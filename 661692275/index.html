

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ykiko">
  <meta name="keywords" content="">
  
    <meta name="description" content="最近打算写一个系列文章详细讨论反射（reflection）这一概念，刚好 C++26 有了新的反射提案，发现知乎上又没有相关的文章，而这个话题又经常被讨论。所以借此机会来聊一聊属于 C++ 的静态反射（static reflection），作为系列预热了。 what is static reflection?首先反射是指什么呢？这个词就像计算机科学领域很多其他的惯用词一样，并没有详细而准确的定义。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++26 静态反射提案解析">
<meta property="og:url" content="https://www.ykiko.me/661692275/index.html">
<meta property="og:site_name" content="ykiko&#39;s blog">
<meta property="og:description" content="最近打算写一个系列文章详细讨论反射（reflection）这一概念，刚好 C++26 有了新的反射提案，发现知乎上又没有相关的文章，而这个话题又经常被讨论。所以借此机会来聊一聊属于 C++ 的静态反射（static reflection），作为系列预热了。 what is static reflection?首先反射是指什么呢？这个词就像计算机科学领域很多其他的惯用词一样，并没有详细而准确的定义。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pica.zhimg.com/v2-e8b1d79d32ae49835de2d5c061d3f058_720w.jpg?source=172ae18b">
<meta property="article:published_time" content="2023-10-16T10:38:26.000Z">
<meta property="article:modified_time" content="2024-06-02T10:18:40.000Z">
<meta property="article:author" content="ykiko">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pica.zhimg.com/v2-e8b1d79d32ae49835de2d5c061d3f058_720w.jpg?source=172ae18b">
  
  
  
  <title>C++26 静态反射提案解析 - ykiko&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.ykiko.me","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ykiko&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++26 静态反射提案解析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-16 18:38" pubdate>
          2023年10月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          31 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++26 静态反射提案解析</h1>
            
            
              <div class="markdown-body">
                
                <p>最近打算写一个系列文章详细讨论反射（reflection）这一概念，刚好 C++26 有了新的反射提案，发现知乎上又没有相关的文章，而这个话题又经常被讨论。所以借此机会来聊一聊属于 C++ 的静态反射（static reflection），作为系列预热了。</p>
<h1 id="what-is-static-reflection"><a href="#what-is-static-reflection" class="headerlink" title="what is static reflection?"></a>what is static reflection?</h1><p>首先反射是指什么呢？这个词就像计算机科学领域很多其他的惯用词一样，并没有详细而准确的定义。关于这个问题，我不打算在这个文章讨论，后续的文章我会详细的解释。本文的重点是 C++ 的 static reflection，为什么强调 static 呢？主要是因为平常我们谈论到反射的时候几乎总是指 Java，C#，Python 这些语言中的反射，而它们的实现方式无一不是把类型擦除，在运行期进行信息的查询。这种方式当然有不可避免的运行时开销，而这种开销显然是违背了 C++ zero cost abstraction 的原则的。为了和它们的反射区分开来，故加上 static 作为限定词，也指示了 C++ 的反射是在编译期完成的。当然，这种说法仍然缺乏一些严谨性。详细的讨论在后续的文章给出，你只需要知道 C++ 的静态反射和 Java，C#，Python 的反射不同，并且主要是在编译期完成的就行了。</p>
<h1 id="what-can-static-reflection-do"><a href="#what-can-static-reflection-do" class="headerlink" title="what can static reflection do?"></a>what can static reflection do?</h1><h2 id="type-as-value"><a href="#type-as-value" class="headerlink" title="type as value"></a>type as value</h2><p>我们都知道随着 C++ 版本的不断更新，编译期计算的功能在不断的增强，通过<code>constexpr/consteval</code>函数我们能很大程度上直接复用运行期的代码，方便的进行编译期计算。完全取代了很久之前使用模板元进行编译期计算的方法。不仅写起来更加方便，编译速度也更快。</p>
<p>观察下面几段编译期计算阶乘的代码：</p>
<p>在 C++03&#x2F;98 的时候，我们只能通过模板递归实例化来实现，而且无法将代码复用到运行期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">factorial</span><br>&#123;<br>    <span class="hljs-keyword">enum</span> &#123; value = N * factorial&lt;N - <span class="hljs-number">1</span>&gt;::value &#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">factorial</span>&lt;<span class="hljs-number">0</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">enum</span> &#123; value = <span class="hljs-number">1</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>C++11 中第一次引入了<code>constexpr</code>函数的概念，使得我们可以编写编译期和运行期复用的代码。但是限制很多，没有变量和循环，我们只能按照纯函数式的风格来编写代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-built_in">factorial</span>(n - <span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> a = <span class="hljs-built_in">factorial</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 编译期计算</span><br>    std::<span class="hljs-type">size_t</span>&amp; n = *<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">size_t</span>(<span class="hljs-number">6</span>);<br>    std::<span class="hljs-type">size_t</span> b = <span class="hljs-built_in">factorial</span>(n); <span class="hljs-comment">// 运行期计算</span><br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    std::cout &lt;&lt; b &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>随着 C++14&#x2F;17 的到来，<code>constexpr</code>函数中的的限制被进一步放开，现在能在 constexpr 函数中使用局部变量和循环了，就像下面这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">factorial</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-type">size_t</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt;= N; ++i)<br>    &#123;<br>        result *= i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>C++20 之后，我们还可以在编译期使用<code>new/delete</code>，我们可以在编译期代码里面使用<code>vector</code>。很多运行期的代码可以直接在编译期复用，而不需要任何更改，只需要在函数前面加上一个 constexpr 标记，再也不用为了进行编译期计算而使用晦涩难懂的模板元编程了。但是，上面的示例仅仅适用于 value，在 C++ 里面除了 value 还有 type 和 higher kind type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">type_list</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> ...Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">find_first_of</span><br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> value = find_first_of&lt;T, Ts...&gt;::value + <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">find_first_of</span>&lt;T, T, Ts...&gt;<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> std::<span class="hljs-type">size_t</span> value = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-built_in">static_assert</span>(find_first_of&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, <span class="hljs-type">char</span>, <span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;::value == <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>由于 type 和 higher kind type 只能是 template arguments，所以还是只能通过<strong>模板递归匹配</strong>处理它们。要是我们能像 value 一样操作它们就好了，这样的话 constexpr 函数也能处理它们了。但是 C++ 又不是像 Zig 那样的语言，type is value。怎么办呢？没关系，我们把 type 映射到 value 不就行了？实现 type as value 的效果。在静态反射加入之前，我们可以通过一些 trick 来实现这个效果。可以在编译期把类型映射到类型名，于是只要对类型名进行计算就好了。关于如何进行这种映射，可以参考 <a href="https://www.ykiko.me/680412313">C++ 中如何优雅进行 enum 到 string 的转换</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">type_list</span>&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(type_list&lt;Ts...&gt;)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// type_name 用于获取编译期类型名</span><br>    std::array arr&#123; <span class="hljs-built_in">type_name</span>&lt;Ts&gt;()... &#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] == <span class="hljs-built_in">type_name</span>&lt;T&gt;())<br>        &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>非常直观的代码，但是如果我们想把值映射回类型就比较困难了。不过没关系，在即将到来的 <strong>static reflection</strong> 中，这种类型和值的双向映射已经成为语言特性了，我们不再需要去手动处理了。</p>
<p>使用<code>^</code>运算符将类型映射到值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> std::meta::info value = ^<span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure>

<p>使用<code>[: ... :]</code>将它映射回去，注意这是 symbol 级别的映射</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Int = <span class="hljs-keyword">typename</span>[:value:]; <span class="hljs-comment">// 在此语境下，typename 可以省略</span><br><span class="hljs-keyword">typename</span>[:value:] a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 相当于 int a = 3;</span><br></code></pre></td></tr></table></figure>

<p>现在我们就能写出下面这样的代码了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">type_list</span><br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> std::array types = &#123;^Ts...&#125;;<br><br>    <span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> N&gt;<br>    <span class="hljs-keyword">using</span> at = <span class="hljs-keyword">typename</span>[:types[N]:]; <br>&#125;;<br><br><span class="hljs-keyword">using</span> Second = <span class="hljs-keyword">typename</span> type_list&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt;::at&lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-built_in">static_assert</span>(std::is_same_v&lt;Second, <span class="hljs-type">double</span>&gt;);<br></code></pre></td></tr></table></figure>

<p>再也不用递归匹配了，我们可以把类型像值一样计算。只要理解了这种映射关系，代码写起来非常简单。用于类型计算的模板元可以退出历史舞台了！</p>
<p>其实<code>^</code>其实不仅能够映射类型，主要有下面这些功能: </p>
<ul>
<li><code>^::</code> —— 代表全局命名空间</li>
<li><code>^namespace-name</code>—— 命名空间名称 </li>
<li><code>^type-id</code>—— 类型 </li>
<li><code>^cast-expression</code> —— 特殊表达式，目前包括包括： </li>
<li><ul>
<li>表示函数或者成员函数的主表达式</li>
</ul>
</li>
<li>表示变量，静态成员变量，结构化绑定的主表达式 </li>
<li>表示非静态成员的主表达式</li>
<li>表示模板的主表达式 </li>
<li>常量表达式</li>
</ul>
<p>同样的<code>[: ... :]</code>也能还原成对应的东西，注意是还原到对应的符号，所以这个运算符被叫做，拼接器（Splicers）</p>
<ul>
<li><code>[: r :]</code> —— 还原成对应的实体或者表达式 </li>
<li><code>typename[: r :]</code> —— 还原成对应的类型 </li>
<li><code>template[: r :]</code> —— 还原成模板参数 </li>
<li><code>namespace[: r :]</code> —— 还原成命名空间 </li>
<li><code>[:r:]::</code> —— 还原成对应的命名空间，类，枚举嵌套说明符</li>
</ul>
<p>看下面的使用示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    [:^x:] = <span class="hljs-number">42</span>;     <span class="hljs-comment">// Okay.  Same as: x = 42;</span><br>    x = [:^(<span class="hljs-number">2</span> * x):];  <span class="hljs-comment">// Error: &quot;2 * x&quot; is a general non-constant expression</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">42</span>;<br>    x = [:^(<span class="hljs-number">2</span> * N):];  <span class="hljs-comment">// Okay: &quot;2 * N&quot; is a constant-expression</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果还原的东西和原本储存的不一样，则会编译错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typename</span>[: ^:: :] x = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure>

<h2 id="metainfo"><a href="#metainfo" class="headerlink" title="metainfo"></a>metainfo</h2><p>光是上面一个特性，就足以让人心动了。然而远远不止如此，获取<code>class</code>等实体元信息的功能也有了。</p>
<p>最基础的，获取类型名（变量名，字段名都可以用这个函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std::meta <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">name_of</span><span class="hljs-params">(info r)</span> -&gt; string_view</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">display_name_of</span><span class="hljs-params">(info r)</span> -&gt; string_view</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>比如可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">display_name_of</span>(^std::vector&lt;<span class="hljs-type">int</span>&gt;) <span class="hljs-comment">//  =&gt; std::vector&lt;int&gt;</span><br><span class="hljs-built_in">name_of</span>(^std::vector&lt;<span class="hljs-type">int</span>&gt;) <span class="hljs-comment">// =&gt; std::vector&lt;int, std::allocator&lt;int&gt;&gt;</span><br></code></pre></td></tr></table></figure>

<p>判断一个模板是不是另一个高阶模板的特化 和 萃取高阶模板里面的参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std::meta <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">template_of</span><span class="hljs-params">(info r)</span> -&gt; info</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">template_arguments_of</span><span class="hljs-params">(info r)</span> -&gt; vector&lt;info&gt;</span>;<br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">template_of</span>(<span class="hljs-built_in">type_of</span>(^v)) == ^std::vector);<br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">template_arguments_of</span>(<span class="hljs-built_in">type_of</span>(^v))[<span class="hljs-number">0</span>] == ^<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure>

<p>把模板参数填到高阶模板中去</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std::meta <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">substitute</span><span class="hljs-params">(info templ, span&lt;info <span class="hljs-type">const</span>&gt; args)</span> -&gt; info</span>; <br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">substitute</span>(^std::vector, std::vector&#123;^<span class="hljs-type">int</span>&#125;);<br><span class="hljs-keyword">using</span> T = [:r:]; <span class="hljs-comment">// Ok, T is std::vector&lt;int&gt;</span><br></code></pre></td></tr></table></figure>

<p>获取<code>struct</code>,<code>class</code>，,<code>union</code>,<code>enum</code>的成员信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std::meta<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Fs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">members_of</span><span class="hljs-params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Fs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">nonstatic_data_members_of</span><span class="hljs-params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">members_of</span>(class_type, is_nonstatic_data_member, filters...);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Fs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">bases_of</span><span class="hljs-params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">members_of</span>(class_type, is_base, filters...);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Fs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">enumerators_of</span><span class="hljs-params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Fs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">subobjects_of</span><span class="hljs-params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>待会用这个我们就可以实现遍历结构体，枚举等功能。进一步就可以实现序列化，反序列化等高级功能。后文会有一些示例。除此之外，还有一些其它的功能的编译期函数，上面只展示了一部分内容，更多的 API 可以参考提案中的内容。由于提供了直接获取高级模板里面参数的函数，再也不用用模板去进行类型萃取了！用于类型萃取的模板元也可以退出历史舞台了。</p>
<h1 id="better-compile-facilities"><a href="#better-compile-facilities" class="headerlink" title="better compile facilities"></a>better compile facilities</h1><p>反射的主题部分大致已经介绍完了，现在来聊聊其它的。虽然这部分是其它提案的内容，但是他们可以使代码写起来更见轻松，让代码有更强的表达能力。</p>
<h2 id="template-for"><a href="#template-for" class="headerlink" title="template for"></a>template for</h2><p>在 C++ 里面如何生成大量的代码段是一个非常不好解决的问题，得益于 C++ 独（逆）特（天）的机制，目前的代码片段生成几乎都是基于 lambda 表达式 + 可变参数包展开。看下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">dynamic_tuple_get</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">auto</span>&amp; tuple)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> size = std::tuple_size_v&lt;std::<span class="hljs-type">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(tuple)&gt;&gt;;<br>    [&amp;]&lt;std::<span class="hljs-type">size_t</span> ...Is&gt;(std::index_sequence&lt;Is...&gt;)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> f = [&amp;]&lt;std::<span class="hljs-type">size_t</span> Index&gt;<br>        &#123;<br>            <span class="hljs-keyword">if</span>(Index == N)<br>            &#123;<br>                std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;Index&gt;(tuple) &lt;&lt; std::endl;<br>            &#125;<br>        &#125;;<br>        (f.<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;Is&gt;(), ...);<br>    &#125;(std::make_index_sequence&lt;size&gt;&#123;&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::tuple tuple = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3.14</span>, <span class="hljs-number">42</span>&#125;;<br>    <span class="hljs-keyword">auto</span> n1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dynamic_tuple_get</span>(n1, tuple); <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">auto</span> n2 = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">dynamic_tuple_get</span>(n2, tuple); <span class="hljs-comment">// 42</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个很经典的例子，原理是通过多个分支判断，将运行期变量分发到编译期常量。实现根据运行期的<code>index</code>来访问<code>tuple</code>里面的元素。<strong>注：这里效率更高的办法是，编译期生成一个函数指针数组，然后直接根据index进行跳转，不过这里只是做个展示，不用纠结太多。</strong></p>
<p>上面的代码展开后相当于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">dynamic_tuple_get</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">auto</span>&amp; tuple)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(N == <span class="hljs-number">0</span>)<br>    &#123;<br>        std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(tuple) &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span>(N == <span class="hljs-number">3</span>)<br>    &#123;<br>        std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">3</span>&gt;(tuple) &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以发现，我们用了极其别扭的写法只是为了实现极其简单的效果。而且由于 lambda 其实是个函数，其实没法直接从 lambda 里面直接返回到上一级函数。导致我们多做了很多多余的<code>if</code>判断。</p>
<p>换成<code>template for</code>则代码看起来清爽很多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">dynamic_tuple_get</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">auto</span>&amp; tuple)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> size = std::tuple_size_v&lt;std::<span class="hljs-type">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(tuple)&gt;&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-title">for</span><span class="hljs-params">(<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> num : std::views::iota(<span class="hljs-number">0</span>, size))</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(num == N)<br>        &#123;<br>            std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;num&gt;(tuple) &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以认为<code>template for</code>是 lambda 展开的语法糖加强版，反正非常好用就是了。如果这个加入了，利用模板元生成函数（代码）就可以退休了。</p>
<h2 id="non-transient-constexpr-allocation"><a href="#non-transient-constexpr-allocation" class="headerlink" title="non-transient constexpr allocation"></a>non-transient constexpr allocation</h2><p>这个提案主要是将两个问题联合起来讨论了。</p>
<ul>
<li>C++ 可以通过控制模板实例化 static 成员在数据段预留位置，可以看作编译期内存分配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>... items&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">make_array</span><br>&#123;<br>    <span class="hljs-keyword">using</span> type = std::<span class="hljs-type">common_type_t</span>&lt;<span class="hljs-keyword">decltype</span>(items)...&gt;;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> type value[<span class="hljs-keyword">sizeof</span> ...(items)] = &#123;items...&#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>... items&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> make_array_v = make_array&lt;items...&gt;::value;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> arr = make_array_v&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&gt;;<br>    std::cout &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>    std::cout &lt;&lt; arr[<span class="hljs-number">1</span>] &lt;&lt; std::endl; <span class="hljs-comment">//成功在数据段预留位置，存放的是 1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>C++20 允许了<code>constexpr</code>中进行<code>new</code>，但是编译期<code>new</code>的内存必需要在编译期<code>delete</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-keyword">auto</span>... Is)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;Is...&#125;;<br>    <span class="hljs-keyword">return</span> v.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那就不能在编译期<code>new</code>里之后，不<code>delete</code>？实际数据放在数据段？这就是这个提案要解决的问题，它希望我们能使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 全局的</span><br></code></pre></td></tr></table></figure>

<p>主要难点是，在数据段分配的内存不像在堆上的内存一样有所有权，不需要<code>delete</code>。只要解决了这个问题，就能使用编译期的<code>std::map</code>，<code>std::vector</code>并且保留到运行期。这个作者的做法是进行标记。具体的细节这里就不说了。如果这个加入了，利用模板元打常量表也可以退出了。</p>
<h1 id="do-something-fun"><a href="#do-something-fun" class="headerlink" title="do something fun"></a>do something fun</h1><p>好了，上面说了那么多，让我们用它们来做些有趣的东西！</p>
<h2 id="print-any-type"><a href="#print-any-type" class="headerlink" title="print any type"></a>print any type</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-title">for</span><span class="hljs-params">(<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> member : nonstatic_data_members_of(type_of(^t)))</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(is_class(type_of(member)))</span> </span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">// 如果是 class 就递归遍历成员</span><br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&#123;&#125;= &quot;</span>, <span class="hljs-built_in">name_of</span>(member));<br>            <span class="hljs-built_in">print</span>(t.[:member:]);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//非类类型可以直接打印</span><br>            std::<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&#123;&#125;= &#123;&#125;&quot;</span>, <span class="hljs-built_in">name_of</span>(member), t.[:member:]); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="enum-to-string"><a href="#enum-to-string" class="headerlink" title="enum to string"></a>enum to string</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt; <span class="hljs-function"><span class="hljs-keyword">requires</span> std::is_enum_v&lt;E&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::string <span class="hljs-title">enum_to_string</span><span class="hljs-params">(E value)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> e : std::meta::members_of(^E))</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (value == [:e:]) <br>        &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(std::meta::<span class="hljs-built_in">name_of</span>(e));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;unnamed&gt;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h1><p>花费了很长的篇幅介绍 C++ 的 static reflection。其实我非常喜欢 C++ 的编译期计算，对它的发展史也非常感兴趣。C++ 的编译期计算是一步步摸索出来的，有很多富有智慧的大师提出他们的独特想法，让不可能的事情变成现实。从 C++03 的变态模板元，到 C++11 的<code>constexpr</code>变量，到 C++14 ~23 对<code>constexpr</code>函数中的限制逐渐放开，把越来越多的操作移到编译期。再到如今的 static reflection，C++ 正在逐步脱离模板元的魔爪。之前那些老旧的模板元写法全都可以淘汰掉了！！！如果你没写过以前的老式模板元代码，大概是体会不到它有多可怕的。</p>
<p>为了让静态反射能早点进入标准，作者团队特地选了原本提案的一部分核心子集。希望如作者所愿，静态反射能在 C++26 进入标准！当然，核心部分先进入，之后再补充更多更加有用的功能，所以这绝不是反射的全部内容。本文只是对该提案的粗略解读和翻译，想要详细了解的还请阅读下方链接中的提案，相关进展持续更新中：</p>
<p><a target="_blank" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html#ref-P2670R1" rel="external nofollow noreferrer" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R0</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html#ref-P2670R1</span></span></span></a></p>
<p><a target="_blank" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r1.html" rel="external nofollow noreferrer" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R1</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r1.html</span></span></span></a></p>
<p><a target="_blank" href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2024/p2996r2.html" rel="external nofollow noreferrer" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R2</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2024/p2996r2.html</span></span></span></a></p>
<br>

<p><a target="_blank" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r3.html" rel="external nofollow noreferrer" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R3</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r3.html</span></span></span></a></p>
<p>实验编译器：</p>
<ul>
<li>在线尝试： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://godbolt.org/z/13anqE1Pa">https://godbolt.org/z/13anqE1Pa</a></li>
<li>本地构建： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/bloomberg/clang-p2996.git">clang-p2996</a></li>
</ul>
<p>反射系列文章：</p>
<p><a target="_blank" href="https://www.ykiko.me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;"></span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.ykiko.me/669358870</span></span></span></a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++26 静态反射提案解析</div>
      <div>https://www.ykiko.me/661692275/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ykiko</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/" rel="external nofollow noreferrer">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/669358870/" title="写给 C++ 程序员的反射教程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">写给 C++ 程序员的反射教程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/659510753/" title="C++ 成员指针完全解析">
                        <span class="hidden-mobile">C++ 成员指针完全解析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

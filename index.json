
[{"content":"","date":"June 7, 2024","externalUrl":null,"permalink":"/articles/","section":"Articles","summary":"","title":"Articles","type":"articles"},{"content":"参加了 Google Summer of Code 2024，主要的任务就是为一个 Python 解释器 实现 pybind11 的兼容性接口。说是实现兼容性接口，实际上相当于重写 pybind11 了，所以最近一直在读它的源码。\n可能有的读者不太清楚 pybind11 是什么，简单来说 pybind11 是一个中间件，让你可以方便进行 Python 与 C++ 代码之间的交互。比如在 C++ 中内嵌 Python 解释器，或者把 C++ 代码编译成动态库以供 Python 调用。具体的内容还请见官方文档。\n最近基本把框架的大体的运作逻辑理清了。现在回过头来看，pybind11 不愧是 C++ 和 Python 绑定的事实标准，有很多巧妙的设计。它这套交互逻辑也完全可以套用到 C++ 和其它有 GC 的语言的交互上，比如 JS 和 C#（虽然现在并没有 jsbind11 和 csharpbind11 之类的东西）。最近可能我会写一系列相关的文章，去掉一些繁琐的细节，介绍其中一些共用的思想。\n这篇文章主要是讨论 pybind11 对象设计一些有意思的点。\nPyObject # 我们都知道 Python 中，一切皆对象，全都是object。但是 pybind11 实际上是需要和 CPython 这种 Python 的具体实现打交道的。那一切皆对象在 CPython 中的体现是什么呢？答案是PyObject*。接下来让我们“看见” Python，理解实际的 Python 代码是如何运作在 CPython 中的。\n创建一个对象实际上就是创建一个PyObject*\nx = [1, 2, 3] CPython 中有专门的 API 来创建内建类型的对象，上面这句话大概就会被翻译成\nPyObject* x = PyList_New(3); PyList_SetItem(x, 0, PyLong_FromLong(1)); PyList_SetItem(x, 1, PyLong_FromLong(2)); PyList_SetItem(x, 2, PyLong_FromLong(3)); 这样的话，is的作用就很好理解了，就是用来判断两个指针的值是否相同。而所谓的默认浅拷贝的原因也就是因为默认的赋值只是指针的赋值，不涉及它指向的元素。\nCPython 也提供了一系列的 API 用来操作 PyObject* 指向的对象，例如\nPyObject* PyObject_CallObject(PyObject *callable_object, PyObject *args); PyObject* PyObject_CallFunction(PyObject *callable_object, const char *format, ...); PyObject* PyObject_CallMethod(PyObject *o, const char *method, const char *format, ...); PyObject* PyObject_CallFunctionObjArgs(PyObject *callable, ...); PyObject* PyObject_CallMethodObjArgs(PyObject *o, PyObject *name, ...); PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name); PyObject* PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v); int PyObject_HasAttrString(PyObject *o, const char *attr_name); PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name); int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v); int PyObject_HasAttr(PyObject *o, PyObject *attr_name); PyObject* PyObject_GetItem(PyObject *o, PyObject *key); int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v); int PyObject_DelItem(PyObject *o, PyObject *key); 这些函数在 Python 中基本都有直接对应，看名字就知道是干什么用的了。\nhandle # 由于 pybind11 要支持在 C++ 中操作 Python 对象，首要任务就是对上述这些 C 风格的 API 进行封装。具体是由handle这个类型来完成的。handle是对PyObject*的简单包装，并且封装了一些成员函数，例如\n大概像下面这样\nclass handle { protected: PyObject* m_ptr; public: handle(PyObject* ptr) : m_ptr(ptr) {} friend bool operator==(const handle\u0026amp; lhs, const handle\u0026amp; rhs) { return PyObject_RichCompareBool(lhs.m_ptr, rhs.m_ptr, Py_EQ); } friend bool operator!=(const handle\u0026amp; lhs, const handle\u0026amp; rhs) { return PyObject_RichCompareBool(lhs.m_ptr, rhs.m_ptr, Py_NE); } // ... }; 大部分函数都是像上面这样简单包装一下，但有一些函数比较特殊。\nget/set # 根据 C++ 之父 Bjarne Stroustrup 在《The Design and Evolution of C++》中的说法，引入引用（左值）类型的部分原因是为了使得用户能够对返回值进行赋值，让[]这样的运算符的重载变的更加自然。例如：\nstd::vector\u0026lt;int\u0026gt; v = {1, 2, 3}; int x = v[0]; // get v[0] = 4; // set 如果没有引用，就只能返回指针，那么上面的代码就得写成这样\nstd::vector\u0026lt;int\u0026gt; v = {1, 2, 3}; int x = *v[0]; // get *v[0] = 4; // set 相比之下，使用引用是不是美观的多呢？这个问题在其它编程语言中也存在，但不是所有语言都采用这种解决办法。例如，Rust 选择自动解引用，编译器在合适的时机自动添加*来解引用，这样也就不需要多写上面那个*了。但是，这两种方法对 Python 来说都不行，因为 Python 中根本没有解引用这个说法，也不区分什么左值和右值。那怎么办呢？答案是区分getter和setter。\n例如，如果要重载[]：\nclass List: def __getitem__(self, key): print(\u0026#34;__getitem__\u0026#34;) return 1 def __setitem__(self, key, value): print(\u0026#34;__setitem__\u0026#34;) a = List() x = a[0] # __getitem__ a[0] = 1 # __setitem__ Python 会检查语法结构，如果[] 出现在=的左边，就会调用__setitem__，否则就会调用__getitem__。实际上有挺多语言采用类似的设计的，例如 C# 的this[]运算符重载。\n甚至连.运算符都可以重载，只需要重写__getattr__和__setattr__：\nclass Point: def __getattr__(self, key): print(f\u0026#34;__getattr__\u0026#34;) return 1 def __setattr__(self, key, value): print(f\u0026#34;__setattr__\u0026#34;) p = Point() x = p.x # __getattr__ p.x = 1 # __setattr__ pybind11 希望 handle 也能实现这样的效果，即在合适的时机调用__getitem__和__setitem__。例如：\npy::handle obj = py::list(1, 2, 3); obj[0] = 4; // __setitem__ auto x = obj[0]; // __getitem__ x = py::int_(1); 对应的 Python 代码是\nobj = [1, 2, 3] obj[0] = 4 x = obj[0] x = 1 accessor # 接下来就让我们重点讨论如何实现这样的效果。首先考虑operator[]的返回值，由于可能要调用__setitem__，所以这里我们返回一个代理对象。里面会把key存下来以备后续调用\nclass accessor { handle m_obj; ssize_t m_key; handle m_value; public: accessor(handle obj, ssize_t key) : m_obj(obj), m_key(key) { m_value = PyObject_GetItem(obj.ptr(), key); } }; 下面一个问题就是如何区分obj[0] = 4和x = int_(1)，使得前面一种情况调用__setitem__，后面一种情况就是简单的对x赋值。注意到上面两种情况的关键性区别，左值和右值\nobj[0] = 4; // assign to rvalue auto x = obj[0]; x = 1; // assign to lvalue 如何让operator=根据操作数的值类别 (value category) 调用不同的函数呢？这就要用到一个比较少见的小技巧了，我们都知道可以在成员函数上加上const限定符，从而允许这个成员函数在 const 对象上调用。\nstruct A { void foo() {} void bar() const {} }; int main() { const A a; a.foo(); // error a.bar(); // ok } 除此之外，其实还可以加引用限定符\u0026amp;和\u0026amp;\u0026amp;，效果就是要求expr.f()的这个expr是左值还是右值。这样我们就可以根据左值和右值调用不同的函数了。\nstruct A { void foo() \u0026amp; {} void bar() \u0026amp;\u0026amp; {} }; int main() { A a; a.foo(); // ok a.bar(); // error A().bar(); // ok A().foo(); // error } 利用这个特性我们就能实现上面的效果了\nclass accessor { handle m_obj; ssize_t m_key; handle m_value; public: accessor(handle obj, ssize_t key) : m_obj(obj), m_key(key) { m_value = PyObject_GetItem(obj.ptr(), key); } // assign to rvalue void operator=(handle value) \u0026amp;\u0026amp; { PyObject_SetItem(m_obj.ptr(), m_key, value.ptr()); } // assign to lvalue void operator=(handle value) \u0026amp; { m_value = value; } }; lazy evaluation # 更进一步，我们希望这个代理对象仿佛就像一个handle一样，可以使用handle的所有方法。这很简单，直接继承handle就行了。\nclass accessor : public handle { handle m_obj; ssize_t m_key; public: accessor(handle obj, ssize_t key) : m_obj(obj), m_key(key) { m_ptr = PyObject_GetItem(obj.ptr(), key); } // assign to rvalue void operator=(handle value) \u0026amp;\u0026amp; { PyObject_SetItem(m_ptr, m_key, value.ptr()); } // assign to lvalue void operator=(handle value) \u0026amp; { m_ptr = value; } }; 到这似乎就结束了，但是注意到我们的__getitem__是在构造函数中调用的，也就是说即使后面没用到获取到的值，也会调用。感觉有进一步优化的空间，能不能通过一些手段把这个求值 lazy 化呢？只在需要调用handle里面这些函数的时候才去调用__getitem__呢？\n目前这样直接继承handle肯定是不行的，不可能在每次成员函数调用之前插入一次判断，然后决定要不要调用__getitem__。可以让handle和accessor都继承一个基类，这个基类里面有一个有一个接口，用来实际获取要操作的指针\nclass object_api{ public: virtual PyObject* get() = 0; bool operator==(const handle\u0026amp; rhs) { return PyObject_RichCompareBool(get(), rhs.ptr(), Py_EQ); } // ... }; 然后handle和accessor都继承这个基类，这时候accessor就可以在这里对__getitem__进行 lazy evaluation 了。\nclass handle : public object_api { PyObject* get() override { return m_ptr; } }; class accessor : public handle { PyObject* get() override { if (!m_ptr) { m_ptr = PyObject_GetItem(m_obj.ptr(), m_key); } return m_ptr; } }; 这样并不涉及到类型擦除，只是需要子类暴露出一个接口，所以理所应当的我们可以使用 CRTP 来去虚化\ntemplate \u0026lt;typename Derived\u0026gt; class object_api { public: PyObject* get() { return static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;get(); } bool operator==(const handle\u0026amp; rhs) { return PyObject_RichCompareBool(get(), rhs.ptr(), Py_EQ); } // ... }; class handle : public object_api\u0026lt;handle\u0026gt; { PyObject* get() { return m_ptr; } }; class accessor : public object_api\u0026lt;accessor\u0026gt; { PyObject* get() { if (!m_ptr) { m_ptr = PyObject_GetItem(m_obj.ptr(), m_key); } return m_ptr; } }; 这样我们就在不额外引入其它运行时开销的情况下把__getitem__的调用 lazy 化了。\nConclusion # 我们常说 C++ 实在是太复杂了，各种眼花缭乱的特性太多了，不同特性之间还经常打架。那换一个角度来看待，特性多，意味着用户就有更多的选择，有更多的设计空间，就能组装出上述这样精彩的设计。我想很难有另外一门语言能实现这样的效果。或许这就是 C++ 的魅力所在吧。\n文章到这里就结束了，感谢你的阅读，欢迎评论区讨论交流。\n","date":"June 7, 2024","externalUrl":null,"permalink":"/articles/702197261/","section":"Articles","summary":"参加了 Google Summer of Code 2024，主要的任务就是为一个 Python 解释器 实现 pybind11 的","title":"Python 与 C++ 的完美结合：pybind11 中的对象设计","type":"articles"},{"content":"","date":"June 7, 2024","externalUrl":null,"permalink":"/","section":"ykiko's blog","summary":"","title":"ykiko's blog","type":"page"},{"content":"单例模式 (Singleton Pattern) 是一种常见的设计模式，往往应用于配置系统，日志系统，数据库连接池等需要确保对象唯一性的场景。但是单例模式真的能保证单例吗？如果唯一性得不到保证会产生什么后果呢？\n既然写了这篇文章，那答案肯定是否了。知乎上已经有很多相关的讨论了，比如 C++单例模式跨 DLL 是不是就是会出问题？ 和 动态库和静态库混合使用下的单例模式 BUG。不过大部分都是遇到问题以后，贴一下解决方案，很零散，并没有系统分析问题产生的原因。于是，我写了这篇文章来详细讨论一下这个问题。\n明确问题 # 首先我们要明确讨论的问题，以 C++11 常见的单例模式实现为例：\nclass Singleton { public: Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton\u0026amp; instance() { static Singleton instance; return instance; } private: Singleton() = default; }; 我们将默认构造设置为private并且显式delete拷贝构造和赋值运算符，这样的话用户只能通过instance这个函数来获取我们预先创建好的对象，不能自己通过构造函数创建一个对象。而使用静态局部变量是为了保证这个变量的初始化线程安全。\n但其实，单例对象和一个普通的全局变量并没有什么区别。在 C++ 中，它们都属于 静态储存期 (static storage duration)，编译器对它们的处理是类似的（只是初始化方式上有点区别）。而所谓的单例模式，只是在语言层面通过一些手段，防止用户不小心创建多个对象。\n那我们讨论的问题其实可以等价为：C++ 中的全局变量是唯一的吗？\n一个定义 # 首先得区分变量的声明和定义。我们都知道，头文件中一般是不能写变量定义的。否则如果这个头文件被多个源文件包含，就会出现多个定义，链接的时候就会报multiple definition of variable的错误。所以我们一般会在头文件中使用extern声明变量，然后在对应的源文件中定义变量。\n那编译器是如何处理全局变量定义的呢？\n假设我们定义一个全局变量\nint x = 1; 其实不会产生任何的指令，编译器会在这个编译单元（每个源文件）编译产物的符号表中，增加一个符号x。在静态储存（具体的实现可能是 bss 段或者 rdata 段等等）中给符号x预留4字节的空间。视初始化方式（静态初始化 或者 动态初始化）来决定这块内存的数据如何填充。\n由于只有一个定义，那么这种情况肯定是全局唯一的了。\n多个定义 # 我们都知道 C++ 并没有官方的构建系统，不同的库使用不同的构建系统，就不方便互相使用了（目前的事实标准来看是 cmake）。这个现状使得 header-only 库变得越来越流行，include即用，谁不喜欢呢？但是 header-only 也就意味着所有的代码都写在头文件中，如何在头文件中定义变量并且使得它能直接被多个源文件包含而不导致链接错误呢？\n在 C++17 之前，并没有直接的办法。但有一些间接的办法，考虑到inline函数或者模板函数的定义都可以出现在多个源文件中，并且 C++ 标准保证它们具有相同的地址（相关的讨论可以参考 C++ 究竟代码膨胀在哪里？）。于是只需要在这些函数中定义静态局部变量，效果上就相当于在头文件中定义变量了\ninline int\u0026amp; x() { static int x = 1; return x; } template\u0026lt;typename T = void\u0026gt; int\u0026amp; y() { static int y = 1; return y; } 在 C++17 之后，我们可以直接使用inline来标记变量，使得这个变量的定义可以出现在多个源文件中。使用它，我们就可以直接在头文件中定义变量了\ninline int x = 1; 我们知道，把变量标记为static也可以使得它在多个源文件中出现定义。那inline和static有什么区别呢？关键就在于，static标记的变量是内部链接的，每个编译单元都有自己的一份实例，你在不同的编译单元取的地址是不一样的。而inline标记的变量是外部链接的，C++ 标准保证你在不同编译单元取同一个inline变量的地址是一样的。\n真的单例吗 # 实践是检验真理的唯一标准，我们来实验一下，C++ 标准有没有骗我们呢？\n示例代码如下\n// src.cpp #include \u0026lt;cstdio\u0026gt; inline int x = 1; void foo() { printf(\u0026#34;addreress of x in src: %p\\n\u0026#34;, \u0026amp;x); } // main.cpp #include \u0026lt;cstdio\u0026gt; inline int x = 1; extern void foo(); int main() { printf(\u0026#34;addreress of x in main: %p\\n\u0026#34;, \u0026amp;x); foo(); } 先简单一点，把这两个源文件一起编译成一个可执行文件，在 Windows(MSVC) 上和 Linux(GCC) 上分别尝试\n# Windows: addreress of x in main: 00007FF7CF84C000 addreress of x in src: 00007FF7CF84C000 # Linux: addreress of x in main: 0x404018 addreress of x in src: 0x404018 可以发现确实是相同的地址。下面我们试一下把src.cpp编译成动态库，main.cpp链接这个库，编译运行。看看是不是像很多人说的那样，一遇到动态库就不行了呢？注意在 Windows 上要显式给foo加上__declspec(dllexport)，否则动态库不会导出这个符号。\n# Windows: addreress of x in main: 00007FF72F3FC000 addreress of x in src: 00007FFC4D91C000 # Linux: addreress of x in main: 0x404020 addreress of x in src: 0x404020 夭寿啦，为什么 Windows 和 Linux 的情况不一样呢？\n符号导出 # 一开始，我简单的以为是动态库默认符号导出规则的问题。因为 GCC 编译动态库的时候，会默认把所有符号导出。而 MSVC 恰恰相反，默认不导出任何符号，全部都要手动导出。显然只有一个符号被导出了，链接器才能“看见”它，然后才能合并来自不同动态库的符号。\n抱着这个想法，我尝试寻找在 GCC 上自定义符号导出的手段，最终找到了 Visibility - GCC Wiki。在编译的时候使用-fvisibility=hidden，这样的话符号就都是默认 hidden（不导出）了。然后使用__attribute__((visibility(\u0026quot;default\u0026quot;)))或者它在 C++ 的等价写法[[gnu::visibility(\u0026quot;default\u0026quot;)]]来显式标记需要导出的符号。于是我修改了代码\n// src.cpp #include \u0026lt;cstdio\u0026gt; inline int x = 1; [[gnu::visibility(\u0026#34;default\u0026#34;)]] void foo () { printf(\u0026#34;addreress of x in src: %p\\n\u0026#34;, \u0026amp;x); } // main.cpp #include \u0026lt;cstdio\u0026gt; inline int x = 1; extern void foo(); int main() { printf(\u0026#34;addreress of x in main: %p\\n\u0026#34;, \u0026amp;x); foo(); } 注意，我只导出了foo用于函数调用，这两个inline变量都没有导出。编译运行\naddreress of x in main: 0x404020 addreress of x in src: 0x7f5a45513010 就像我们预期的那样，地址果然不一样。这就验证了：符号被导出，是链接器合并符号的必要条件，但是并不充分。如果在 Windows 上能通过改变默认符号导出规则，使得 inline 变量具有相同的地址，那么充分性就得到验证。当我满怀激动的开始尝试，却发现事情并非这么简单。\n注意到 Windows 上的 GCC（MinGW64 工具链）仍然默认导出所有符号，按照设想，变量地址应该相同。尝试结果如下\naddreress of x in main: 00007ff664a68130 addreress of x in src: 00007ffef4348110 可以发现结果并不相同，我不理解，并认为是编译器的 BUG。转而使用 MSVC，并且发现 CMake 提供了一个 CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS 选项，打开之后会自动导出所有符号（通过 dumpbin 实现的）。遂尝试，编译运行，结果如下\naddreress of x in main: 00007FF60B11C000 addreress of x in src: 00007FFEF434C000 哦，结果还是不同，我意识到我的猜测出问题了。但是查阅了很久资料，也没找到为什么。后来还是在 TG 的 C++ 群提问，才得到了答案。\n简单来说，在 ELF 不区分符号是来自哪个.so的，先加载谁就用谁，所以遇到多个inline变量就使用第一个加载的。但是 PE 文件的符号表指定了某个符号从哪个dll引入，这样就会导致只要一个变量dllexport了，那么这个 dll 一定会使用自己的变量。即使多个dll同时dllexport同一个变量，也没法合并，Windows 上 dll 的格式就限制了这件事情是做不到的。\n动态库链接时的符号解析问题实际上可能还要复杂的得多，还有很多其它的情况，例如通过dlopen等函数主动加载动态库。之后有时间的话，可能会专门写一篇文章来分析这个事情，这里就不多说了。\n不唯一如何？ # 为什么要保证“单例”变量的唯一性呢？这里拿 C++ 标准库来举例子\n我们都知道 type_info 可以用于运行时区分不同的类型，标准库的std::function和std::any这些类型擦除的设施就依赖于它来实现。它的constructor和operator=就被deleted了，我们只能通过typeid(T)来获取对应type_info对象的引用，对象的创建则由编译器来负责。\n怎么样，是不是完全符合单例模式呢？下一个问题是，编译器是如何判断两个type_info对象是否相同的呢？一个典型的实现如下\n#if _PLATFORM_SUPPORTS_UNIQUE_TYPEINFO bool operator==(const type_info\u0026amp; __rhs) const { return __mangled_name == __rhs.__mangled_name; } #else bool operator==(const type_info\u0026amp; __rhs) const { return __mangled_name == __rhs.__mangled_name || strcmp(__mangled_name, __rhs.__mangled_name) == 0; } #endif 上面的代码很好理解，如果保证type_info的地址是唯一的，那么直接比较__mangled_name就行了（它是const char*所以是指针比较）。若不然，就先比较地址然后比较类型名。具体到三大标准库的实现：\nlibstdc++ 使用__GXX_MERGED_TYPEINFO_NAMES来控制是否启用 libc++ 使用_LIBCPP_TYPEINFO_COMPARATION_IMPLEMENTATION来决定采用的方式（实际上还有一种特殊的 BIT_FLAG 模式） msvc stl (crt/src/vcruntime/std_type_info.cpp) 由于前面提到的 Windows 上 dll 的限制，总是使用第二种方式 举这个例子的目的是，为了说明，单例变量地址的唯一性会影响我们代码的编写方式。如果不唯一我们可能被迫要书写一些代码进行防御，可能会影响性能，而如果没写的话，甚至会直接导致逻辑错误。\n解决方案 # 只提出问题可不行，得要解决，如何确保单例唯一呢？\n在 Linux 上就很简单了，如果同一个变量出现在多个动态库中，只要确保这些动态库都把这个符号设置为对外可见就行了。而编译器默认的行为也就是对外可见，所以基本上不用担心这个问题。\n在 Windows 上呢？非常麻烦了，必须要确保只有一个 dll 使用dllexport导出了这个符号，其它所有的dll必须要使用dllimport。这件事情常常不太好做，你可能写着写着就忘记，是哪个 dll 负责导出的这个符号了。怎么办呢？那就是专门用一个 dll 来管理所有的单例变量，也就是说这个 dll 负责所有dllexport所有的单例变量，除此之外的 dll 都只 dllimport 就行了。之后添加和修改都在这个 dll 中进行，这样就比较好管理了。\n到这文章就结束了，说实话我并不确定上面的讨论有没有覆盖所有的情形。如果有错误欢迎评论区留言讨论。\n","date":"May 9, 2024","externalUrl":null,"permalink":"/articles/696878184/","section":"Articles","summary":"单例模式 (Singleton Pattern) 是一种常见的设计模式，往往应用于配置系统，日志系","title":"C++ 中的单例模式真的“单例”吗？","type":"articles"},{"content":"Compiler Explorer 是一个非常流行的 C++ 在线编译器，可用于测试不同的编译执行环境，或者分享代码。作为一个 C++ 爱好者，我几乎每天都要和它打交道，使用频率之高远超我的想象。同时，我也是一个重度 VSCode 用户，几乎所有的事情都在 VSCode 中完成。考虑到经常在本地写代码然后拷贝到 Compiler Explorer 上去，总觉得不太舒服，有时候直接就在它的网页编辑器上改了，但是又没有代码补全，也不舒服。所以我和 @iiirhe 合作编写了这个插件 Compiler Explorer for VSCode，基于 Compiler Explorer 提供的 API 将 Compiler Explorer 集成到 VSCode 中，使得用户可以在 VSCode 中直接使用 Compiler Explorer 的功能。\n现在你可以在 VSCode 插件市场搜索到这个插件\n效果展示 # 单文件支持 # 让我们从上往下以此介绍\n这个三个按钮的功能依次是：\nCompile All：编译所有的编译器实例 Add New：添加一个新的编译器实例 Share Link：根据当前的编译器实例生成一个链接，并复制到剪贴板 这四个按钮的功能依次是：\nAdd CMake：添加一个 CMake 编译器实例（后面会细说） Clear All：关闭所有用于展示的webview面板 Load Link：根据输入的链接加载编译器实例的信息 Remove All：删除所有的编译器实例 这个三个按钮的功能依次是：\nRun：编译这个编译器实例 Clone：克隆这个编译器实例 Remove：删除这个编译器实例 下面这些用于设置编译器实例的参数：\nCompiler：点击右侧的按钮可以选择编译器版本 Input：选择源代码文件，默认是active即当前活跃的编辑器 Output：输出编译结果的文件，默认使用webview Options：编译选项，点击右侧按钮可以打开输入框 Execute Arguments：传递给可执行文件的参数 Stdin：用于标准输入的缓冲区 Filters：一些选项 多文件支持 # 使用Add CMake按钮可以添加一个 CMake 编译器实例，这个实例可以用于编译多个文件。\n大部分选项和单文件的编译器实例一样，额外多出了两个\nCMake Arguments：传递给 CMake 的参数 Source：CMakelists.txt 所在的文件夹路径 注意，由于多文件编译需要把所有用到的文件都上传到服务器，所以我们默认会读取你指定的目录下的所有文件（无论后缀名），所以目前请不要指定文件数量过多的文件夹。之后可能会添加一些选项允许用户过滤掉一些文件，但是目前还没有。\n一些用户设置 # compiler-explorer.default.options：使用+号创建编译器时的默认参数\n\u0026#34;compiler-explorer.default.options\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The default compiler configuration\u0026#34;, \u0026#34;default\u0026#34;: { \u0026#34;compiler\u0026#34;: \u0026#34;x86-64 gcc 13.2\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;c++\u0026#34;, \u0026#34;options\u0026#34;: \u0026#34;-std=c++17\u0026#34;, \u0026#34;exec\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;stdin\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cmakeArgs\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;src\u0026#34;: \u0026#34;workspace\u0026#34;, \u0026#34;filters\u0026#34;: { \u0026#34;binaryObject\u0026#34;: false, \u0026#34;binary\u0026#34;: false, \u0026#34;execute\u0026#34;: false, \u0026#34;intel\u0026#34;: true, \u0026#34;demangle\u0026#34;: true, \u0026#34;labels\u0026#34;: true, \u0026#34;libraryCode\u0026#34;: true, \u0026#34;directives\u0026#34;: true, \u0026#34;commentOnly\u0026#34;: true, \u0026#34;trim\u0026#34;: false, \u0026#34;debugCalls\u0026#34;: false } } } compiler-explorer.default.color：用于指定高亮汇编代码时的颜色\n\u0026#34;compiler-explorer.default.color\u0026#34;:{ \u0026#34;symbol\u0026#34;: \u0026#34;#61AFEF\u0026#34;, \u0026#34;string\u0026#34;: \u0026#34;#98C379\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;#D19A66\u0026#34;, \u0026#34;register\u0026#34;: \u0026#34;#E5C07B\u0026#34;, \u0026#34;instruction\u0026#34;: \u0026#34;#C678DD\u0026#34;, \u0026#34;comment\u0026#34;: \u0026#34;#7F848E\u0026#34;, \u0026#34;operator\u0026#34;: \u0026#34;#ABB2BF\u0026#34; } compiler-explorer.default.url：用于打开插件时默认加载的链接，默认是空\n\u0026#34;compiler-explorer.default.url\u0026#34;: { \u0026#34;default\u0026#34;: \u0026#34;\u0026#34; } 问题反馈 # 该插件还处于早期阶段，如果你在使用过程中遇到了问题，或者有任何建议，欢迎在 GitHub 上留言讨论。或者添加 QQ 群：662499937。\n另外 Output 窗口可能会提供一些有用的信息，可以注意检索\n","date":"April 24, 2024","externalUrl":null,"permalink":"/articles/694365783/","section":"Articles","summary":"Compiler Explorer 是一个非常流行的 C++ 在线编译器，可用于测试不同的编译执行环","title":"超好用的 C++ 在线编译器（VSCode 版）","type":"articles"},{"content":"Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的时候经常会讨论到它，看文章的时候经常会提到它，有时候又要处理它导致的兼容性。陌生在哪里？如果有人问你什么是 ABI，你会发现你知道它是怎么一回事，但是要用严谨的语言去描述它有些困难。最后只好照着 WIKI 说：ABI 就是两个二进制程序模块之间的接口。有问题吗？没有问题，作为一个概括性的描述，已经足够了。但是让人感觉到有些空洞。\n这一情况在 CS 领域并不少见，笔者之前写的讨论 反射 的文章也遇到完全相同的情况。究其根本，CS 本来就不是一门力求严谨性的学科，很多概念都没有严格的定义，更多的是约定俗成的说法。所以我们就不去纠结定义，而是就实际出发，来看看这些所谓的二进制接口究竟有哪些，又有哪些因素会影响它们的稳定性。\n软件工程讲究分层，对于一个 C++ 程序的 ABI 来说，我们也可以从下面这五个层次来看待。\nCPU \u0026amp; OS # 最终的可执行文件最后都是要运行在特定 CPU 上的特定操作系统的。如果 CPU 的指令集不同，那肯定会导致二进制不兼容，比如 ARM 上的程序没法直接运行在 x64 处理器上（除非借助一些虚拟化技术）。如果指令集兼容呢？比如 x64 处理器就兼容 x86 的指令集，那 x86 程序一定能运行在 x64 操作系统上吗？这时候就要看操作系统了，具体来说，要考虑到 Object File Format（目标文件格式），Data Representation（数据表示）， Function Calling Convention（函数调用约定）和 Runtime Library（运行时库）等因素。这几点就可以看做是操作系统层面的 ABI 规定。第四点我们后面有专门的一节来讨论，下面以 x64 平台为例，就前三点进行讨论。\nx64, x86-64, x86_64, AMD64 和 Intel 64 是一个意思，都是指 x86 指令集的 64 位版本。\nx64 平台上主要有两套常用的 ABI：\n用于 64 位 Windows 操作系统上的 Windows x64 ABI 用于 64 位 Linux 以及一众 UNIX-like 的操作系统上的 x86-64 System V ABI 而从一个动态库里面调用某个函数可以简单的看成下面这个三个步骤：\n按照某种格式解析动态库 根据符号名从解析结果中查找函数地址 函数参数传递，调用函数 Object File Format # 以何种格式解析动态库？这就是 ABI 中对 Object File Format 的规定起作用的地方了。如果你希望自己写一个链接器，那么最后生成的可执行文件就需要满足对应平台的格式要求。Windows x64 使用的可执行文件格式是 PE32+ ，也就是 PE32（Portable Executable 32-bit）格式的64位版本。System V ABI 使用的则是 ELF（Executable Linkable Format） 格式的可执行文件。通过使用一些 parse 库（当然感兴趣的话也可以自己写），例如 pe-parse 和 elfio，对实际的可执行文件进行解析，得到其中的符号表，我们便能拿到函数名与函数地址的映射关系了。\nData Representation # 拿到函数地址之后，接下来就是怎么进行调用了。在调用之前，首先得传参对吧。那传参的时候就特别要注意 Data Representation（数据表示）表示的一致性，什么意思呢？\n假设我把下面这个文件编译成动态库\nstruct X{ int a; int b; }; int foo(X x){ return x.a + x.b; } 结果后续版本升级导致结构体内容发生变动了，用户代码里面看到的结构体定义变成了\nstruct X{ int a; int b; int c; }; 然后仍然去尝试链接旧版本代码编译出的动态库，并调用里面的函数\nint main(){ int n = foo({1, 2, 3}); printf(\u0026#34;%d\\n\u0026#34;, n); } 能成功吗？当然会失败了。这种错误可以看成所谓的 ODR（One Definition Rule）违反，更多的示例会在后面的章节中讨论。\n上面的情况属于用户主动变更代码导致的 ODR 违反，那如果我不主动变更代码，能确保结构体布局的稳定性吗？那这就由 ABI 中 Data Representation 来进行相关保证了。例如：规定一些基础类型的大小和对齐， Windows x64 规定long是32位，而 System V 则规定long是64位。规定struct和union的大小和对齐等等。\n注意 C 语言标准仍然是不规定 ABI 的，对于 System V ABI 来说，其主要使用 C 语言的术语和概念编写，所以可以认为提供了针对 C 语言的 ABI。而 Windows x64 ABI 在 C 和 C++ 之间并没有太过明显的界限。\nFunction Calling Convention # 接下来就到函数传参这一步了。我们知道，函数不过就是一段二进制数据，执行函数其实就是跳转到函数的入口地址，然后执行那一段代码，最后执行完了再跳转回来就行了。而传参无非就是找一块地方，存放数据，使得调用前后都能访问到这个地方来取数据。有哪些位置可以选择呢？主要有下面四个选项：\nglobal（全局变量） heap（堆） register（寄存器） stack（栈） 使用全局变量进行传参，听起来很魔幻，实际上平常写代码的时候经常把一些需要反复传递的参数改成全局变量，例如config这种的。但是，显然不是所有参数都适合使用全局变量传参，如果考虑到线程安全就要更加注意了。\n使用堆进行传参，似乎也很不可思议，但其实 C++20 加入的无栈协程就把协程的状态（函数参数，局部变量）保存在堆上。不过对于普通的函数调用来说，如果每次传参都要动态内存分配，确实有些奢侈了。\n所以我们主要还是考虑使用寄存器和栈进行传参。多一种选择总是好的，但是在这里并不好。如果调用方觉得应该使用寄存器传参，于是把参数存到寄存器里面去了。而被调用方觉得应该使用栈传参，所以取数据的时候是从栈里面取的。不一致就出现了，很可能从栈里面独到的就是垃圾值，导致代码逻辑错误，程序直接崩溃。\n如何保证调用方和被调用方传参的位置一致呢？相信你已经猜到了，这就是 Function Calling Convention（函数调用约定）发挥作用的地方。\n具体来说，调用约定规定下面这些内容：\n函数参数传递顺序，从左到右还是从右到左？ 函数参数和返回值传递的方式，通过栈还是寄存器？ 哪些寄存器在调用者调用前后是保持不变的？ 谁负责清理栈帧，调用者还是被调用者？ 如何处理 C 语言的 variadic 函数？ ... 在32位程序中，有很多调用约定，像什么__cdecl，__stdcall，__fastcall，__thiscall等等，当时的程序可谓是饱受兼容性之苦。而在64位程序中，已经基本完成统一。主要有两种调用约定，也就是 Windows x64 ABI 和 x86-64 System V ABI 分别规定的调用约定（不过并没有个正式的名字）。需要强调的是函数传参方式只和调用约定有关，和代码优化等级无关。你也不想不同优化等级编译出来的代码，链接到一起之后跑不起来吧。\n介绍具体的规定是有些无聊的，感兴趣的读者可以自行查阅对应文档的相关小节，下面主要讨论一些比较有意思的话题。\n注意：下面这些讨论只适用于函数调用实际发生的情况，如果函数被完全内联，函数传参这一行为并不会发生。目前 C++ 代码的内联优化主要发生在同一编译单元内（单个文件），对于跨编译单元的代码，必须要打开 LTO（Link Time Optimization）才行，跨动态库的代码目前还不能内联。\n小于16字节大小的结构体值传递效率比引用效率更高 这个说法由来已久，但是我始终没有找到依据。终于，最近在研究调用约定的时候，让我找到原因了。首先如果结构体大小小于等于8字节，那么可以直接塞进一个64位寄存器里面传参，通过寄存器传参比通过引用传参要少几次访存，效率要高一些，没什么问题。那对于16字节呢？System V ABI 允许将一个16字节大小的结构体拆两个8个字节的部分，然后分别使用寄存器传递。那么在这种情况下传值确实比传引用要高一些，观察下面的 代码\n#include \u0026lt;cstdio\u0026gt; struct X { size_t x; size_t y; }; extern void f(X); extern void g(const X\u0026amp;); int main() { f({1, 2}); // pass by value g({1, 2}); // pass by reference } 最后生成的代码如下所示\nmain: sub rsp, 24 mov edi, 1 mov esi, 2 call f(X) movdqa xmm0, XMMWORD PTR .LC0[rip] mov rdi, rsp movaps XMMWORD PTR [rsp], xmm0 call g(X const\u0026amp;) xor eax, eax add rsp, 24 ret .LC0: .quad 1 .quad 2 System V ABI 规定了前六个整形参数，依次可以使用rdi，rsi，rdx，rcx，r8，r9寄存器传递，而 Windows x64 ABI 规定了前四个整形参数，依次可以使用rcx，rdx，r8，r9寄存器传递。如果过寄存器用完了，就通过栈传递。整形参数即char，short，int，long，long long等基础整数类型外加指针类型。浮点参数和 SIMD 类型的参数则有专门的寄存器负责，这里不过多涉及了。\n可以发现1,2分别通过寄存器edi和esi传递给了f函数，而g则是把临时变量的地址传递给了g函数。但是这只是 System V ABI，对于 Windows x64 ABI 来说，**只要结构体的大小大于8字节，只能通过引用传递。**同样的代码，在 Windows 上编译的结果如下\nmain: sub rsp, 56 lea rcx, QWORD PTR [rsp+32] mov QWORD PTR [rsp+32], 1 mov QWORD PTR [rsp+40], 2 call void f(X) lea rcx, QWORD PTR [rsp+32] mov QWORD PTR [rsp+32], 1 mov QWORD PTR [rsp+40], 2 call void g(X const \u0026amp;) xor eax, eax add rsp, 56 ret 0 可以看到两次函数调用产生的代码完全相同，也就是说对于 Windows x64 ABI 来说，大于8字节的结构体无论是通过引用传递还是值传递，生成的代码都是一样的。\nunique_ptr 和 raw_ptr 的效率完全一致 好吧在此之前我一直对此深信不疑，毕竟unique_ptr只是对裸指针简单包装一层嘛。直到看了 CPPCON 上 There are no zero-cost abstractions 这个令人深省的 talk，才意识到完全是我想当然了。这里不谈异常导致的额外开销（析构函数导致编译器必须额外生成清理栈帧的代码），仅仅讨论一个 C++ 对象（小于8字节）能使用寄存器传参吗？对于一个完全 trivial 的类型来说，是没问题的，它表现得和一个 C 语言的结构体几乎完全一样。不过不满足呢？\n比如自定义了拷贝构造函数，还能放寄存器里面吗？其实从逻辑上就不能，为什么呢？我们知道，C++ 是允许我们对函数参数取地址的，那如果参数是整形，那么它通过寄存器传参，那取地址的结果哪里来的呢？实验一下，就知道了\n#include \u0026lt;cstdio\u0026gt; extern void f(int\u0026amp;); int g(int x) { f(x); return x; } 生成的对应汇编如下\ng(int): sub rsp, 24 mov DWORD PTR [rsp+12], edi lea rdi, [rsp+12] call f(int\u0026amp;) mov eax, DWORD PTR [rsp+12] add rsp, 24 ret 可以发现，这里把edi（用于传递第一个整形参数）里面的值拷贝到了 rsp+12 这个地址，也就是栈上，之后把这个地址传递给了f。也就是说，如果一个函数参数通过寄存器传递，如果在某些情况下需要它的地址，编译器会把这个参数拷贝到栈上。但是无论如何，用户是观察不到这些拷贝过程的，因为它们的拷贝构造函数是trivial的。不影响最终代码执行结果的任何优化都是符合 as if 原则的。\n那么如果这个对象有用户定义的拷贝构造函数，假设参数通过寄存器传递，就可能会导致额外的拷贝构造函数调用，并且用户可以观察到这个副作用。显然这是不合理的，所以不允许拥有自定义拷贝构造函数的对象通过寄存器传参，那通过栈传递呢？实际上也会遇到类似的拷贝困境。于是最终这类对象只能通过引用传递了。注意，给拷贝构造显式标记为delete也算是自定义拷贝构造函数。\n所以对于unique_ptr来说，只能通过引用传递，无论你函数签名写成void f(unique_ptr\u0026lt;int\u0026gt;)还是void f(unique_ptr\u0026lt;int\u0026gt;\u0026amp;)，最后在传参处生成的二进制代码都是一样的。但是裸指针却可以通过寄存器安全的传递。综上所述，unique_ptr和裸指针的效率并不是完全一致的。\n实际上对于一个非 trivial 的 C++ 对象，究竟能否使用寄存器传参的实际情况更复杂一些，相关的内容参考对应 ABI 中的相关小节，这里不过多描述。另外 C++ 对象如何传递这部分规定，究竟属于操作系统的 ABI 还是 C++ 编译器 ABI 这个问题也并不是很明确。\nC++ Standard # 终于说完了操作系统层面的保证，由于偏向底层，涉及到较多汇编，对于不那么熟悉汇编的读者，读起来可能有些困难。不过接下来的内容基本就和汇编没什么关系了，可以放心阅读。\n我们都知道 C++ 标准没有明确规定 ABI，但并不是完全没有规定，它对于编译器的实现是有一些要求的，例如：\n结构体成员地址按照声明顺序 递增，这保证了编译器不会对结构体成员进行重新排序 满足 Standard Layout 约束的结构体需要与相应的 C 结构体布局兼容 满足 Trivially Copyable 约束的结构体可以使用memmove或者memcpy进行拷贝得到一个完全相同的全新对象 ... 另外，由于 C++ 一直在推出新的版本。同一份代码，我使用新标准和旧标准分别进行编译，得到的结果相同吗（不考虑使用宏控制 C++ 版本进行条件编译的影响）？这就要看 C++ 标准层面对 ABI 兼容性的保证了，事实上，C++ 标准尽可能的保证向后兼容性。也就是说，两段代码，使用旧标准和新标准编译出来的代码是完全一样的。\n然而，也有极少数的例外，例如（我只找得到这些，欢迎评论区补充）：\nC++17 把noexcept作为函数类型的一部分，这会影响函数最后生成的 mangling name C++20 引入的no_unique_address，MSVC 目前仍然没直接支持，因为会导致 ABI Broken 更多时候，C++ 新版本会在加入新的语言特性的同时带来新的 ABI，而不会影响旧的代码，例如 C++23 加入的两个新特性：\nExplicit Object Parameter # 在 C++23 之前，事实上没有合法的手段获取一个成员函数的地址，我们唯一能做的就是获取成员指针（关于成员指针是什么，可以参考这篇 文章 的内容）\nstruct X { void f(int); }; auto p = \u0026amp;X::f; // p is a pointer to member function of X // type of p is void (X::*)(int) 想要获取使用成员函数作为回调函数，只能使用 lambda 表达式包装一层\nstruct X { void f(int); }; using Fn = void(*)(X*, int); Fn p = [](A* self, int x) { self-\u0026gt;f(x); }; 这其实很麻烦，没有任何必要，而且这层包装可能会导致额外的函数调用开销。某种程度上这算是个历史遗留问题，32位系统上对成员函数的调用约定有些特殊（广为人知的thiscall），而 C++ 中并没有调用约定相关的内容，所以搞了个成员函数指针这么个东西。旧的代码为了 ABI 兼容性已经无法改变，但是新的可以，C++23 加入了显式对象参数，我们现在可以明确this的传入方式了，甚至可以使用值传递\nstruct X { // 这里的 this 只是个标记作用，为了和旧语法区分开来 void f(this X self, int x); // pass by value void g(this X\u0026amp; self, int x); // pass by reference }; 被显式this标记的函数也可以直接获取函数地址了，就和普通的函数一样\nauto f = \u0026amp;X::f; // type of f is void(*)(X, int) auto g = \u0026amp;X::g; // type of g is void(*)(X*, int) 所以新代码可以都采用这种写法，只有好处，没有坏处。\nStatic Operator() # 标准库中有一些仿函数，里面什么成员都没有，只有一个operator()，例如std::hash\ntemplate \u0026lt;class T\u0026gt; struct hash { std::size_t operator()(T const\u0026amp; t) const; }; 尽管这是个空的结构体，但是由于operator()是成员函数，所以有一个隐式this参数。在非内联调用的情况下仍然需要传递一个无用的空指针。这个问题在 C++23 中得到了解决，可以直接定义static operator()，从而避免这个问题\ntemplate \u0026lt;class T\u0026gt; struct hash { static std::size_t operator()(T const\u0026amp; t); }; static也就意味着这是个静态函数了，使用上还是和原来一样\nstd::hash\u0026lt;int\u0026gt; h; std::size_t n = h(42); 但这里只是拿hash举个例子，实际上标准库的代码为了 ABI 兼容性已经不会改动了。新代码可以使用这个特性，来避免不必要的this传递。\nCompiler Specific # 接下来就到了重头戏了，实现定义的部分，这部分似乎是被人诟病最多的内容了。然而事实真的如此吗？让我们一点点往下看。\nDe Facto Standard # C++ 中的一些抽象最终是要落实到实现上的，而标准有没有规定如何实现，那这部分内容就由编译器自由发挥，例如：\nname mangling 的规则（为了实现函数重载和模板函数） 复杂类型的布局（例如含有虚继承） 虚函数表的布局 RTTI 的实现 异常处理 ... 如果编译器对这些部分的实现不同，那么最后不同编译器编译出的二进制产物自然是互不兼容，不能混用的。\n在上世纪90年代，那时候还是 C++ 发展的黄金时期，各个厂商都致力于实现自己的编译器并扩大基本盘，争夺用户。出于竞争关系，不同编译器之间使用不同的 ABI 是很常见的行为。随着时代的发展，它们中的大多数已经退出了历史舞台，要么停止更新，要么仅做维护，不再跟进 C++ 的新标准。浪潮过后，留下的只有 GCC，Clang 和 MSVC 这三大编译器。\n在今天，C++ 编译器的 ABI 已经基本得到统一，主流的 ABI 只有两套：\nItanium C++ ABI，具有公开透明的 文档 MSVC C++ ABI，并没有官方的文档，这里有一份非正式的 版本 尽管名为 Itanium C++ ABI，但它实际上是用于 C++ 的跨架构 ABI，除了 MSVC 之外，几乎所有的 C++ 编译器都在使用它，尽管在异常处理方面的细节略有不同。历史上，C++ 编译器都以各自的方式处理 C++ ABI。当英特尔大力推广 Itanium 时，他们希望避免不兼容问题，因此，他们为 Itanium 上的所有 C++ 供应商创建了一个标准化的 ABI。后来，由于各种原因，GCC 需要修改其内部 ABI，而且鉴于它已经支持了 Itanium ABI（为 Itanium 处理器），他们选择将 ABI 定义扩展到所有架构，而不是创建自己的 ABI。从那时起，所有主要的编译器除了 MSVC 都采用了跨架构的 Itanium ABI，并且即使 Itanium 处理器本身不再接收维护，该 ABI 仍然得到了维护。\n在 Linux 平台上，GCC 和 Clang 都使用 Itanium ABI，所以两个编译器编译出来的代码就具有互操作性，可以链接到一起并运行。而在 Windows 平台上，情况则稍微复杂些，默认的 MSVC 工具链使用自己的 ABI。但是除了 MSVC 工具链以外，还有人把 GCC 移植到 Windows 上了，也就是我们熟知的 MinGW 工具链，它使用的仍然是 Itanium ABI。这两套 ABI 互不兼容，编译出来的代码不能直接链接到一起。而 Windows 平台上的 Clang 可以通过编译选项控制使用这两种 ABI 的其中的一种。\n注意：MinGW 既然在 Windows 上运行，那它生成的代码的调用约定自然是尽量遵守 Windows x64 ABI 的，最终生成的可执行文件格式也是 PE32+。但是它的使用的 C++ ABI 仍然是 Itanium ABI，这两者并没有必然关联。\n考虑到 C++ 巨大的 codebase，这两套 C++ ABI 已经基本稳定，不会再改动了，所以我们现在其实可以说 C++ 编译器具有稳定的 ABI。怎么样，是不是和网上主流的说法不同？但是事实的确就摆在这里。\nMSVC 从 2015 的版本往后开始保证 ABI 稳定。GCC 从 3.4 开始使用 Itanium ABI 并保证 ABI 稳定。\nWorkaround # 尽管基础的 ABI 不再改变，但是升级编译器版本仍然可能会导致编译出来的库发生 ABI Broken，为什么呢？\n这其实不难理解，首先编译器也是软件，只要是软件就可能有 BUG。有时候为了修复 BUG，会被迫做出一些 ABI Broken（一般会在新版本的发行介绍中详细说明）。例如 GCC 有一个编译选项 -fabi-version 用于专门控制这些不同的版本，其中一些内容如下：\n版本7首次出现在 G++ 4.8 中，它将nullptr_t视为内建类型，并修正了默认参数作用域中 Lambda 表达式的名称编码 版本8首次出现在 G++ 4.9 中，修正了带有函数 CV 限定符的函数类型的替换行为 版本9首次出现在 G++ 5.2 中，修正了nullptr_t的对齐方式 另外对于用户来说，也可能之前为了绕过编译器的 BUG，编写了一些特殊的代码，我们一般把这个叫做 workaround。当 BUG 被修复之后，这些 workaround 很可能起到反作用。从而导致 ABI 出现不兼容\nImportant Options # 除此之外，编译器还提供了一些列选项用来控制编译器的行为，这些选项可能会影响 ABI，比如：\n-fno-strict-aliasing：关闭严格别名 -fno-exceptions：关闭异常 -fno-rtti：关闭 RTTI ... 给不同选项编译出来的库链接到一起的时候，尤其要兼容性问题。例如你的代码关闭了严格别名，但是依赖的外部库开启了严格别名，很可能指针错误的传播，从而导致程序出错。\n我最近就遇到了这种情况，我在给 LLVM 的一些函数编写 Python Wrapper，通过 pybind11。而 pybind11 要求必须打开 RTTI，但是 LLVM 默认构建是关闭异常和 RTTI 的，所以最后代码就链接不到一块去了。一开始我是自己编译了一份开 RTTI 的 LLVM，这会导致二进制膨胀，后来发现没必要这样做。我其实没有用到 LLVM 里面类型的 RTTI 信息，只是由于写在同一个文件里面，编译器认为我用到了。于是把使用到 LLVM 部分的代码单独编译成一个动态库，再和使用 pybind11 部分的代码一起链接就解决了。\nRuntime \u0026amp; Library # 这一小节主要讨论的就是，一个 C++ 程序依赖的库的 ABI 稳定性。理想情况下是，对于一个可执行程序，使用新版本的动态库替换旧版本的动态库，仍然不影响它运行。\n三大 C++ 编译器都有自己的标准库\nMSVC 对应的是 msvc stl GCC 对应的是 libstdc++ Clang 对应的是 libc++ 我们在前面提到过，C++ 标准尽量保证 ABI 向后兼容。即使是从 C++98 到 C++11 这样的大更新，旧代码的 ABI 也没有受到太大影响，导致 ABI Break Change 的措辞改变更是完全找不到。\n但是对于 C++ 标准库来说情况就有些不一样了，从 C++98 到 C++11，标准库经历了一次大的 ABI Break Change。标准库中修改了对一些容器实现的要求，例如std::string。这导致原来广泛使用的 COW 实现不符合新标准，于是在 C++11 中不得不采用新实现。这也就导致了 C++98 和 C++11 之间的标准库 ABI Broken。不过在这之后，标准库的 ABI 一般相对稳定，各家实现也尽量保证。参考 stl，libstdc++ 和 libc++ 相关的页面以获取详细介绍。\n另外由于 RTTI 和 Exception 一般可以关掉，所以这两项功能可能由单独的运行时库来负责，比如 MSVC 的 vcruntime 和 libc++ 的 libcxxabi。\n值得一提的是，libcxxabi 中还包含了对静态局部变量初始化的支持，涉及到的主要函数是 **cxa_guard_acquire, **cxa_guard_release。使用它们来保证静态局部变量只在运行时初始化一次，如果对具体的实现感到好奇，可以查阅相关源码。\n还有就是负责一些底层功能的运行时库，比如 libgcc 和 compiler-rt。\n除了标准库以外，C++ 程序一般还需要链接 C 运行时\n在 Windows 上，必须链接 CRT 在 Linux 上 取决于所使用的发行版和编译环境，可能会链接 glibc 或者 musl C 运行时除了提供 C 标准库的实现外，还负责程序的初始化和清理。它负责调用main函数，并管理程序的启动和终止过程，包括执行一些必要的初始化和清理工作。对于大多数在操作系统上的软件来说，链接它是必须的。\n最理想的状态自然是，升级编译器的时候把这些对应的运行时库版本也升级，避免不必要的麻烦。但是在实际项目中，依赖关系可能十分复杂，可能会引发连锁反应。\nUser Code # 最后我们来谈谈用户代码自身的改变导致的 ABI 问题，如果希望将你的库以二进制形式进行分发，那么当用户量达到一定程度之后，ABI 兼容性就很重要了。\n在第一小节讨论调用约定的时候，就提到过变更结构体定义导致的 ABI 不兼容问题。那如果既想要保证 ABI 兼容，又想要为以后得扩展留下空间怎么办呢？答案就是在运行时处理了\nstruct X{ size_t x; size_t y; void* reserved; }; 通过一个void*指针为以后的扩展预留空间。可以根据它来判断不同的版本，比如\nvoid f(X* x) { Reserved* r = static_cast\u0026lt;Reserved*\u0026gt;(x-\u0026gt;reserved); if (r-\u0026gt;version == ...) { // do something } else if (r-\u0026gt;version == ...) { // do something else } } 这样就能在添加新的功能的同时而不影响原有的代码。\n在对外暴露接口的时候，对于函数参数中有自定义析构函数的类型，也要格外注意。假设我们要暴露std::vector作为返回值，例如把下面这个简单的代码编译成动态库，并且使用\\MT选项来静态链接 Windows CRT。\n__declspec(dllexport) std::vector\u0026lt;int\u0026gt; f() { return {1, 2, 3}; } 然后我们写一个源文件，链接到刚才编译的这个动态库，调用这个函数\n#include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; f(); int main() { auto vec = f(); } 编译运行，发现直接崩溃了。如果关闭\\MT重新编译一遍动态库，然后运行，发现一切正常。很奇怪，为什么依赖的动态库静态链接 CRT 会导致代码崩溃？\n思考一下上面的代码不难发现，vec的构造实际上发生在动态库里面，而析构则是发生在main函数里面。更进一步，其实就是内存是在动态库里面分配的，释放是在main函数里面。但是每一份 CRT 都有自己的malloc，free（类似于不同进程间的内存）。你不能把 CRT A 分配的内存交给 CRT B 释放，这就是问题的根源。所以之后不静态链接到 CRT 就没事了，它们用的都是同一个malloc，free。不仅仅是 WIndows CRT，对于 Linux 上的 glibc 或者 musl 也是一样的。示例代码放在 这里，感兴趣的可以自己试试。\nextern \u0026ldquo;C\u0026rdquo; # 对于任何带有自定义析构函数的 C++ 类型都可能出现上面那种情况，由于种种原因，构造函数和析构函数的调用跨越动态库边界，RAII 的约定被打破，导致严重的错误。\n如何解决呢？那自然是函数参数和返回值都不使用带有析构函数的类型了，只使用 POD 类型。\n例如上面那个例子需要改成\nusing Vec = void*; __declspec(dllexport) Vec create_Vec() { return new std::vector\u0026lt;int\u0026gt;; } __declspec(dllexport) void destroy_Vec(Vec vec) { delete static_cast\u0026lt;std::vector\u0026lt;int\u0026gt;*\u0026gt;(vec); } 然后使用就得这样\nusing Vec = void*; Vec create_Vec(); void destroy_Vec(Vec vec); int main() { Vec vec = create_Vec(); destroy_Vec(vec); } 其实我们就是在按照 C 风格的 RAII 来进行封装。更进一步，如果想要解决 C 和 C++ 由于 mangling 不同而导致的链接问题，可以使用extern \u0026quot;C\u0026quot;来修饰函数\nextern \u0026#34;C\u0026#34; { Vec create_Vec(); void destroy_Vec(Vec vec); } 这样的话 C 语言也可以使用上述的导出函数了。\n但是如果代码量很大的话，把全部的函数都封装成这样的 API 显然不太现实，那就只能把 C++ 的类型暴露在导出接口中，然后小心地管理依赖项（比如所有依赖库全都静态链接）。具体选择哪一种方式，还是要看项目大小和复杂度，然后再做定夺。\nConclusion # 到这里，我们终于讨论完了影响 C++ 程序 ABI 的主要因素。可以清楚地看到，C++ 标准、编译器厂商和运行时库都在尽力维护 ABI 的稳定性，C++ ABI 并没有很多人说的那么不堪，那么不稳定。对于小型项目而言，带源码静态链接，几乎不会有任何的兼容性问题。对于那些历史悠久的大型项目来说，由于复杂的依赖关系，升级某些库的版本可能会导致程序崩溃。但这并不是 C++ 的错，对于大型项目的管理，早已超出了单纯的语言层面，不能指望通过更换编程语言来解决这些问题。实际上，学习软件工程就是在学习如何应对巨大的复杂度，如何保证复杂系统的稳定性。\n文章到这就结束了，感谢您的阅读。作者水平有限，并且这篇文章内容跨度较大，如有错误欢迎评论区留言讨论。\n一些其它的参考资料：\nAn Overview of ABI in Different Platforms WIndows x64 ABI System V x64 ABI Itanium C++ ABI MinGW x64 Software Convention MacOS x64 ABI ARM ABI WIndows ARM64 ABI RISCV ABI Go Internal ABI ","date":"April 16, 2024","externalUrl":null,"permalink":"/articles/692886292/","section":"Articles","summary":"Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概","title":"彻底理解 C++ ABI","type":"articles"},{"content":"相信读者经常能听见有人说 C++ 代码二进制膨胀严重，但是一般很少会有人指出具体的原因。在网络上一番搜索过后，发现深入讨论这个问题的文章的并不多。上面那句话更像是八股文的一部分，被口口相传，但是没什么人能说出个所以然。今天小编 ykiko 就带大家一起来探秘 C++ 代码膨胀那些事 (^ω^)\n首先要讨论的是，什么叫做代码膨胀？如果一个函数被大量内联，那相比于不被内联，最终生成的可执行文件是更大了对吧。那这样算膨胀吗？我认为不算，这是我们预期范围内的，可接受的，正常行为。那反过来，不在我们预期范围内的，理论上能消除，但迫于现有的实现却没有消除的代码膨胀，我把它叫做\u0026quot;真正的代码膨胀\u0026quot;。后文所讨论的膨胀都是这个意思。\n用 inline 标记函数会导致膨胀吗？ # 首先要明确，这里的inline是 C++ 中的inline，标准中规定的语义是，允许一个函数的在多个源文件中定义。被inline标记的函数可以直接定义在头文件中，即使被多个源文件#include，也不会导致链接错误，这样可以方便的支持 header-only 的库。\n多份实例的情况 # 既然可以在多个源文件中定义，那是不是就意味着每个源文件都有一份代码实例，会不会导致代码膨胀呢?\n考虑如下示例，开头的注释表示文件名\n// src1.cpp inline int add(int a, int b) { return a + b; } int g1(int a, int b) { return add(a, b); } // src2.cpp inline int add(int a, int b) { return a + b; } int g2(int a, int b){ return add(a, b); } // main.cpp #include \u0026lt;cstdio\u0026gt; extern int g1(int, int); extern int g2(int, int); int main() { return g1(1, 2) + g2(3, 4); } 先尝试不开优化编译前两个文件，看看他们是不是各自保留了一份add函数\n$ g++ -c src1.cpp -o src1.o $ g++ -c src2.cpp -o src2.o 分别查看这两个文件里面的符号表\n$ objdump -d src1.o | c++filt $ objdump -d src2.o | c++filt 本地验证都通过上述命令直接查看符号表进行。但是为了方便展示，我会把 godbolt 对应的链接和截图放上来，它把很多影响阅读的不关键符号都省略了，看起来更加清晰。\n可以看到这两个 源文件 分别保留了一份，add函数的实例。然后我们将它们链接成可执行文件\n$ g++ main.o src1.o src2.o -o main.exe $ objdump -d main.exe | c++filt 结果如下图所示\n发现链接器只保留了两份add实例中的一份，所以并没有额外的代码膨胀。并且 C++ 标准要求，内联函数在不同编译单元的定义必须相同，所以无论选哪一份代码保留都没区别。但是如果你问：万一定义不同呢？那就会导致 ODR 违反，严格意义来说算 undefined behavior，究竟保留哪一个可能就看具体实现了，甚至和链接顺序有关。关于 ODR 违反相关的内容，我最近可能会单独写一个文章介绍，这里就不说太多了。只需要知道 C++ 标准保证 inline 函数在不同编译单元定义相同就行了。\n完全内联的情况 # 前面我特意强调了，不打开优化，如果打开了优化会怎么样呢？仍然是上面的代码，我们尝试打开O2优化。最后的 结果 如下图所示\n可能让人有点吃惊，打开-O2优化之后，add调用被完全内联。编译器最后连符号都没有给add生成，链接的时候自然也没有add。按照我们之前的定义来看，这种函数内联不属于代码膨胀，所以是没有额外的二进制膨胀开销的。\n稍微偏个题，既然这两个文件都不生成add这个符号，那万一有别的文件引用了add这个符号，不就会导致编译失败吗？\n考虑如下代码\n// src1.cpp inline int add(int a, int b) { return a + b; } int g1(int a, int b) { return add(a, b); } // main.cpp inline int add(int a, int b); int main() { return g1(1, 2) + add(3, 4); } 尝试编译链接上面的代码。发现不开优化可以链接通过。开了优化就会导致链接失败了。链接器会告诉你undefined reference to add(int, int)。三大编译器的行为都是如此，具体的原因上面已经解释过了，开了优化之后，编译器压根没生成add这个符号，链接的时候自然无法找到了。\n但是我们想知道的是，这样做符合 C++ 标准吗？\n三大编译器都这样，似乎没有不符合的道理。但是在 inline 那一小节并没有明确说明，而在 One Definition Rule 这里有如下两句话\nFor an inline function or inline variable(since C++17), a definition is required in every translation unit where it is odr-used. a function is odr-used if a function call to it is made or its address is taken 两句话啥意思呢？意思就是，一个 inline 函数，如果在某个编译单元被 odr-used 了，那么这个编译单元必须要有该函数的定义。啥情况是 odr-used 呢？后面一句话就是在解释，如果函数被调用或者取函数的地址就算是 odr-used。\n那我们看看之前的代码，在 main.cpp 中调用一个 inline 函数，但是却没有定义，所以其实是违背了 C++ 标准的约定的。到这里，算是松了一口气了。虽然有点反直觉，但是事实的确如此，三大编译器都没错！\n其它情况 # 我们这一小节主要讨论了两种情况：\n第一种即inline函数在多个编译单元都有实例（生成符号），那么这时候目前主流的链接器都只会选择其中一份保留，不会有额外的代码膨胀 第二种情况是inline函数被完全内联，并且不生成符号。这时候就如同普通的函数被内联一样，不属于\u0026quot;额外的开销\u0026quot; 可能会有人觉得 C++ 优化怎么规则这么多啊。但是实际上核心的规则只有一条，那就是as-if原则，也就是编译器可以对代码进行任何优化，只要最后生成的代码运行效果和不优化的一样就行了。编译器绝大部分时候都是按照这个原则来进行优化的，只有少数几个例外可以不满足这个原则。上述对 inline 函数的优化也是满足这个原则的，如果不显式对 inline 函数取地址，那的确没必要保留符号。\n另外， inline 虽然标准层面没有强制内联的语义了，但是实际上它会给编译器一些 hint，使得这个函数更容易被内联。这个 hint 是如何作用的呢？前面提到了，标准的措辞表明 inline 函数可以不生成符号。那相比之下，没有任何说明符限定的函数，则默认被标记为 extern ，必须要生成符号。编译器肯定是更愿意内联可以不生成符号的函数的。从这个角度出发，你可能会猜测 static 也会有类似的 hint 效果，实际情况的确如此。当然了，这些只是一个方面，实际上，判断函数是否被内联的计算会复杂的多。\n注意：本小节，只讨论了仅被inline标记的函数，除此之外还有inline static和inline extern这样的组合，感兴趣的读者可以阅读官方文档或者自行尝试效果如何。\n模板导致代码膨胀的真正原因？ # 如果有人给出 C++ 二进制膨胀的理由，那么几乎它的答案一定是模板。果真如此吗？模板究竟是怎么导致二进制膨胀的？在什么情况导致的？难道我用了就导致吗？\n隐式实例化如同 inline 标记 # 我们知道模板实例化发生在当前编译单元，实例化一份就会产生一份代码。考虑下面这个例子\n// src1.cpp template \u0026lt;typename T\u0026gt; int add(T a, T b) { return a + b; } float g1() { return add(1, 2) + add(3.0, 4.0); } // src2.cpp template \u0026lt;typename T\u0026gt; int add(T a, T b) { return a + b; } float g2() { return add(1, 2) + add(3.0, 4.0); } // main.cpp extern float g1(); extern float g2(); int main() { return g1() + g2(); } 仍然不开优化，尝试编译 编译结果 如下\n可以看见就像被 inline 标记的函数那样，这两个编译单元都实例化了add\u0026lt;int, int\u0026gt;和add\u0026lt;double, double\u0026gt;，各有一份代码。然后在最终链接的时候，链接器只为每个模板实例化保留了一份代码。那我们尝试打开-O2，然后再看看情况。结果 如下\n也和 inline 标记的效果一样，编译器直接把函数内联了，然后实例化出的函数的符号都扔了。那这样的话，要么内联了符号都没生成，要么生成了符号，最后函数合并了。和 inline 一样，这种情况似乎没有额外的膨胀啊，那经常说的模板膨胀，究竟膨胀在哪呢？\n显式实例化和 extern 模板 # 在介绍真正膨胀的原因之前，我们先来讨论一下显式实例化。\n虽然链接器最后能合并多份相同的模板实例化。但是模板定义的解析，模板实例化，以及生成最终的二进制代码和链接器去除重复代码，这些都要编译时间的啊。有些时候，我们能确定，只是使用某几种固定模板参数的实例化，比如像标准库的basic_string几乎只有那几种固定的类型作为模板参数，如果每次个文件用到它们，都要进行模板实例化可能会大大增长编译时间。\n那我们可以像非模板函数一样，把实现放在某一个源文件，其它文件引用这个源文件的函数吗？从上一小节的讨论来看，既然会生成符号，那应该就有办法链接到。但是不能保证一定生成啊，有什么办法保证生成符号吗？\n答案就是 —— 显式实例化！\n什么叫显式实例化？简单来说，如果一个模板，你直接使用。而不提前声明具体到何种类型，由编译器帮你生成声明，那就算隐式实例化。反之就叫做显式实例化。以函数模板为例，\ntemplate \u0026lt;typename T\u0026gt; void f(T a, T b) { return a + b; } template void f\u0026lt;int\u0026gt;(int, int); // 显式实例化 f\u0026lt;int\u0026gt; 定义 void g() { f(1, 2); // 调用之前显式实例化的 f\u0026lt;int\u0026gt; f(1.0, 2.0); // 隐式实例化 f\u0026lt;double\u0026gt; } 相信还是很好理解的，而且显式实例化定义的话，编译器一定会为你保留符号。那接下来就是外部如何链接到这个显式实例化的函数了，有两种办法\n一种是，直接显式实例化一个函数声明\ntemplate \u0026lt;typename T\u0026gt; void f(T a, T b); template void f\u0026lt;int\u0026gt;(int, int); // 显式实例化 f\u0026lt;int\u0026gt; 仅声明 另一种是直接使用extern关键字实例化一个定义\ntemplate \u0026lt;typename T\u0026gt; void f(T a, T b){ return a + b; } extern template void f\u0026lt;int\u0026gt;(int, int); // 显式实例化 f\u0026lt;int\u0026gt; 声明 // 注意不加 extern 就会显式实例化一个定义了 这两种都能正确引用到上面那个函数f，这样就可以调用其它文件的模板实例化了！\n真正的模板膨胀开销 # 接下来是最重要的部分了，我们将会介绍模板膨胀的真正原因。由于一些历史遗留问题，C++ 中char,unsigned char,signed char三种类型永远互不相同\nstatic_assert(!std::is_same_v\u0026lt;char, unsigned char\u0026gt;); static_assert(!std::is_same_v\u0026lt;char, signed char\u0026gt;); static_assert(!std::is_same_v\u0026lt;unsigned char, signed char\u0026gt;); 但是如果落实到到编译器最终实现上来，char要么signed，要么unsigned。假设我们编写一个模板函数\ntemplate \u0026lt;typename T\u0026gt; void f(T a, T b){ return a + b; } void g() { f\u0026lt;char\u0026gt;(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;); f\u0026lt;unsigned char\u0026gt;(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;); f\u0026lt;signed char\u0026gt;(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;); } 实例化三种类型的函数模板，那么其中必然有两个实例化是相同的代码。编译器会把函数类型不同，但是最后生成的二进制代码相同的两个函数合并吗？尝试一下，结果 如下\n可以看到这里生成了两个完全一样的函数，但是并没有合并。当然，如果我们打开-O2优化，这样短的函数就会被内联掉了，也不会生成最终符号。就和第一小节说的那样，也就没有所谓的\u0026quot;模板膨胀开销\u0026quot;。实际代码编写中有很多这样的短小的模板函数，比如vector这种容器的end,begin,operator[]等等，它们大概率会被完全内联，从而没有\u0026quot;额外的膨胀\u0026quot;开销。\n现在问题来了，如果函数没被没有内联呢？假设模板函数比较复杂，函数体较大。为了方便演示，我们暂时使用 GCC 的一个 attribute [[gnu::noinline]]来实现这种效果，然后打开 O2，再次编译上面的 代码\n可以看到虽然被优化的只剩一条指令，但是编译器还是生成了三份函数。实际上，真的不被编译器内联的函数体积可能比较大，情况可能比这个“伪装的大函数”糟糕的多。于是，这样的话就产生了所谓的\u0026quot;模板膨胀\u0026quot;。本来能合并的代码却没有合并，这就是真正的模板膨胀开销所在。\n如果非常希望编译器/链接器合并这些相同的二进制代码怎么办呢？很遗憾，主流的工具链 ld / lld / ms linker 都不会做这种合并。目前唯一支持这个特性的链接器是 gold，但是它只能用于链接 elf 格式的可执行文件，所以没法在 Windows 上面使用了。下面我展示一下：如何使用它合并相同的二进制代码\n// main.cpp #include \u0026lt;cstdio\u0026gt; #include \u0026lt;utility\u0026gt; template \u0026lt;std::size_t I\u0026gt; struct X { std::size_t x; [[gnu::noinline]] void f() { printf(\u0026#34;X\u0026lt;%zu\u0026gt;::f() called\\n\u0026#34;, x); } }; template \u0026lt;std::size_t... Is\u0026gt; void call_f(std::index_sequence\u0026lt;Is...\u0026gt;) { ((X\u0026lt;Is\u0026gt;{Is}).f(), ...); } int main(int argc, char *argv[]) { call_f(std::make_index_sequence\u0026lt;100\u0026gt;{}); return 0; } 我这里通过模板生成了100个不同的类型，但是实际上它们底层都是size_t类型，所以进行最终编译生成的二进制代码是完全相同的。使用如下命令尝试编译它\n$ g++ -O2 -ffunction-sections -fuse-ld=gold -Wl,--icf=all main.cpp -o main.o $ objdump -d main.o | c++filt 使用-fue-ld=gold指定链接器，-Wl,--icf=all指定链接器选项。icf即意味着identical code folding，即相同代码折叠。因为链接器只在 section 级别上工作，所以 GCC 则需要配合开启-ffunction-sections，上面的编译器也可以替换成clang\n0000000000000740 \u0026lt;X\u0026lt;99ul\u0026gt;::f() [clone .isra.0]\u0026gt;: 740: 48 89 fa mov %rdi,%rdx 743: 48 8d 35 1a 04 00 00 lea 0x41a(%rip),%rsi 74a: bf 01 00 00 00 mov $0x1,%edi 74f: 31 c0 xor %eax,%eax 751: e9 ca fe ff ff jmp 620 \u0026lt;_init+0x68\u0026gt; 756: 66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 75d: 00 00 00 0000000000000760 \u0026lt;void call_f\u0026lt;0..99\u0026gt;(std::integer_sequence\u0026lt;unsigned long, 0..99\u0026gt;) [clone .isra.0]\u0026gt;: 760: 48 83 ec 08 sub $0x8,%rsp 764: 31 ff xor %edi,%edi 766: e8 d5 ff ff ff call 740 \u0026lt;X\u0026lt;99ul\u0026gt;::f() [clone .isra.0]\u0026gt; ... # 重复 98 次 b48: e9 f3 fb ff ff jmp 740 \u0026lt;X\u0026lt;99ul\u0026gt;::f() [clone .isra.0]\u0026gt; b4d: 0f 1f 00 nopl (%rax) 对输出内容进行了一些筛选，可以发现，gold 把二进制完全相同的 100 个模板函数合并成一个了，所谓的\u0026quot;模板膨胀\u0026quot;消失了。相比之下，前面那些那些不做这种合并的链接器，就自然就有额外的开销了。\n但是 gold 并不是万能的，有些情况不能很好的处理。假设这 100 个函数，前90%的代码相同，但是最后10%的代码不相同，那么它就无能为力了。它只是简单的对比最终生成的二进制，然后合并完全相同的函数。那么还有其他的解决办法吗？**自动挡没有，咱们还有手动挡呢，咱写 C++ 的没什么别的擅长的，就擅长开手动挡。 **\n手动优化模板膨胀问题 # 下面以大家最常用的vector为例，展示一下解决模板膨胀的主要思路。前面已经提到了，像迭代器接口这样的短函数，我们是不需要去管的。我们主要来处理那些逻辑比较复杂的函数，对 vector 来说，首当其冲的就是扩容函数了\n假设我们有如下vector代码\ntemplate \u0026lt;typename T\u0026gt; struct vector { T* m_Begin; T* m_End; T* m_Capacity; void grow(std::size_t n); }; 考虑一个vector扩容的朴素实现，暂不考虑异常安全\ntemplate \u0026lt;typename T\u0026gt; void vector\u0026lt;T\u0026gt;::grow(std::size_t n) { T* new_date = static_cast\u0026lt;T*\u0026gt;(::operator new(n * sizeof(T))); if constexpr (std::is_move_constructible_v\u0026lt;T\u0026gt;) { std::uninitialized_move(m_Begin, m_End, new_date); } else { std::uninitialized_copy(m_Begin, m_End, new_date); } std::destroy(m_Begin, m_End); ::operator delete(m_Begin); } 逻辑看起来还挺简单的。但是毫无疑问，它算是一个较复杂的函数了，尤其是当对象的构造函数被内联的话，代码量也是比较大的。那如何合并呢？注意，合并模板的前提是找出不同模板实例的相同部分，如果一个函数为不同的类型生成完全不同的代码，那是没法合并的。\n那对于vector来说，如果 T 里面的元素类型不同，扩容逻辑还能相同吗？考虑到构造函数调用，似乎没任何办法。关键点来了，这里需要介绍一个trivially_relocatable的概念，具体的讨论可以参考\n全新的构造函数，C++ 中的 relocate 构造函数 https://www.ykiko.me/articles/679782886\n我们这里只说结果，如果一个类型是trivially_relocatable的，那么可以使用memcpy把它从旧内存移动到新内存，不需要调用构造函数了。\n考虑编写如下的扩容函数\nvoid trivially_grow(char*\u0026amp; begin, char*\u0026amp; end, char*\u0026amp; capacity, std::size_t n, std::size_t size) { char* new_data = static_cast\u0026lt;char*\u0026gt;(::operator new(n * size)); std::memcpy(new_data, begin, (end - begin) * size); ::operator delete(begin); begin = new_data; end = new_data + (end - begin); capacity = new_data + n; } 然后将原来的grow实现转发到这个函数\ntemplate \u0026lt;typename T\u0026gt; void vector\u0026lt;T\u0026gt;::grow(std::size_t n) { if constexpr (is_trivially_relocatable_v\u0026lt;T\u0026gt;) { trivially_grow(reinterpret_cast\u0026lt;char*\u0026amp;\u0026gt;(m_Begin), reinterpret_cast\u0026lt;char*\u0026amp;\u0026gt;(m_End), reinterpret_cast\u0026lt;char*\u0026amp;\u0026gt;(m_Capacity), n, sizeof(T)); } else { // 原来的实现 } } 这样就完成了抽取公共逻辑。于是所有的T只要满足trivially_relocatable，就可以全都这共享一份代码了。而几乎所有不含有自引用的类型都符合这个条件，于是99%的类型都使用同一套扩容逻辑！这样的优化效果是非常显著的！实际上 LLVM 很多容器的源码，比如 SmallVector,StringMap等等，都使用了这样的技巧。另外如果你觉得上面的reinterpret_cast破坏了严格别名，用起来有点害怕，你可以通过继承来实现相同的效果（基类成员用void*），具体的代码就不展示了。\n异常导致的代码膨胀！ # 为什么 LLVM 源码禁用异常？很多人可能会下意识的认为，原因是异常很慢，效率很低。但其实，根据 LLVM Coding Standard 里面的内容，关闭异常和RTTI的主要目的是为了减少二进制大小。据说，打开异常和RTTI会导致 LLVM 的编译结果膨胀10%-15%，那么实际情况究竟如何？\n目前主要的异常实现有两种，一种是 Itanium ABI 的实现，另一种则是 MS ABI 的实现。简单来说 MS ABI 采用运行时查找的办法，这样会导致异常在 Happy Path 执行也有的额外运行时开销，但是优点是最终生成的二进制代码相对较小。而 Itanium ABI 则是我们今天的主角，它号称零开销异常，Happy 路径没有任何额外的运行时开销。那古尔丹，代价是什么？代价就是非常严重的二进制膨胀。为什么会产生膨胀呢？简单来说，就是如果不想完全等到运行时去查找，那就得预先打表。由于异常的隐式传播特性，会导致表占用空间很大。具体实现细节非常复杂，不是本文的主题，放张图，大概感受一下\n那我们主要讨论什么呢？异常会导致二进制膨胀，这个没什么好怀疑的。我们主要看看如何减少异常产生的二进制膨胀，以 Itanium ABI 为例\n先来看下面这段示例代码\n#include \u0026lt;vector\u0026gt; void foo(); // 外部链接函数，可能抛出异常 void bar() { std::vector\u0026lt;int\u0026gt; v(12); // 拥有 non-trivial 的析构函数 foo(); } 注意，这里foo是一个外部链接的函数，可能会抛出异常。另外就是vector的析构函数调用是在foo之后的。如果foo抛出异常，控制流不知道跳转到什么地方了，那么vetcor的析构函数可能被跳过调用了，如果编译器不做些特殊处理的话，就会导致内存泄露了。先只打开-O2看看程序编译的结果\nbar(): ... call operator new(unsigned long) ... call foo() ... jmp operator delete(void*, unsigned long) mov rbp, rax jmp .L2 bar() [clone .cold]: .L2: mov rdi, rbx mov esi, 48 call operator delete(void*, unsigned long) mov rdi, rbp call _Unwind_Resume 省略掉不重要的部分，和我们刚才猜的大致相同。那这个.L2是干嘛的呢？这个其实就是异常被catch处理完后会跳转到这个L2把之前没处理完的工作做完（这里就是析构之前未析构的对象），之后再Resume回到先前的位置。\n我们稍微调整下代码，把foo调用移动到vector构造的前面，其它什么都不变\nbar(): sub rsp, 8 call foo() mov edi, 48 call operator new(unsigned long) ... jmp operator delete(void*, unsigned long) 可以发现没有生成清理栈的代码了，很合理。原因很简单，如果foo抛出异常，控制流直接跳转走了，那vector都没构造呢，自然也不需要析构了。通过简单的调整调用顺序就减少了二进制大小！但是，只有这种特别简单的情况下，依赖关系才比较明显。如果实际抛出异常的函数很多的话，就很难分析了。\nnoexcept # 先讨论 C++11 加入的这个noexcept。注意即使加了noexcept，这个函数还是可能会抛出异常的，如果该函数抛出异常，程序直接terminate。那你可能要问了，这玩意有啥用呢？我异常抛了，不捕获不也是terminate吗？\n其实这个和 const 有点类似，你想改 const 变量，虽然是 undefined behavior，但是运行时随便改呀，限制不多。那你要问了， const 有什么意义？一个重要的意义是给编译器提供优化指示信息。编译器可以利用这个做 constant folding（常量折叠） 和 common subexpression elimination（公共子表达式消除） 。\nnoexcept也是类似的，它让编译器假设这个函数不会抛出异常，从而可以进行一些额外的优化。 还是第一个例子里面的代码为例，唯一的改变是把foo函数声明为了noexcept，然后再次编译\nbar(): push rbx mov edi, 48 call operator new(unsigned long) ... call foo() ... jmp operator delete(void*, unsigned long) 可以发现，用于异常处理的代码路径，同样没有了，这就是noexpect的功劳。\nfno-exceptions # 终于讲到重头戏了：-fno-exceptions，注意这个选项非标准。但是三大编译器都有提供，不过具体的实现效果有些许差异。好像并没有十分详细的文档，我仅凭经验说一下 GCC 相关的，对于 GCC 来说，该选项会禁止用户的代码里面使用try,catch,throw等关键字，如果使用则导致编译错误。但是特别的，允许使用标准库。如果异常被抛出，就和noexcept一样，程序直接terminate。所以如果打开了这个选项，GCC 会默认假设所有函数不会抛出异常。\n仍然是上面的例子，我们尝试打开-fno-exceptions，然后再次编译\nbar(): push rbx mov edi, 48 call operator new(unsigned long) ... call foo() ... jmp operator delete(void*, unsigned long) 可以发现和noexcept产生的效果类似，它们都会让编译器假设某个函数不会抛出异常，从而不需要生成清理栈的额外代码,达到减少程序二进制大小的效果。\n这篇文章涉及到的话题跨度有点大，某些地方有错误在所难免，欢迎评论区讨论交流 (^ω^)\n","date":"March 11, 2024","externalUrl":null,"permalink":"/articles/686296374/","section":"Articles","summary":"相信读者经常能听见有人说 C++ 代码二进制膨胀严重，但是一般很少会","title":"C++ 究竟代码膨胀在哪里？","type":"articles"},{"content":" 前情提要： # https://www.ykiko.me/articles/682031684\n2015-2016：模板的语法糖 # 在 C++ 中支持 全特化 (full specialization) 的模板很多，但是支持 偏特化 (partial specialization) 的模板并不多，事实上其实只有类模板 (class template) 和变量模板 (variable template) 两种支持，而变量模板其实可以看做类模板的语法糖，四舍五入一下其实只有类模板支持偏特化。不支持偏特化会导致有些代码十分难写\n假设我们想实现一个destroy_at函数，效果就是调用对象的析构函数。特别的，如果析构函数是 trivial 的，那我们就省去这次无意义的析构函数调用。\n直觉上我们能写出下面这样的代码\ntemplate\u0026lt;typename T, bool value = std::is_trivially_destructible_v\u0026lt;T\u0026gt;\u0026gt; void destroy_at(T* p) { p-\u0026gt;~T(); } template\u0026lt;typename T\u0026gt; void destroy_at\u0026lt;T, true\u0026gt;(T* p) {} 很可惜，clangd 已经可以智慧的提醒你：Function template partial specialization is not allowed。函数模板不能偏特化，那咋办呢？当然了，可以包一层类模板解决，但是每次遇到这种情况都额外包一层实在是让人难以接受。\n旧时代的做法是利用 SFINAE 来解决这个问题\ntemplate\u0026lt;typename T, std::enable_if_t\u0026lt;(!std::is_trivially_destructible_v\u0026lt;T\u0026gt;)\u0026gt;* = nullptr\u0026gt; void destroy_at(T* p) { p-\u0026gt;~T(); } template\u0026lt;typename T, std::enable_if_t\u0026lt;std::is_trivially_destructible_v\u0026lt;T\u0026gt;\u0026gt;* = nullptr\u0026gt; void destroy_at(T* p) {} 具体的原理这里就不叙述了，虽然少了一层包装，但是仍然有很多与代码逻辑无关的东西出现。这里的std::enable_if_t就是典型例子，严重影响了代码的可读性。\n提案 N4461 希望引入static_if（借鉴自 D 语言）可以用来编译期控制代码生成，只会把实际用到的分支编译进最终的二进制代码。这样就可以写出下面这样的代码，其中static_if的条件必须是常量表达式\ntemplate\u0026lt;typename T\u0026gt; void destroy_at(T* p){ static_if(!std::is_trivially_destructible_v\u0026lt;T\u0026gt;){ p-\u0026gt;~T(); } } 可以发现逻辑非常清晰，但是委员会一般对于加新的关键字比较谨慎。后来static_if被重命名为constexpr_if，再后来变成了我们今天熟悉的这种形式并且进入 C++17\nif constexpr (...){...} else if constexpr (...){...} else {...} 巧妙地避免了加新的关键字，C++ 委员会还真是喜欢关键字复用呢。\n2015：constexpr lambda # 提案 N4487 讨论了支持 constexpr lambda 可能性，尤其希望能在 constexpr 计算中能够使用 lambda 表达式，并附带了一个实验性实现。\n其实支持 constexpr 的 lambda 表达式并不困难，我们都知道 lambda 在 C++ 里面是很透明的，基本上完全就是一个匿名的函数对象。函数对象都能是 constexpr 的，那么支持 constexpr 的 lambda 也就是理所当然的事情了。\n唯一需要注意的就是，lambda 是可以进行捕获的，捕获 constexpr 的变量会怎么样呢？\nvoid foo() { constexpr int x = 3; constexpr auto foo = [=]() { return x + 1; }; static_assert(sizeof(foo) == 1); } 从直觉上来说，由于x是常量表达式，没有必要给它分配空间来储存。那么f其实里面没有任何成员，在 C++ 中空类的 size 至少是1。上面的代码挺合理的，但是在文章的上篇也说到了，constexpr 变量其实也是可以占用内存的，我们可以显式取它的地址\nvoid foo() { constexpr int x = 3; constexpr auto foo = [=]() { return \u0026amp;x + 1; }; static_assert(sizeof(foo) == 4); } 可以发现这种情况下，编译器不得不给x分配内存。实际上的判断规则更复杂一些，感兴趣的可以自行参考 lambda capture。最终这个提案被接受，进入了 C++17。\n2017-2019：编译期和运行期\u0026hellip;不同? # 通过不断放宽 constexpr 的限制，越来越多的函数可以在编译期执行。但是具有外部链接（也就是被extern的函数）无论如何是无法在编译期执行的。绝大部分从 C 继承过来的函数都是这样的，例如memcpy, memmove等等。\n假设我写了一个 constexpr 的memcpy\ntemplate \u0026lt;typename T\u0026gt; constexpr T* memcpy(T* dest, const T* src, std::size_t count) { for(std::size_t i = 0; i \u0026lt; count; ++i) { dest[i] = src[i]; } return dest; } 虽然能在编译期用了，编译期执行效率倒是无所谓，但是运行期效率肯定不如标准库的实现。如果能在编译期使用我的实现，运行期使用外部链接的标准库函数就好了。\n提案 P0595 希望加入一个新的 magic function 也就是 constexpr() 用来判断当前的函数是否在编译期执行，后来被更名为is_constant_evaluated并且进入 C++20。使用起来就像下面这样\nconstexpr int foo(int x) { if(std::is_constant_evaluated()) { return x; } else { return x + 1; } } 这样的话编译期和运行期就可以采用不同的逻辑实现了，我们可以对外部链接的函数进行一层封装，使得它们在内部暴露为 constexpr 的函数接口，既可以代码复用又可以保证运行期效率，两全其美。\n唯一的问题是，假设上面的foo在运行期运行，你会发现第一个分支仍然被编译了，虽然可能编译器最终应该会把if(false)这个分支优化掉。但是这个分支里面仍然会进行语法检查之类的工作，如果里面用到了模板，那么模板实例化仍然会被触发（甚至产生预料外的实例化导致编译错误），显然这不是我们想要的结果。尝试使用if constexpr改写上面的代码呢？\nconstexpr int foo(int x) { if constexpr(std::is_constant_evaluated()) { // ... } } 这种写法被认为是 obviously incorrect，因为if constexpr的条件只能在编译期执行，所以这里is_constant_evaluated永远会返回true，这与我们最开始的目的相悖了。 所以提案 P1938R3 提议加入新的语法来解决这个问题\nif consteval /* !consteval */ { // ... } else { // ... } 代码看上去是一目了然的，两个分支一个编译期一个运行期。这个升级过后的版本最终被接受并加入 C++23。\n2017-2019： 高效的调试 # C++ 模板一个最被人诟病的问题就是报错信息非常糟糕，而且难以调试。内层模板实例化失败之后，会把整个实例化栈打印出来，能轻松产生成百上千行报错。但是事情在 constexpr 函数这里其实也并没有变好，如果 constexpr 函数常量求值失败，也会把整个函数调用堆栈打印出来\nconstexpr int foo(){ return 13 + 2147483647; } constexpr int bar() { return oo(); } constexpr auto x = bar(); 报错\nin \u0026#39;constexpr\u0026#39; expansion of \u0026#39;bar()\u0026#39; in \u0026#39;constexpr\u0026#39; expansion of \u0026#39;foo()\u0026#39; error: overflow in constant expression [-fpermissive] 233 | constexpr auto x = bar(); 如果函数嵌套多了，报错信息也非常糟糕。不同于模板的地方在于，constexpr 函数也可以在运行期运行。所以我们可以在运行期调试代码，最后在编译期执行就好了。但是如果考虑到上一小节加的is_constant_evaluated，就会发现这种做法并不完全可行，因为编译期和运行期的代码逻辑可能不同。提案 P0596 希望引入constexpr_trace和constexpr_assert来方便编译期调试代码，虽然投票一致赞成，但是暂时未进入 C++ 标准。\n2017： 编译期可变容器 # 尽管在先前的提案中，允许了 constexpr 函数使用和修改变量，但是动态内存分配还是不允许的。如果有未知长度的数据需要处理，一般就是在栈上开一个大数组，这没什么问题。但是从实践上来说，有特别多的函数依赖于动态内存分配，支持 constexpr 函数中使用vector势在必得。\n在当时，直接允许在 constexpr 函数中使用new/delete似乎过于让人惊讶了，所以提案 P0597 想了一个折中的办法，先提供一个 magic container 叫做std::constexpr_vector，它由编译器实现，并且支持在 constexpr 函数中使用和修改。\nconstexpr constexpr_vector\u0026lt;int\u0026gt; x; // ok constexpr constexpr_vector\u0026lt;int\u0026gt; y{ 1, 2, 3 }; // ok constexpr auto series(int n) { std::constexpr_vector\u0026lt;int\u0026gt; r{}; for(int k; k \u0026lt; n; ++k) { r.push_back(k); } return r; } 这并不彻底解决问题，用户仍然需要重写它的代码以支持常量求值。从在 constexpr 函数支持循环的那一节来看，这种加重语言不一致性的东西，很难被加入标准。最终有更好的提案取代了它，后面会提到。\n2018：真正的编译期多态？ # 提案 P1064R0 希望在常量求值中支持虚函数调用。哎，还不支持动态内存分配呢，咋就要支持虚函数调用了？其实不依赖动态内存分配也可以弄出来多态指针嘛，指向栈上的对象或者静态储存就可以了。\nstruct Base { virtual int foo() const { return 1; } }; struct Derived : Base { int foo() const override { return 2; } }; constexpr auto foo() { Base* p; Derived d; p = \u0026amp;d; return p-\u0026gt;foo(); } 似乎没有任何理由拒绝上面这段代码编译通过。由于是在编译期执行，编译器当然能知道p指向的是Derived，然后调用Derived::f，实践上没有任何难度。的确如此，之后又有一个新的提案 P1327R1 进一步希望dynamic_cast和typeid也能在常量求值中使用，最终它们都被接受并且加入了 C++20，现在可以自由的在编译期使用这些特性了。\n2017-2019： 真正的动态内存分配！ # 在 constexpr everything 的这个演示视频中，展示了一个能在编译期处理JSON对象的例子\nconstexpr auto jsv= R\u0026#34;({ \u0026#34;feature-x-enabled\u0026#34;: true, \u0026#34;value-of-y\u0026#34;: 1729, \u0026#34;z-options\u0026#34;: {\u0026#34;a\u0026#34;: null, \u0026#34;b\u0026#34;: \u0026#34;220 and 284\u0026#34;, \u0026#34;c\u0026#34;: [6, 28, 496]} })\u0026#34;_json; if constexpr (jsv[\u0026#34;feature-x-enabled\u0026#34;]) { // feature x } else { // feature y } 希望能直接通过解析常量字符串起到配置文件的作用（字符串文本可以由#include引入）。作者们因为不能使用 STL 的容器受到了严重影响，并且自己编写了替代品。通过std::array来实现std::vector和std::map这样的容器，由于没有动态内存分配，只能预先计算出需要的大小（可能导致多次遍历）或者在栈上开块大内存。\n提案 P0784R7 重新讨论了在常量求值中支持标准库容器的可能性\n主要有以下三个难点：\n析构函数不能被声明为 constexpr（对于 constexpr 对象，它们必须是 trivial 的） 无法进行动态内存分配/释放 无法在常量求值中使用 placement new 来调用对象的构造函数 针对第一个问题，作者们与 MSVC，GCC，Clang，EDG 等前端开发人员快速讨论并解决了这个问题。C++20 起，可以符合 literal type 要求的类型具有 constexpr 修饰的析构函数，而不是严格要求平凡的析构函数。\n针对第二个问题，处理起来并不简单。C++ 有很多未定义行为都是由于错误的内存处理导致的，相比之下，不能直接操作内存的脚本语言则安全的多。但是为了复用代码，C++ 编译器中的常量求值器不得不直接操作内存，不过由于所有信息都是编译期已知的，理论上可以保证常量求值中不会出现内存错误 (out of range, double free, memory leak, \u0026hellip;)，如果出现应该中止编译并报告错误。\n常量求值器需要跟踪许多对象的的元信息，并找出这些错误\n记录union哪个 field 是 active 的，访问 unactive 的成员导致未定义行为，这由 P1330 阐明 正确记录对象的 lifetime，访问未初始化的内存和已经析构的对象都是不允许的 当时还不允许在常量求值中把void*转换成T*，所以理所当然的\nvoid* operator new(std::size_t); 不支持在常量求值中使用，取而代之的是\n// new =\u0026gt; initialize when allocate auto pa = new int(42); delete pa; // std::allocator =\u0026gt; initialize after allocate std::allocator\u0026lt;int\u0026gt; alloc; auto pb = alloc.allocate(1); alloc.deallocate(pb, 1); 它们返回的都是T*，并且由编译器实现，这对于支持标准库容器来说已经足够了。\n对于第三个问题，则是添加了一个 magic function 即 std::construct_at，它的作用是在指定的内存位置上调用对象的构造函数，用来在常量求值中取代placement new。这样的话我们就可以先通过std::allocator分配内存，再通过std::construct_at来构造对象了。该提案最终被接受，进入了 C++20，同时使得std::vector，std::string在常量求值中可用（其它的容器理论上也行，但是目前的实现还没支持，如果非常想要只能自己搓一个了）。\n虽然支持了动态内存分配，但并不是毫无限制。在一次常量求值中分配的内存必须要在这次常量求值结束之前释放完全，不能有内存泄漏，否则会导致编译错误。这种类型的内存分配被叫做 transient constexpr allocations（瞬态内存分配） 。该提案也讨论了 non-transient allocation（非瞬态内存分配） ，在编译期未被释放的内存，将被转为静态储存（其实就是存在数据区，就像全局变量那样）。但是，委员会认为这种可能性 \u0026ldquo;too brittle\u0026rdquo;，出于多种原因，目前尚未采纳。\n2018：更多的 constexpr # 提案 P1002 希望在 constexpr 函数中支持try-catch块。但是不能throw，这样是为了能把更多的标准库容器的成员函数标记为constexpr。\nconstexpr int foo(){ throw 1; return 1; } constexpr auto x = foo(); // error // expression \u0026#39;\u0026lt;throw-expression\u0026gt;\u0026#39; is not a constant expression // 233 | throw 1; 如果在编译期throw会直接导致编译错误，由于throw不会发生，那自然也不会有异常被捕获。\n2018：保证编译期执行！ # 有些时候我们想保证一个函数在编译期执行\nextern int foo(int x); constexpr int bar(int x){ return x; } foo(bar(1)); // evaluate at compile time ? 事实上g无论是在编译期还是运行期执行，理论上都可以。为了保证它在编译期执行，我们需要多写一些代码\nconstexpr auto x = bar(1); foo(x); 这样就保证了g在编译期执行，同样，这种没意义的局部变量实在是多余。提案 P1073 希望增加一个标记 constexpr!来确保一个函数在编译期执行，如果不满足则导致编译错误。最终该标记被更名为 consteval 并进入了 C++20。\nextern int foo(int x); consteval int bar(int x){ return x; } foo(bar(1)); // ensure evaluation at compile time consteval函数不能获取指针或引用，编译器后端根本不需要（也不应该）知道这些函数的存在，也不需要将它们放入符号表中等等。事实上该提案也为未来可能引入的 static reflection 做了铺垫，未来将会有大量只在编译期执行的函数进入标准。\n2018：默认 constexpr ？ # 在当时，有很多提案的内容仅仅是把标准库的某个部分标记为constexpr，在本文中没有讨论它们，因为它们具有相同的模式。\n提案 P1235 希望把所有函数都标记为 implicit constexpr 的\nnon：如果可能，将方法标记为 constexpr。 constexpr：与当前行为相同 constexpr(false)：不能在编译时调用 constexpr(true)：只能在编译时调用 该提案最终没有被接受。\n2020：更强的动态内存分配？ # 正如之前提到的，在 constexpr 函数中支持内存分配已经被允许了，也可以在 constexpr 函数中使用std::vector这样的容器，但是由于是瞬态内存分配，无法创建全局的std::vector\nconstexpr std::vector\u0026lt;int\u0026gt; v{1, 2, 3}; // error 所以如果一个 constexpr 函数返回一个std::vector，只能额外包装一层把这个std::vector转成std::array然后作为全局变量\nconstexpr auto f() { return std::vector\u0026lt;int\u0026gt;{1, 2, 3}; } constexpr auto arr = [](){ constexpr auto len = f().size(); std::array\u0026lt;int, len\u0026gt; result{}; auto temp = f(); for(std::size_t i = 0; i \u0026lt; len; ++i){ result[i] = temp[i]; } return result; }; 提案 P1974 提议使用propconst来支持非瞬态内存分配，这样上述的额外的包装代码就不需要了。\n非瞬态内存分配的原理很简单\nconstexpr std::vector vec = {1, 2, 3}; 编译器会将上述代码编译为类似下面这样\nconstexpr int data[3] = {1, 2, 3}; constexpr std::vector vec{ .begin = data, .end = data + 3, .capacity = data + 3 }; 其实就是把本来应该指向动态分配的内存的指针改为指向静态内存。原理并不复杂，真正的难点是如何保证程序的正确性。显然上述的vec即使在程序结束的时候也不应该调用析构函数，否则会导致段错误。这个问题要解决很简单，我们可以约定，任何constexpr标记的变量都不会调用析构函数。\n但是考虑如下情况：\nconstexpr unique_ptr\u0026lt;unique_ptr\u0026lt;int\u0026gt;\u0026gt; ppi { new unique_ptr\u0026lt;int\u0026gt; { new int { 42 } } }; int main(){ ppi.reset(new int { 43 }); // error, ppi is const auto\u0026amp; pi = *ppi; pi.reset(new int { 43 }); // ok } 由于pp1是constexpr的，那么它的析构函数不应该调用。对ppi尝试调用reset是不允许的，因为constexpr标记的变量隐含const，而reset并不是一个const方法。但是对pi调用reset是允许的，因为外层const不影响内层指针。\n如果允许pi调用reset，显然这是一次运行期调用，会在运行期动态内存分配，而由于ppi不会调用析构函数，里面的pi当然也不会调用析构函数，于是内存就泄露了，显然这种做法不应该被允许。\n解决办法自然是想办法禁止pi调用reset，提案提出了propconst关键字，它可以把外层的constexpr传递给内层，这样pi也是const的了，也就不能调用reset了，就不会出现代码逻辑问题了。\n可惜的的是暂时还未被标准接受，在那之后还有一些新的的提案希望能够支持这个特性比如 P2670R1，相关的讨论还在继续。\n2021：constexpr 类 # C++ 标准库中的很多类型，比如vector, string, unique_ptr中的所有方法都被标记为 constexpr，并且真正可以在编译期执行。很自然的，我们希望能直接标记整个类为 constexpr，这样可以省去哪些重复的说明符编写。\n提案 P2350 希望支持这个特性，constexpr 标记的class中的所有方法都被隐式标记为 constexpr\n// before class struct { constexpr bool empty() const { /* */ } constexpr auto size() const { /* */ } constexpr void clear() { /* */ } }; // after constexpr struct SomeType { bool empty() const { /* */ } auto size() const { /* */ } void clear() { /* */ } }; 有一个有趣的故事与这个提案有关 - 在不知道它的存在之前，我（文章原作者）在 stdcpp.ru 提出了同样的想法。\n在标准制定过程中，很多几乎相同的提案几乎可以同时出现。这证明了 多重发现理论的正确性：某些思想或概念会在不同的人群中独立地出现，就像它们在空气中漂浮一样，并且谁先发现的并不重要。如果社区的规模足够大，这些思想或概念自然会发生演变。\n2023：编译期类型擦除！ # 在常量求值中，一直不允许把void*转换成T*，这样导致诸如std::any，std::function等类型擦除实现的容器无法在常量求值中使用。原因呢，是因为我们可以通过void*来绕过类型系统，把一个类型转换为不相干的类型\nint* p = new int(42); double* p1 = static_cast\u0026lt;float*\u0026gt;(static_cast\u0026lt;void*\u0026gt;(p)); 如果对p1解引用实际上是未定义的行为，所以禁止了这种转换（注意 reinterpret_cast 一直在常量求值中禁用）。但是显然这种做法已经误伤了正确的写法了，因为像std::any这种实现，显然不会把一个从void*转换成无关的类型，而是会把它转换回原来的类型，完全不允许这种转换是不合理的。提案 P2738R0 希望在常量求值中支持这种转换，编译器理论上能在编译期记录一个void*指针原本的类型，如果转换的不是原本的类型，就报错。\n最终该提案被接受，并且加入 C++26，现在可以进行 T* -\u0026gt; void* -\u0026gt; T* 的转换了\nconstexpr void f(){ int x = 42; void* p = \u0026amp;x; int* p1 = static_cast\u0026lt;int*\u0026gt;(p); // ok float* p2 = static_cast\u0026lt;float*\u0026gt;(p); // error } 2023：支持 placement new？ # 前面我们提到，为了支持vector在常量求值中使用，加入了construct_at用于在常量求值中调用构造函数。它具有如下形式\ntemplate\u0026lt;typename T, typename... Args\u0026gt; constexpr T* construct_at(T* p, Args\u0026amp;\u0026amp;... args); 虽然一定程度上解决了问题，但是它并不能完全提供placement new的功能\nvalue initialization new (p) T(args...) // placement new version construct_at(p, args...) // construct_at version default initialization new (p) T // placement new version std::default_construct_at(p) // P2283R1 list initialization new (p) T{args...} // placement new version // construct_at version doesn\u0026#39;t exist designated initialization new (p) T{.x = 1, .y = 2} // placement new version // construct_at version cannot exist 提案 P2747R1 希望在常量求值中直接支持placement new。暂时还未被加入标准。\n2024-∞：未来无极限！ # 截止目前，C++ 的常量求值已经支持了非常丰富的功能，支持条件，变量，循环，虚函数调用，动态内存分配等等一系列特性。但是受限于日常开发使用的 C++ 版本，有很多功能可能暂时没法使用，可以在 这里 方便的查看哪个版本支持了什么特性。\n未来的 constexpr 中仍然有很多可能性，比如像memcpy这样的函数或许也能在常量求值中使用？又或者目前的small_vector的某些实现不能在不改动任何代码的前提下变成 constexpr 的，因为它们使用char数组为栈上的对象提供储存（为了避免默认构造）\nconstexpr void foo(){ std::byte buf[100]; std::construct_at(reinterpret_cast\u0026lt;int*\u0026gt;(buf), 42); // no matter what } 但是目前在常量求值中无法直接在char数组上构造对象。更进一步，在 C++20 加入的 implicit lifetime 是否可能在常量求值中表现出来呢？这些理论上都是可能实现的，只是要求编译器记录更多的元信息。而在未来，一切皆有可能！最终我们或许真的能 constexpr everything！\n","date":"February 22, 2024","externalUrl":null,"permalink":"/articles/683463723/","section":"Articles","summary":"前情提要： # https://www.ykiko.me/articles/682031684 2015-2016：模板的语法糖 # 在 C++ 中支持 全","title":"C++ 中 constexpr 的发展史（下）","type":"articles"},{"content":"几个月前，我写了一篇介绍 C++ 模板的文章\n雾里看花：真正意义上的理解 C++ 模板 https://www.ykiko.me/articles/655902377\n理清了现代 C++ 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C++ 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C++ 版本都在改进它，所以不同的 C++ 版本可以使用的内容差别很大，有时候可能给人一种inconsistency的感觉。\n刚好最近我偶然间读到了这篇文章：Design and evolution of constexpr in C++，全面介绍了 C++ 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。\n但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：izaronplatz@gmail.com，我已经和他联系过了，他回复到：\nIt\u0026rsquo;s always good to spread knowledge in more languages.\n也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。\n原文内容较长，故分为上下两篇，这是上篇\n很神奇吗？ # constexpr 是当代 C++ 中最神奇的关键字之一。它使得某些代码可以在编译期执行。\n随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。\nconstexpr 的发展历史可以追溯到早期版本的 C++。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。\n本文适合于任何人，无论你是否了解 constexpr ！\nC++98/03：我比你更 const # 在 C++ 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C++ 标准允许通过简单的表达式来构造常量，例如\nenum EPlants{ APRICOT = 1 \u0026lt;\u0026lt; 0, LIME = 1 \u0026lt;\u0026lt; 1, PAPAYA = 1 \u0026lt;\u0026lt; 2, TOMATO = 1 \u0026lt;\u0026lt; 3, PEPPER = 1 \u0026lt;\u0026lt; 4, FRUIT = APRICOT | LIME | PAPAYA, VEGETABLE = TOMATO | PEPPER, }; template \u0026lt;int V\u0026gt; int foo(int v = 0){ switch(v){ case 1 + 4 + 7: case 1 \u0026lt;\u0026lt; (5 | sizeof(int)): case (12 \u0026amp; 15) + PEPPER: return v; } } int f1 = foo\u0026lt;1 + 2 + 3\u0026gt;(); int f2 = foo\u0026lt;((1 \u0026lt; 2) ? 10 * 11 : VEGETABLE)\u0026gt;(); 这些表达式在[expr.const]小节中被定义，并且被叫做常量表达式（constant expression） 。它们只能包含：\n字面量：1,'A',true,... 枚举值 整数或枚举类型的模板参数（例如template\u0026lt;int v\u0026gt;中的v） sizeof表达式 由常量表达式初始化的const变量 前几项都很好理解的，对于最后一项稍微有点复杂。如果一个变量具有 静态储存期，那么在常规情况下，它的内存会被填充为0，之后在程序开始执行的时候改变。但是对于上述的变量来说，这太晚了，需要在编译结束之前就计算出它们的值。\n在 C++98/03 当中有两种类型的 静态初始化：\n零初始化 内存被填充为0，然后在程序执行期间改变 常量初始化 使用常量表达式进行初始化，内存（如果需要的话）立即填充为计算出来的值 所有其它的初始化都被叫做 动态初始化，这里我们不考虑它们。\n让我们看一个包含两种静态初始化的例子\nint foo() { return 13; } const int v1 = 1 + 2 + 3 + 4; // const initialization const int v2 = 15 * v1 + 8; // const initialization const int v3 = foo() + 5; // zero initialization const int v4 = (1 \u0026lt; 2) ? 10 * v3 : 12345; // zero initialization const int v5 = (1 \u0026gt; 2) ? 10 * v3 : 12345; // const initialization 变量v1, v2和v5都可以作为常量表达式，可以用作模板参数，switch的case，enum的值，等等。而v3和v4则不行。即使我们能明显看出foo() + 5的值是18，但在那时还没有合适的语义来表达这一点。\n由于常量表达式是递归定义的，如果一个表达式的某一部分不是常量表达式，那么整个表达式就不是常量表达式。在这个判断过程中，只考虑实际计算的表达式，所以v5是常量表达式，但v4不是。\n如果没有获取常量初始化的变量的地址，编译器就可以不为它分配内存。所以我们可以通过取地址的方式，来强制编译器给常量初始化的变量预留内存（其实如果没有显式取地址的话，普通的局部变量也可能被优化掉，任何不违背 as-if 原则的优化都是允许的。可以考虑使用[[gnu::used]]这个 attribute 标记避免变量被优化掉）。\nint main() { std::cout \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026amp;v1 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; v2 \u0026lt;\u0026lt; \u0026amp;v2 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; v3 \u0026lt;\u0026lt; \u0026amp;v3 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; v4 \u0026lt;\u0026lt; \u0026amp;v4 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; v5 \u0026lt;\u0026lt; \u0026amp;v5 \u0026lt;\u0026lt; std::endl; } 编译上述代码并查看符号表（环境是 windows x86-64）\n$ g++ --std=c++98 -c main.cpp $ objdump -t -C main.o (sec 6)(fl 0x00)(ty 0)(scl 3) (nx 0) 0x0000000000000000 v1 (sec 6)(fl 0x00)(ty 0)(scl 3) (nx 0) 0x0000000000000004 v2 (sec 3)(fl 0x00)(ty 0)(scl 3) (nx 0) 0x0000000000000000 v3 (sec 3)(fl 0x00)(ty 0)(scl 3) (nx 0) 0x0000000000000004 v4 (sec 6)(fl 0x00)(ty 0)(scl 3) (nx 0) 0x0000000000000008 v5 ---------------------------------------------------------------- (sec 3)(fl 0x00)(ty 0)(scl 3) (nx 1) 0x0000000000000000 .bss (sec 4)(fl 0x00)(ty 0)(scl 3) (nx 1) 0x0000000000000000 .xdata (sec 5)(fl 0x00)(ty 0)(scl 3) (nx 1) 0x0000000000000000 .pdata (sec 6)(fl 0x00)(ty 0)(scl 3) (nx 1) 0x0000000000000000 .rdata 可以发现在我的 GCC 14 上，零初始化的变量v3和v4被放在.bss段，而常量初始化的变量v1, v2,v5被放在.rdata段。操作系统会对.rdata段进行保护，使其处于只读模式，尝试写入会导致段错误。\n从上述的差异可以看出，一些const变量比其它的更加const。但是在当时我们并没有办法检测出这种差异（后来的 C++20 引入了 constinit 来确保一个变量进行常量初始化）。\n0-∞：编译器中的常量求值器 # 为了理解常量表达式是如何求值的，我们需要简单了解编译器的构造。不同编译器的处理方法大致相同，接下来将以 Clang/LLVM 为例\n总的来说，编译器可以看做由以下三个部分组成：\n前端（Front-end）：将 C/C++/Rust 等源代码转换为 LLVM IR（一种特殊的中间表示）。Clang 是 C 语言家族的编译器前端 中端（Middle-end）：根据相关的设置对 LLVM IR 进行优化 后端（Back-end）：将 LLVM IR 转换为特定平台的机器码： x86/Arm/PowerPC 等等 对于一个简单的编程语言，通过调用 LLVM，1000行就能实现一个编译器。你只需要负责实现语言前端就行了，后端交给 LLVM 即可。甚至前端也可以考虑使用 lex/yacc 这样的现成的语法解析器。\n具体到编译器前端的工作，例如这里提到的 Clang，可以分为以下三个阶段：\n词法分析：将源文件转换为 Token Stream，例如 []() { return 13 + 37; } 被转换为 [, ], (, ), {, return, 13, +, 37, ;, } 语法分析：产生 Abstract Syntax Tree（抽象语法树），就是将上一步中的 Token Stream 转换为类似于下面这样的递归的树状结构 lambda-expr └── body └── return-expr └── plus-expr ├── number 13 └── number 37 代码生成：根据给定的 AST 生成 LLVM IR 因此，常量表达式的计算（以及相关的事情，如模板实例化）严格发生在 C++ 编译器的前端，而 LLVM 不涉及此类工作。这种处理常量表达式（从 C++98 的简单表达式到 C++23 的复杂表达式）的工具被称为常量求值器 (constant evaluator) 。\n多年来，对常量表达式的限制一直在不断放宽，而 Clang 的常量求值器相应地变得越来越复杂，直到管理 memory model（内存模型）。有一份旧的 文档，描述 C++98/03 的常量求值。由于当时的常量表达式非常简单，它们是通过分析语法树进行 constant folding （常量折叠）来进行的。由于在语法树中，所有的算术表达式都已经被解析为子树的形式，因此计算常量就是简单地遍历子树。\n常量计算器的源代码位于 lib/AST/ExprConstant.cpp，在撰写本文时已经扩展到将近 17000 行。随着时间的推移，它学会了解释许多内容，例如循环（EvaluateLoopBody），所有这些都是在语法树上进行的。\n常量表达式与运行时代码有一个重要的区别：它们必须不引发 undefined behavior（未定义行为）。如果常量计算器遇到未定义行为，编译将失败。\nerror: constexpr variable \u0026#39;foo\u0026#39; must be initialized by a constant expression 2 | constexpr int foo = 13 + 2147483647; | ^ ~~~~~~~~~~~~~~~ note: value 2147483660 is outside the range of representable values of type \u0026#39;int\u0026#39; 2 | constexpr int foo = 13 + 2147483647; 因此在有些时候可以用它们来检测程序中的潜在错误。\n2003：真的能 macro free 吗？ # 标准的改变是通过 proposals（提案）进行的\n在哪里可以找到提案？它们是由什么组成的？\n所有的有关 C++ 标准的提案都可以在 open-std.org 上找到。它们中的大多数都有详细的描述并且易于阅读。通常由如下部分组成： - 当前遇到的问题 - 标准中相关措辞的的链接 - 上述问题的解决方案 - 建议对标准措辞进行的修改 - 相关提案的链接（提案可能有多个版本或者需要和其它提案进行对比） - 在高级提案中，往往还会附带上实验性实现的链接\n可以通过这些提案来了解 C++ 的每个部分是如何演变的。并非存档中的所有提案最终都被接受，但是它们都对 C++ 的发展有着重要的影响。\n通过提交新提案，任何人都可以参与到 C++ 的演变过程中来。\n2003年的提案 N1521 Generalized Constant Expressions 指出一个问题。如果一个表达式中的某个部分含有函数调用，那么整个表达式就不能是常量表达式，即使这个函数最终能够被常量折叠。这迫使人们在处理复杂常量表达式的时候使用宏，甚至一定程度上导致了宏的滥用\ninline int square(int x) { return x * x; } #define SQUARE(x) ((x) * (x)) square(9) std::numeric_limits\u0026lt;int\u0026gt;::max() // 理论上可用于常量表达式, 但是实际上不能 SQUARE(9) INT_MAX // 被迫使用宏代替 因此，建议引入常值 (constant-valued) 函数的概念，允许在常量表达式中使用这些函数。如果希望一个函数是常值函数，那么它必须满足\ninline ，non-recursive，并且返回类型不是 void 仅由单一的 return expr 语句组成，并且在把 expr 里面的函数参数替换为常量表达式之后，得到的仍然是一个常量表达式 如果这样的函数被调用，并且参数是常量表达式，那么函数调用表达式也是常量表达式\nint square(int x) { return x * x; } // constant-valued long long_max(int x) { return 2147483647; } // constant-valued int abs(int x) { return x \u0026lt; 0 ? -x : x; } // constant-valued int next(int x) { return ++x; } // non constant-valued 这样的话，不需要修改任何代码，最开始的例子中的v3和v4也可以被用作常量表达式了，因为foo被认为是常值函数。\n该提案认为，可以考虑进一步支持下面这种情况\nstruct cayley{ const int value; cayley(int a, int b) : value(square(a) + square(b)) {} operator int() const { return value; } }; std::bitset\u0026lt;cayley(98, -23)\u0026gt; s; // same as bitset\u0026lt;10133\u0026gt; 因为成员value是totally constant的，在构造函数中通过两次调用常值函数进行初始化。换句话说，根据该提案的一般逻辑，此代码可以大致转换为以下形式（将变量和函数移到结构体之外）：\n// 模拟 cayley::cayley(98, -23)的构造函数调用和 operator int() const int cayley_98_m23_value = square(98) + square(-23); int cayley_98_m23_operator_int() { return cayley_98_m23_value; } // 创建 bitset std::bitset\u0026lt;cayley_98_m23_operator_int()\u0026gt; s; // same as bitset\u0026lt;10133\u0026gt; 但是和变量一样，程序员无法确定一个函数是否为常值函数，只有编译器知道。\n提案通常不会深入到编译器实现它们的细节。上述提案表示，实现它不应该有任何困难，只需要稍微改变大多数编译器中存在的常量折叠即可。然而，提案与编译器实现密切相关。如果提案无法在合理时间内实现，很可能不会被采纳。从后来的视角来看，许多大的提案最后被分成了多个小的提案逐步实现\n2006-2007：当一切浮出水面 # 幸运的是，三年后，这个提案的后续修订版 N2235 认识到了过多的隐式特性是不好的，程序员应该有办法确保一个变量可以被用作常量，如果不满足相应的条件应该导致编译错误。\nstruct S{ static const int size; }; const int limit = 2 * S::size; // dynamic initialization const int S::size = 256; // const initialization const int z = std::numeric_limits\u0026lt;int\u0026gt;::max(); // dynamic initialization 根据程序员的设想，limit应该被常量初始化，但事实并非如此，因为S::size被定义在limit之后，定义的太晚了。可以通过 C++20 加入的 constinit 来验证这一点，constinit保证一个变量进行常量初始化，如果不能进行常量初始化，则会编译错误。\n在新的提案中，常值函数被重命名为 constexpr function ，对它们的要求保持不变。但现在，为了能够在常量表达式中使用它们，必须使用 constexpr 关键字进行声明。此外，如果函数体不符合相关的要求，将会编译失败。同时建议将一些标准库的函数（如std::numeric_limits中的函数）标记为 constexpr，因为它们符合相关的要求。变量或类成员也可以声明为 constexpr，这样的话，如果变量不是通过常量表达式进行初始化，将会编译失败。\n用户自定义class的 constexpr 构造函数也合法化了。该构造函数必须具有空函数体，并用常量表达式初始化成员。隐式生成的构造函数将尽可能的被标记为 constexpr。对于 constexpr 的对象，析构函数必须是平凡的，因为非平凡的析构函数通常会在正在执行的程序上下文中做一些改变，而在 constexpr 计算中不存在这样的上下文。\n以下是包含 constexpr 的示例类：\nstruct complex { constexpr complex(double r, double i) : re(r), im(i) { } constexpr double real() { return re; } constexpr double imag() { return im; } private: double re; double im; }; constexpr complex I(0, 1); // OK 在提案中，像I这样的对象被称为用户自定义字面量。\u0026ldquo;字面量\u0026rdquo; 是 C++ 中的基本实体。就像 \u0026ldquo;简单\u0026rdquo; 字面量（数字、字符等）立即被嵌入到汇编指令中，字符串字面量存储在类似.rodata的段中那样，用户定义的字面量也在其中占有一席之地。\n现在 constexpr 变量不仅可以是数字和枚举，还可以是 literal type，在此提案中引入了（尚不支持引用类型）。literal type 是可以传递给 constexpr 函数的类型，这些类型足够简单，以至于编译器可以在常量计算中支持它们。\nconstexpr 关键字最后成为了一个 specifier（说明符 ），类似于 *override * 这样仅用作标记。在讨论后，决定不创建新的 储存期类型 和新的类型限定符，并且也决定不允许将其用于函数参数，以免使得函数的overload resolution规则变得过于复杂。\n2007：试着让标准库更加 constexpr？ # 在这一年，提案 N2349 Constant Expressions in the Standard Library 被提出，其中标记了一些函数和常量为 constexpr，还有一些容器的函数，例如：\ntemplate\u0026lt;size_t N\u0026gt; class bitset{ // ... constexpr bitset(); constexpr bitset(unsigned long); // ... constexpr size_t size(); // ... constexpr bool operator[](size_t) const; }; 构造函数通过 constant-expression 初始化类的成员，其他函数内部含有单个 return 语句，符合当前的规定。\n所有关于 constexpr 的提案中，超过一半是建议将标准库中的某些函数标记为 constexpr。就内容而言，其实并不是十分有趣，因为它们并没有导致核心语言规则的改变。\n2008年：停停\u0026hellip;机问题？我才不管！ # constexpr unsigned int factorial(unsigned int n){ return n == 0 ? 1 : n * factorial(n - 1); } 最初，提案提出者希望允许在 constexpr 函数中进行递归调用，但出于谨慎起见，这一做法被禁止了。然而，在审查过程中，由于措辞的变化，意外地允许了这种做法。CWG 认为递归具有足够的使用情景，因此应该允许它们。如果允许函数之间相互递归调用，还需要允许 constexpr 函数的 forward declaration（向前声明） 。在 constexpr 函数中调用未定义的 constexpr 函数时，应该在需要常量求值的上下文中进行诊断。这一点在 N2826 被澄清\n既然有递归，那就可能出现无穷递归。一个函数究竟会不会无穷递归？在一些简单的情况下，静态分析工具可以分析无穷递归是否会发生。而在一般情况下，这其实是个 停机问题，无法解决。\n一般来说，编译器会设置一个默认递归层数。如果递归层数超过这个默认的层数，则会编译错误\nconstexpr int foo(){ return f() + 1; } constexpr int x = foo(); 上述代码编译错误\nerror: \u0026#39;constexpr\u0026#39; evaluation depth exceeds maximum of 512 (use \u0026#39;-fconstexpr-depth=\u0026#39; to increase the maximum) 24 | constexpr int x = foo(); 在 Clang 中默认的层数是 512，可以通过-fconstexpr-depth来修改，其实模板实例化也会有类似的层数限制。从效果上而言，这个限制可以看成类似运行时函数调用的栈大小，超过这个大小就会“爆栈”了，其实也是挺合理的。\n2010：引用还是指针？ # 当时，许多函数都无法被标记为 constexpr，因为它们的参数中含有引用。\ntemplate \u0026lt;class T\u0026gt; constexpr const T\u0026amp; max(const T\u0026amp; a, const T\u0026amp; b); // error constexpr pair(); // ok pair(const T1\u0026amp; x, const T2\u0026amp; y); // error 提案 N3039 Constexpr functions with const reference parameters 希望允许函数参数和返回值出现常量引用。\n事实上，这是个非常巨大的改变。在此之前，常量求值中只有值，没有引用（指针）。只需要简单的对值进行运算就行了，引用的引入让常量求值器不得不建立一个内存模型。如果要支持const T\u0026amp;，编译器需要在编译期创建一个临时对象，然后将引用绑定到它上面。任何对该对象不合法的访问都应该导致编译错误。\ntemplate \u0026lt;typename T\u0026gt; constexpr T self(const T\u0026amp; a) { return *(\u0026amp;a); } template \u0026lt;typename T\u0026gt; constexpr const T* self_ptr(const T\u0026amp; a) { return \u0026amp;a; } template \u0026lt;typename T\u0026gt; constexpr const T\u0026amp; self_ref(const T\u0026amp; a) { return *(\u0026amp;a); } template \u0026lt;typename T\u0026gt; constexpr const T\u0026amp; near_ref(const T\u0026amp; a) { return *(\u0026amp;a + 1); } constexpr auto test1 = self(123); // OK constexpr auto test2 = self_ptr(123); // 失败，指向临时对象的指针不是常量表达式 constexpr auto test3 = self_ref(123); // OK constexpr auto tets4 = near_ref(123); // 失败，指针越界访问 2011：为什么不能有声明？ # 前文提到过，constexpr 函数只能由单个 return 语句构成。这就意味着，里面甚至不允许任何不影响求值的声明。但是至少有三种声明有助于编写此类函数：静态断言，类型别名和常量表达式初始化的局部变量\nconstexpr int f(int x){ constexpr int magic = 42; return x + magic; // should be ok } 提案 N3268 static_assert and list-initialization in constexpr functions 希望在 constexpr 函数中支持这些静态声明。\n2012：我需要分支！ # 有许多简单的函数，希望能够在编译时计算，例如计算a的n次方：\nint pow(int a, int n){ if (n \u0026lt; 0) throw std::range_error(\u0026#34;negative exponent for integer power\u0026#34;); if (n == 0) return 1; int sqrt = pow(a, n / 2); int result = sqrt * sqrt; if (n % 2) return result * a; return result; } 然而，在当时（C++11），为了它能够变成 constexpr 的，程序员需要按照纯函数式风格（没有局部变量和循环）写一份全新的代码\nconstexpr int pow_helper(int a, int n, int sqrt) { return sqrt * sqrt * ((n % 2) ? a : 1); } constexpr int pow(int a, int n){ return (n \u0026lt; 0) ? throw std::range_error(\u0026#34;negative exponent for integer power\u0026#34;) : (n == 0) ? 1 : pow_helper(a, n, pow(a, n / 2)); } 提案 N3444 Relaxing syntactic constraints on constexpr functions 希望进一步放宽 constexpr 函数的限制，以便能够编写任意的代码\n允许声明具有 literal type 类型的局部变量，如果它们是通过构造函数进行初始化的，则该构造函数也必须被标记为 constexpr。这样，常量求值器可以缓存这些变量，避免重复求值相同的表达式，提高常量求值器的执行效率，但是不允许修改这些变量 允许局部类型声明 允许使用if和多个return语句，并且要求每个分支至少有一个return语句 允许 expression statement（仅由表达式构成的语句） 允许静态变量的地址或引用作为常量表达式 constexpr mutex\u0026amp; get_mutex(bool which){ static mutex m1, m2; if (which) return m1; else return m2; } constexpr mutex\u0026amp; m = get_mutex(true); // OK 但是，不允许for/while循环，goto，switch，try，这些可能产生复杂控制流，甚至产生无穷循环的语句。\n2013：小孩子才做选择，循环我也要！ # 然而，CWG 认为在 constexpr 函数中支持循环（至少支持for）是必须的。2013年提案 Relaxing constraints on constexpr functions 发布了修订版本。\n实现 constexpr for 考虑了四种选项。\n添加全新的循环语法，新语法与 constexpr 所需的函数式编程风格良好交互。虽然解决了缺乏循环的问题，但并未消除程序员对现有语言的不满（为了支持 constexpr，需要将原有的代码重新改写） 仅支持传统 C 语言风格的 for 循环，为此，至少需要支持 constexpr 函数中对变量进行更改 仅支持 range-based for loop，这样的循环不能与用户定义的迭代器类型一起使用，除非进一步放宽语言规则 允许在 constexpr 函数中使用 C++ 的一致和广泛的子集，可能包括所有 C++ 最后选择的是最后一个选项，这极大的影响了 constexpr 在 C++ 中的后续发展。\n为了支持这个选项，我们不得不在 constexpr 函数中引入变量的可变性，即支持修改变量的值。根据该提案，现在可以更改在常量求值过程中创建的对象，直到求值过程或对象的 lifetime 结束。这些求值过程将在类似虚拟机的沙箱中进行，不会影响外部的代码。因此理论上，输出相同的 constexpr 参数将会输出相同的结果。\nconstexpr int f(int a){ int n = a; ++n; // ++n 不是一个常量表达式 return n * a; } int k = f(4); // OK，这是一个常量表达式 // f 中的 n 可以被修改，因为其生存期 // 在表达式求值期间开始 constexpr int k2 = ++k; // 错误，不是一个常量表达式，不能修改 k // 因为其生存期没有在，这个表达式内开始 struct X{ constexpr X() : n(5){ n *= 2; // 不是一个常量表达式 } int n; }; constexpr int g(){ X x; // x 的初始化是一个常量表达式 return x.n; } constexpr int k3 = g(); // OK，这是一个常量表达式 // x.n 可以被修改，因为 // x 的生存期在 g() 的求值期间开始 另外，我想指出现在这样的代码也能编译通过：\nconstexpr void add(X\u0026amp; x) { x.n++; } constexpr int g(){ X x; add(x); return x.n; } 常量求值中，局部的副作用也是允许的！\n2013：constexpr 不是 const 的子集！ # 目前，类的 constexpr 函数会自动标记为 const\n在提案 constexpr member functions and implicit const 中指出：如果一个成员函数是 constexpr 的，它不一定一定要是 const 的。随着 constexpr 计算中的可变性变得越来越重要，这一点变得更加突出。但即使在此之前，它也妨碍了在 constexpr 和非 constexpr 代码中使用相同的函数：\nstruct B{ A a; constexpr B() : a() {} constexpr const A\u0026amp; getA() const /*implicit*/ { return a; } A\u0026amp; getA() { return a; } // 代码重复 }; 有趣的是，提案提供了三个选项，其中选择了第二个：\n维持现状 -\u0026gt; 导致代码重复 被 constexpr 标记的函数不是隐式 const 的 -\u0026gt; 破坏 ABI，成员函数的 const 签名是函数类型的一部分 使用mutable进行标记constexpr A \u0026amp;getA() mutable { return a; }; -\u0026gt; 更加不协调了 最终，方案2被接受了，现在如果一个成员函数被 constexpr 标记，不代表它是隐式 const 的成员函数了。\n下篇在这里\nC++ 中 constexpr 的发展史（下） https://www.ykiko.me/articles/683463723\n","date":"February 10, 2024","externalUrl":null,"permalink":"/articles/682031684/","section":"Articles","summary":"几个月前，我写了一篇介绍 C++ 模板的文章 雾里看花：真正意义上的理","title":"C++ 中 constexpr 的发展史!（上）","type":"articles"},{"content":" 拒绝硬编码 # 定义一个enum\nenum Color { RED, GREEN, BLUE }; 尝试打印\nColor color = RED; std::cout \u0026lt;\u0026lt; color \u0026lt;\u0026lt; std::endl; // output =\u0026gt; 0 如果需要枚举作为日志输出，我们不希望在查看日志的时候，还要人工去根据枚举值去查找对应的字符串，麻烦并且不直观。我们希望直接输出枚举值对应的字符串，比如RED，GREEN，BLUE。\n考虑使用一个数组当map，将枚举值作为key，将字符串作为value，这样就可以通过枚举值直接查找到对应的字符串了\nstd::string_view color_map[] = { \u0026#34;RED\u0026#34;, \u0026#34;GREEN\u0026#34;, \u0026#34;BLUE\u0026#34; }; 但是当枚举数量很多的时候，手写并不方便，非常繁琐。具体表现为，如果我们想增加若干枚举定义，那字符串映射表相应的内容也需要修改，当数量达到上百个的时候，很可以会有疏漏。或者接手一个别人的项目，发现他有一大堆枚举，内容太多，手写非常耗时间。\n需要寻找解决办法，能自动的进行相关的修改。在别的语言中，如 Java，C#，Python，可以轻松的通过反射实现这个功能。但是 C++ 目前并没有反射，故此路不通。目前这个问题主要有三种解决方案。\n模板打表 # 这一小节介绍的内容已经有人提前封装好了，可以直接使用 magic enum 这个库。下面主要是对这个库的原理进行解析，为了方便展示，将用 C++20 实现，实际上 C++17 就可以。\n在三大主流编译器中，有一些特殊宏变量。GCC 和 Clang 中的__PRETTY_FUNCTION__，MSVC 中的__FUNCSIG__。这几个宏变量会在编译期间被替换成函数的签名，如果该函数是模板函数则会将模板实例化的信息也输出（也可以使用 C++20 加入标准的 source_location，它具有和这些宏类似的效果）\ntemplate \u0026lt;typename T\u0026gt; void print_fn(){ #if __GNUC__ || __clang__ std::cout \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; std::endl; #elif _MSC_VER std::cout \u0026lt;\u0026lt; __FUNCSIG__ \u0026lt;\u0026lt; std::endl; #endif } print_fn\u0026lt;int\u0026gt;(); // gcc and clang =\u0026gt; void print_fn() [with T = int] // msvc =\u0026gt; void __cdecl print_fn\u0026lt;int\u0026gt;(void) 特别的，当模板参数是枚举常量的时候，会输出枚举常量的名称\ntemplate \u0026lt;auto T\u0026gt; void print_fn(){ #if __GNUC__ || __clang__ std::cout \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; std::endl; #elif _MSC_VER std::cout \u0026lt;\u0026lt; __FUNCSIG__ \u0026lt;\u0026lt; std::endl; #endif } enum Color { RED, GREEN, BLUE }; print_fn\u0026lt;RED\u0026gt;(); // gcc and clang =\u0026gt; void print_fn() [with auto T = RED] // msvc =\u0026gt; void __cdecl print_fn\u0026lt;RED\u0026gt;(void) 可以发现，在特定的位置出现了枚举名。通过简单的字符串裁剪，便能得到我们想要的内容了\ntemplate\u0026lt;auto value\u0026gt; constexpr auto enum_name(){ std::string_view name; #if __GNUC__ || __clang__ name = __PRETTY_FUNCTION__; std::size_t start = name.find(\u0026#39;=\u0026#39;) + 2; std::size_t end = name.size() - 1; name = std::string_view{ name.data() + start, end - start }; start = name.rfind(\u0026#34;::\u0026#34;); #elif _MSC_VER name = __FUNCSIG__; std::size_t start = name.find(\u0026#39;\u0026lt;\u0026#39;) + 1; std::size_t end = name.rfind(\u0026#34;\u0026gt;(\u0026#34;); name = std::string_view{ name.data() + start, end - start }; start = name.rfind(\u0026#34;::\u0026#34;); #endif return start == std::string_view::npos ? name : std::string_view{ name.data() + start + 2, name.size() - start - 2 }; } 进行测试\nenum Color { RED, GREEN, BLUE }; int main(){ std::cout \u0026lt;\u0026lt; enum_name\u0026lt;RED\u0026gt;() \u0026lt;\u0026lt; std::endl; // output =\u0026gt; RED } 成功满足我们的需求。但是事情并没有结束，这种形式要求枚举是模板参数，那就只支持编译期常量。但是其实绝大部分时候，我们用的枚举都是运行期变量，怎么办呢？静态转动态，只要打个表就行了，考虑通过模板元编程生成一个array，其中每个元素就是index对应枚举的字符串表示。一个问题是，这个数组应该多大，这就需要我们来获取枚举项的数量了。一种比较直接的办法是，直接在枚举中定义一对用来标记的首尾项，这样直接相减就能获取到枚举的最大数量了。但是很多时候，我们并不能修改枚举定义，还好这里有一个小 trick 能解决这个问题\nconstexpr Color color = static_cast\u0026lt;Color\u0026gt;(-1); std::cout \u0026lt;\u0026lt; enum_name\u0026lt;color\u0026gt;() \u0026lt;\u0026lt; std::endl; // output =\u0026gt; (Color)2 可以发现，如果这个整数没有对应的枚举项，那么最后就不会输出对应的枚举名，而是带有括号的强制转换表达式。这样只需要判断下得到的字符串中有没有)就知道对应的枚举项是否存在了。递归判断就可以找出最大的枚举值了（这样查找适用范围有限，如分散枚举值，可能相对困难一点）\ntemplate\u0026lt;typename T, std::size_t N = 0\u0026gt; constexpr auto enum_max(){ constexpr auto value = static_cast\u0026lt;T\u0026gt;(N); if constexpr (enum_name\u0026lt;value\u0026gt;().find(\u0026#34;)\u0026#34;) == std::string_view::npos) return enum_max\u0026lt;T, N + 1\u0026gt;(); else return N; } 然后通过make_index_sequence生成一个对应的长度数组就行了\ntemplate\u0026lt;typename T\u0026gt; requires std::is_enum_v\u0026lt;T\u0026gt; constexpr auto enum_name(T value){ constexpr auto num = enum_max\u0026lt;T\u0026gt;(); constexpr auto names = []\u0026lt;std::size_t... Is\u0026gt;(std::index_sequence\u0026lt;Is...\u0026gt;){ return std::array\u0026lt;std::string_view, num\u0026gt;{ enum_name\u0026lt;static_cast\u0026lt;T\u0026gt;(Is)\u0026gt;()... }; }(std::make_index_sequence\u0026lt;num\u0026gt;{}); return names[static_cast\u0026lt;std::size_t\u0026gt;(value)]; } 测试一下\nenum Color { RED, GREEN, BLUE }; int main(){ Color color = RED; std::cout \u0026lt;\u0026lt; enum_name(color) \u0026lt;\u0026lt; std::endl; // output =\u0026gt; RED } 更进一步可以考虑支持 bitwidth enum，也就是RED | BLUE这种形式的枚举，这里就不继续展开了。\n这种方法的缺点很明显，通过模板实例化来打表，其实会很大的拖慢编译速度。如果enum中的数量较多，在一些对常量求值效率较低的编译器上，如 MSVC，可能会增加几十秒甚至更长的编译时间。所以一般只适用于小型枚举。优点是轻量级，开箱即用，其它的什么也不用做。\n外部代码生成 # 既然手写字符串转枚举很麻烦，那么写个脚本生成代码不就行了？的确如此，我们可以使用 libclang 的 python bind 轻松的完成这项工作。具体如何使用这个工具，可以参考 使用 clang 工具自由的支配 C++ 代码吧，下面只展示实现效果的代码\nimport clang.cindex as CX def generate_enum_to_string(enum: CX.Cursor): branchs = \u0026#34;\u0026#34; for child in enum.get_children(): branchs += f\u0026#39;case {child.enum_value}: return \u0026#34;{child.spelling}\u0026#34;;\\n\u0026#39; code = f\u0026#34;\u0026#34;\u0026#34; std::string_view {enum.spelling}_to_string({enum.spelling} value) {{ switch(value) {{ {branchs}}}}}\u0026#34;\u0026#34;\u0026#34; return code def traverse(node: CX.Cursor): if node.kind == CX.CursorKind.ENUM_DECL: print(generate_enum_to_string(node)) return for child in node.get_children(): traverse(child) index = CX.Index.create() tu = index.parse(\u0026#39;main.cpp\u0026#39;) traverse(tu.cursor) 测试代码\n// main.cpp enum Color { RED, GREEN, BLUE }; 这是最后生成的代码，可以直接生成.cpp文件，放在固定目录下面，然后构建之前运行一下这个脚本就行了\nstd::string_view enum_to_string(Color value) { switch(value) { case 0: return \u0026#34;RED\u0026#34;; case 1: return \u0026#34;BLUE\u0026#34;; case 2: return \u0026#34;GREEN\u0026#34;; }} 优点，非侵入式，可以用于大数量的枚举。缺点，有外部依赖，需要将代码生成加入到编译流程里面。可能会使编译流程变得很复杂。\n宏 # 上面的两种方式都是非侵入式的。也就是说，可能你拿到了一个别人的库，不能修改它的代码，只好这么做了。如果是完全由自己定义枚举呢？其实可以在定义阶段就特殊处理，以方便后续的使用。比如（代码开头的注释表示当前文件名）：\n// Color.def #ifndef COLOR_ENUM #define COLOR_ENUM(...) #endif COLOR_ENUM(RED) COLOR_ENUM(GREEN) COLOR_ENUM(BLUE) #undef COLOR_ENUM 然后在要使用的地方，通过修改宏定义来生成代码就行了\n// Color.h enum Color { #define COLOR_ENUM(x) x, #include \u0026#34;Color.def\u0026#34; }; std::string_view color_to_string(Color value){ switch(value){ #define COLOR_ENUM(x) case x: return #x; #include \u0026#34;Color.def\u0026#34; } } 这样的话，只要在def文件里面进行相关的增加和修改就行了。之后如果要遍历enum什么的，也可以直接定义一个宏来生成代码就行了，非常方便。事实上，对于大数量的枚举，有很多开源项目都采取这种方案。例如 clang 在定义TokenKind的时候，就是这么做的，相关的代码请参考 Token.def。由于 clang 要适配多种语言前端，最后总计的TokenKind有几百个之多。如果不这样做，进行Token的增加和修改会十分困难。\n总结 # 非侵入式且枚举数量较少，编译速度不是很重要，那就使用模板打表（至少要求 C++17） 非侵入式且枚举数量较多，编译速度很重要，那就使用外部代码生成 侵入式，可以直接使用宏 年年月月盼反射，还是不知道什么时候才能进入标准呢。想要提前了解 C++ 静态反射的小伙伴，可以看\nC++26 静态反射提案解析 https://www.ykiko.me/articles/661692275\n或者还不知道反射是什么的小伙伴，可以参考这篇文章的内容\n写给 C++ 程序员的反射教程 https://www.ykiko.me/articles/669358870\n","date":"January 29, 2024","externalUrl":null,"permalink":"/articles/680412313/","section":"Articles","summary":"拒绝硬编码 # 定义一个enum enum Color { RED, GREEN, BLUE }; 尝试打印 Color color = RED; std::cout","title":"C++ 中如何优雅进行 enum 到 string 的转换 ？","type":"articles"},{"content":"众所周知，现在 C++ 里面有两种特殊的构造函数，即 copy constructor 和 move constructor\ncopy constructor 早在 C++98 的时候就加入了，用来拷贝一个对象，像vector这种拥有资源的类型，拷贝的时候会把它拥有的资源也拷贝一份\nstd::vector\u0026lt;int\u0026gt; v1 = {1, 2, 3}; std::vector\u0026lt;int\u0026gt; v2 = v1; // copy 当然了，拷贝的开销有些时候非常大，而且完全没必要。于是在 C++11 加入了 move constructor，用来把一个对象的资源转移到另一个对象上。这样相对于直接拷贝，开销是小得多的\nstd::vector\u0026lt;int\u0026gt; v1 = {1, 2, 3}; std::vector\u0026lt;int\u0026gt; v2 = std::move(v1); // move 注意 C++ 中的 move 被叫做 non-destructive move。 C++ 标准规定了，被移动过后的对象状态是一种 valid state ，实现需要保证它能够正常调用析构函数。被移动的对象仍然可能被再次使用（具体能否使用取决于实现）。\n结束了？ # 有这两个构造函数就足够了吗？当然没有。事实上还有另一种广泛使用的操作，可以把它叫做 relocate 操作。考虑如下场景\n假设你正在实现一个vector，扩容是必要的，于是你写了一个私有成员函数grow用来进行扩容（下面的代码示例暂时忽略异常安全）\nvoid grow(std::size_t new_capacity) { auto new_data = malloc(new_capacity * sizeof(T)); for (std::size_t i = 0; i \u0026lt; m_Size; ++i) { new (new_data + i) T(std::move(m_Data[i])); m_Data[i].~T(); } free(m_Data); m_Data = new_data; m_Capacity = new_capacity; } 上面的代码很简单，先通过malloc分配新的内存，然后通过 placement new 在新分配的内存上调用移动构造进行初始化。注意，正如前文提到的： C++ 中的 move 是 non-destructive 的，所以需要在调用完移动构造之后，原对象还需要调用析构函数，来正确的结束生存期。最后释放原来的内存，更新成员变量的值就行了。\n注：构造和析构的步骤也可以采用 C++20 加入的 std::construct_at 和 std::destroy_at，其实就是对 placement new 和 destroy 的封装。\n但是这样的实现并不高效，在 C++ 中有一个 trivially copyable 的概念，可以通过is_trivially_copyable这个 triat 来进行判断。满足这个约束的类型，可以直接使用memcpy或者memmove来进行拷贝得到一个新的对象。考虑下面这个例子：\nstruct Point { int x; int y; }; static_assert(std::is_trivially_copyable_v\u0026lt;Point\u0026gt;); Point points[3] = {{1, 2}, {3, 4}, {5, 6}}; Point new_points[3]; std::memcpy(new_points, points, sizeof(points)); 不仅仅省去了多次函数调用，而且memcpy和memmove本身就是高度优化的 builtin 函数（可以通过 SIMD 进行向量化）。所以效率相比于直接调用拷贝构造进行复制效率会高很多。\n为了让我们的vector更快，我们也可以做一下这种优化，利用 C++17 加入的if constexpr来做编译期判断，很轻松的写出下面的代码\nvoid grow(std::size_t new_capacity) { auto new_data = malloc(new_capacity * sizeof(T)); if constexpr (std::is_trivially_copyable_v\u0026lt;T\u0026gt;) { std::memcpy(new_data, m_Data, m_Size * sizeof(T)); } else if constexpr (std::is_move_constructible_v\u0026lt;T\u0026gt;) { for (std::size_t i = 0; i \u0026lt; m_Size; ++i) { std::construct_at(new_data + i, std::move(m_Data[i])); std::destroy_at(m_Data + i); } } else if constexpr (std::is_copy_constructible_v\u0026lt;T\u0026gt;) { for (std::size_t i = 0; i \u0026lt; m_Size; ++i) { std::construct_at(new_data + i, m_Data[i]); std::destroy_at(m_Data + i); } } free(m_Data); m_Data = new_data; m_Capacity = new_capacity; } *注：也可以考虑直接使用 C++17 加入的 uninitialized_move_n 和 destroy_n 避免重新造轮子，这些函数已经进行过类似的优化了。不过由于指针 alisa 的问题，它们可能最多优化成memmove，而在这个vector扩容的场景，可以进一步优化成memcpy，所以还是自己优化效果更好。 *\n大材小用 # 这样总感觉怪怪的，我们主要的目的是把就旧内存上的对象全部移动到新内存上，但是用的居然是 trivially copyable 这个 trait，似乎约束过强了。完全创建一个新对象和把原来的对象放置到新的位置，感觉差别还挺大的。考虑下面这个例子。似乎直接对std::string这样的类型进行memcpy也是可以的。由于内存都是我们手动管理，析构函数也是我们手动调用，并不会出现多次调用析构函数的情况\nstd::byte buffer[sizeof(std::string)]; auto\u0026amp; str1 = *std::construct_at((std::string*) buffer, \u0026#34;hello world\u0026#34;); std::byte new_buffer[sizeof(std::string)]; std::memcpy(new_buffer, buffer, sizeof(std::string)); auto\u0026amp; str2 = *(std::string*) new_buffer; str2.~basic_string(); 仔细思考一下数据的流向和析构函数的调用，发现没有任何不妥。似乎我们应该寻找一种叫做 trivially moveable 的概念，用来放宽松条件，从而使更多的类型得到优化。很可惜，目前 C++ 标准中并没有这样的概念。为了和 C++ 已经存在的 move 操作区分开来，我们把这种操作叫做 relocate，即把原本的对象放置在一个全新的位置。\n事实上有很多著名的开源组件也都通过模板特化来实现了类似的功能，例如\nBSL 的bslmf::IsBitwiseMoveable\u0026lt;T\u0026gt; Folly 的folly::IsRelocatable\u0026lt;T\u0026gt; QT 的QTypeInfo\u0026lt;T\u0026gt;::isRelocatable 通过对特定的类型进行标记，使得它们可以拥有这种优化。但是，上面的优化只是在我们逻辑上认为相等，严格来说目前这样写在 C++ 中算是 undefined behavior。那怎么办？只能想办法通过新提案，修改标准措辞，来支持上面的优化。\n现状 # 首先这个问题早就被发现了，例如知乎上很久之前就有相关的讨论：\n比起 malloc new / free old，realloc 在性能上有多少的优势? C++ vector 的 push_back 扩容机制为什么不考虑在尾元素后面的空间申请内存? 类似的问题还有挺多的。realloc会尝试在原地扩容，如果失败。就会尝试分配一块新的内存，然后用memcpy把原来的数据拷贝到新的内存上。所以在目前的 C++ 标准中，如果你想要直接使用realloc进行扩容的话，必须要保证对象是 trivially copyable 的。当然，前面已经说了，这个条件是比较苛刻的，需要引入新的概念来放宽条件。\n相关的提案最早在 2015 年就被提出了，在 2023 年仍然活跃的提案主要有下面四个（目标都是 C++26）：\nstd::is_trivially_relocatable Trivial Relocatability For C++26 Relocating prvalues Nontrivial Relocation via a New owning reference Type 大概可以分为两派，保守派和激进派\n保守派 # 保守派的解决方案是添加 relocatable 和 trivally-relocatable 的概念，以及用来判断的相关 trait。\n如果一个类型是 move-constructible 且 destructible 的，那么它就是 relocatable 的\n如果一个类型满足下列条件之一，那么它就是 trivally-relocatable 的\n是一个 trivially-copyable 的类型 是一个 trivally-relocatable 类型的数组 是一个用具有值为 true 的trivially_relocatable属性声明的类类型 是一个类类型，满足以下条件： 没有用户提供的移动构造函数或移动赋值运算符 没有用户提供的复制构造函数或复制赋值运算符 没有用户提供的析构函数 没有虚拟成员函数 没有虚基类 每个成员都是引用或者 trivally-relocatable 类型，并且所有基类都是 trivally-relocatable 类型 可以通过新的 attribute ——trivially_relocatable 来显式标记一个类型为 trivally-relocatable，它可以用常量表达式作为参数，来支持泛型类型\ntemplate\u0026lt;typename T\u0026gt; struct [[trivially_relocatable(std::std::is_trivially_relocatable_v\u0026lt;T\u0026gt;)]] X { T t; }; 还增加了一些新的操作：\ntemplate\u0026lt;class T\u0026gt; T *relocate_at(T* source, T* dest); template\u0026lt;class T\u0026gt; [[nodiscard]] remove_cv_t\u0026lt;T\u0026gt; relocate(T* source); // ... template\u0026lt;class InputIterator, class Size, class NoThrowForwardIterator\u0026gt; auto uninitialized_relocate_n(InputIterator first, Size n, NoThrowForwardIterator result); 这些函数都是由编译器实现的，效果上等同于 move + destroy 原对象。并且允许编译器在满足 as-if 规则的前提下，把对 trivially_relocatable 的类型的操作优化成memcpy或者memmove。对于那些不能优化的结构，比如含有自引用的结构，就正常调用移动构造 + 析构函数就行了。这样在实现vector的时候，直接使用这些标准库提供的函数就可以享受优化了。\n该提案之所以被称作保守派，最大的原因就是它既不影响原来的 API，也不影响原来的 ABI，具有较强的兼容性，引入进来十分方便。\n激进派 # 更为激进的就是今天的主角了，它主张引入 relocate constructor，并且引入了新的关键字reloc\nreloc是一个一员运算符，可以用于函数非静态局部变量，reloc用于执行如下操作\n如果变量是引用类型，则进行完美转发 如果不是则把源对象变成纯右值并返回 并且被reloc过后的对象，如果再次使用被认为是编译错误（实际判定的规则会更加详细，详见提案里面的相关小节）\n然后引入了一个新的构造函数，即 relocate constructor（重定位构造函数），具有如下形式T(T)，函数参数是T类型的纯右值。选择这个作为函数签名是为了完善 C++ value category 体系。目前（C++17）及以后，C++ 的拷贝构造函数从 lvalue 创建对象，移动构造函数从 xvalue 创建对象，而重定位构造函数则是从 prvalue 创建对象。这样就完整的覆盖了所有的 value category，对于重载决议来说是十分友好的，语义上也十分和谐融洽。\nstruct X { std::string s; X(X x): s(std::move(x.s)) {} } 另外一个好处是，目前这种T(T)声明的构造函数是不允许的，所以不会和现有的代码冲突。有一点需要注意，相信之前大家可能听人这样解释过，为什么拷贝构造函数的参数必须是引用？因为如果不是引用的话，函数传参也需要拷贝，就会导致无限递归。\n事实上这种解释已经过时了，由于 C++17 引入的强制性的 copy elision。即使一个类型没有拷贝构造函数和移动构造函数，它也可以直接从纯右值构造，并且没有任何拷贝/移动构造函数的调用\nstruct X { X() = default; X(const X\u0026amp;) = delete; X(X\u0026amp;\u0026amp;) = delete; }; X f(){ return X{}; }; X x = f(); 上述的代码在开启 C++17 之后各大编译器都能编译通过。所以这里T(T)的这种构造函数的形式并不会导致无限递归。该提案也引入了重定位赋值函数，具有如下形式T\u0026amp; operator=(T)，函数参数是T类型的纯右值。当然，也还有 trivially-relocatable 的概念，允许满足这个条件的重定位构造函数被优化为memcpy。但是，这是通过重定位构造函数等规则来进行判断的，用户不能显式通过 attribute 进行标记。我觉得这一点并不好，应该允许用户手动标记一个类型为 trivially-relocatable。tuple就是由于目前的实现限制，必须要写一个构造函数，从而导致永远不能是 trivially-copyable 的了，pair 居然也不是 trivially-copyable 的，显然这不合理。所以希望该提案以后能支持通过 attribute 来标记一个类型为 trivially-relocatable。\n我个人是比较喜欢这个提案的，有了它以后，我甚至感觉 C++ 的 value category 系统能够和优雅挂钩了。在这之前，我一直觉得 value category 这个系统是混乱邪恶的，是为了兼容以前的旧代码打的烂补丁。但是如果该提案通过以后\n左值 —— 拷贝构造 亡值 —— 移动构造 纯右值 —— 重定位构造 有一种逻辑完全自洽的美感。提案中其它的细节，就比较琐碎了，这里就省略了。感兴趣的读者可以自己阅读。\n为什么过多这么久还没进入标准 # 关于为什么过了这么多年这个问题仍然没有解决，其实这是一段相当长的历史，是 C++ 的对象模型存在缺陷导致的。直到 C++20 的 隐式生存期提案 被接受之前，在最开始的扩容函数实现中，连把 trivially-copyable 的类型优化为 memcpy 都是 undefined behavior。\n当然，不要听到 undefined behavior 就害怕，觉得心里面有道坎一样。事实上这一直被认为是标准的缺陷，这种优化早已经广泛实践各大代码库之中了，可靠性已经得到验证。只是 C++ 标准一直没有合适的措辞来描述这种情况，完全认为是 UB 肯定是不对的，不加限制的使用也是不对的，所以问题的关键就是如何在这两者之间如何找出一个合适的边界了。最近我会专门写一篇文章来介绍 C++ 对象模型相关的内容，这里就不展开了。\n其它语言 # C++ 固然有各种不足，考虑到历史兼容性等因素，导致设计放不开手脚。那新语言呢？它们是如何解决这些问题的？\nRust # 首先先看最近比较火热的 Rust。其实，只要结构中不含有自引用的成员，那么使用memcpy把旧的对象移动到新的内存上，几乎总是可行的。另外，Rust 并没有什么多继承虚函数（虚表结构复杂）啦，虚继承啦，这种比较奇怪的东西（并且实际用到的地方很少），所以几乎所有的类型都可以直接使用memcpy来从旧对象创建一个新对象。刚好 Safe Rust 中的 move 语义还是 destructive move，所以它的 move 的默认实现就是直接memcpy，是清爽很多。\n但是默认的移动只能移动局部非静态变量，如果一个变量是引用，那么你就没法移动它。不过还好 Safe Rust 提供了一个 std::mem::take 函数用来解决这个问题：\nuse std::mem; let mut v: Vec\u0026lt;i32\u0026gt; = vec![1, 2]; let old_v = mem::take(\u0026amp;mut v); assert_eq!(vec![1, 2], old_v); assert!(v.is_empty()); 效果是，移动 + 原对象置空，比较类似于 C++ 中的 move。还有 std::mem::swap 和 std::mem::replace 用于其它需要从引用处进行移动的场景。\n虽然可能情况不多，但是如果一个类型含有自引用的结构怎么办？事实上，允许用户自定义构造函数是一个比较简单的解决办法，但是 Rust 社区对此似乎比较反感。目前的解决方案是通过 Pin，不过 Rust 社区似乎对这个解决方案也不是很满意，它很难理解且很难使用。未来全新的设计应该和 linear type 有关，相关的讨论详见 Changing the rules of Rust。\nMojo # 这个语言前些日子也在知乎上也宣传过一波，但是目前还处于完全早期的状态，不过一开始人家就考虑提供四种构造函数\n__init__() __copy__() __move__() __take__() 其中 copy 就类似于 拷贝构造函数，move 类似于重定位构造函数，take 则类似于现在的移动构造函数。更多的细节就无从得知了。\n","date":"January 25, 2024","externalUrl":null,"permalink":"/articles/679782886/","section":"Articles","summary":"众所周知，现在 C++ 里面有两种特殊的构造函数，即 copy constructor 和 move constructor copy constructor 早","title":"全新的构造函数，C++ 中的 relocate 构造函数","type":"articles"},{"content":" 引子 # 在C++17中引入了叫做「结构化绑定」的特性也就是Struct Bind，这一特性类似于别的语言中的模式匹配，可以让我们方便的对结构体的成员进行访问\nstruct Point { int x; int y; }; Point p = {1, 2}; auto [x, y] = p; // x = 1, y = 2 利用它我们能实现一些有趣的功能，包括有限的 对结构体的反射功能，比如实现一个for_each函数\nvoid for_each(auto\u0026amp;\u0026amp; object, auto\u0026amp;\u0026amp; func) { using T = std::remove_cvref_t\u0026lt;decltype(object)\u0026gt;; if constexpr (std::is_aggregate_v\u0026lt;T\u0026gt;) { auto\u0026amp;\u0026amp; [x, y] = object; for_each(x, func); for_each(y, func); } else { func(object); } } 这样的话对于任意的含有两个成员的聚合类型，我们都可以对其进行遍历\nstruct Point { int x; int y; }; struct Line { Point start; Point end; }; Line line = {{ 1, 2 }, { 3, 4 }}; for_each(line, [](auto\u0026amp;\u0026amp; object) { std::cout \u0026lt;\u0026lt; object \u0026lt;\u0026lt; std::endl; // 1 2 3 4 }); 但是这样有一个问题那就是，只能递归的支持结构体字段数量为2的情况，如果你尝试填入一个字段数量为3的结构体，那么编译器就会抛出一个hard error。即结构化绑定数量错误，它不能被SFINAE或者requires处理，会直接导致编译中止\nstruct Vec3 { float x; float y; float z; }; // 里面是个 lambda constexpr auto value = requires{ [](){ auto [x, y] = Vec3{ 1, 2, 3 }; }; }; // hard error 我们可以通过手动分发的方式来解决这个问题\nif constexpr(N == 1) { auto\u0026amp;\u0026amp; [x] = object; // ... } else if constexpr(N == 2) { auto\u0026amp;\u0026amp; [x, y] = object; // ... } else if constexpr(N == 3) { auto\u0026amp;\u0026amp; [x, y, z] = object; // ... } // ... 你可以自由枚举到你想要支持的数量，这里面的N就是结构体字段数量了，你可能需要把它作为模板参数显式传入，或者给每个类型都特化一个模板，里面存上它的字段数量。但是这仍然很麻烦，那么有没有一种方法可以让编译器自动的帮我们计算出结构体的字段数量呢？\n第一棒 Antony Polukhin # 初步解决方案在 boost/pfr 中就已经给出了，其作者 Antony Polukhin 在 CppCon2016 和 CppCon2018 中对此做了详细的介绍，不过作者采用的版本是C++14/17，其中的代码较为晦涩难懂，在我使用C++20进行重写之后可读性提高了不少。\n首先在C++中我们可以写一个Any类型，它支持向任意类型进行转换，其实就是把它的 类型转换函数 写成模板函数就行了\nstruct Any { constexpr Any(int){}; // 支持从 int 构造 template\u0026lt;typename T\u0026gt; constexpr operator T() const; }; static_assert(std::is_convertible_v\u0026lt;Any, int\u0026gt;); // true static_assert(std::is_convertible_v\u0026lt;Any, std::string\u0026gt;); // true 之后我们可以利用聚合初始化的特性，那就是对于超出聚合初始化最大数量的表达式，requires语句会返回false\nstruct Point { int x; int y; }; template\u0026lt;typename T, std::size_t N\u0026gt; constexpr auto test() { // 利用 make_index_sequence 构造 N 个参数 return []\u0026lt;std::size_t... I\u0026gt;(std::index_sequence\u0026lt;I...\u0026gt;) { return requires{ T{ Any(I)... }; }; }(std::make_index_sequence\u0026lt;N\u0026gt;{}); } static_assert(test\u0026lt;Point, 0\u0026gt;()); // true static_assert(test\u0026lt;Point, 1\u0026gt;()); // true static_assert(test\u0026lt;Point, 2\u0026gt;()); // true static_assert(!test\u0026lt;Point, 3\u0026gt;()); // false 注意到这里Point只有两个成员，当我们传入了三个参数给初始化列表的时候，requires就会返回false。利用这个特性，我们可以把上面的尝试过程改成递归的，也就是线性查找这个序列直到找到false为止。\ntemplate\u0026lt;typename T, int N = 0\u0026gt; constexpr auto member_count() { if constexpr(!test\u0026lt;T, N\u0026gt;()) { return N - 1; } else { return member_count\u0026lt;T, N + 1\u0026gt;(); } } 如果test\u0026lt;T, N\u0026gt;为真说明N个参数可以成功构造T，那么我们就递归的尝试N + 1个参数，直到test\u0026lt;T, N\u0026gt;为假，那么N - 1就是T的成员数量了。这样我们就可以通过member_count\u0026lt;T\u0026gt;()来获取T的成员数量了。测试一下效果\nstruct A{ std::string a; }; static_assert(member_count\u0026lt;A\u0026gt;() == 1); struct B{ std::string a; int b; }; static_assert(member_count\u0026lt;B\u0026gt;() == 2); 很好啊，大获成功！事情到这里就结束了吗？\n第二棒 João Baptista # 考虑下面这三个例子\n左值引用 struct A{ int\u0026amp; x; }; static_assert(member_count\u0026lt;A\u0026gt;() == 1); // error 默认构造函数被删除 struct X { X() = delete; } // 默认构造函数被删除 struct B{ X x; X y; }; static_assert(member_count\u0026lt;B\u0026gt;() == 2); // error 数组 struct C { int x[2]; }; static_assert(member_count\u0026lt;C\u0026gt;() == 1); // error 遇到这三种情况，原来的方法完全失效了，为什么会这样？\n这一小节的主要内容参考自 João Baptista 的两篇博客\nCounting the number of fields in an aggregate in C++20 Counting the number of fields in an aggregate in C++20 — part 2 他总结了boost/pfr中的问题，并提出了解决方案，解决了上述提到的三个问题\n左值引用的问题 # 第一个问题相对比较好理解，主要就是因为T()类型产生的转换产生的都是纯右值，左值引用没法绑定到纯右值，如果是右值引用就可以了\nstatic_assert(!std::is_constructible_v\u0026lt;int\u0026amp;, Any\u0026gt;); // false static_assert(std::is_constructible_v\u0026lt;int\u0026amp;\u0026amp;, Any\u0026gt;); // true 怎么办呢？其实有一种很巧妙的写法，可以解决这个问题\nstruct Any { constexpr Any(int) {}; // 支持从 int 构造 template\u0026lt;typename T\u0026gt; constexpr operator T\u0026amp;() const; template\u0026lt;typename T\u0026gt; constexpr operator T\u0026amp;\u0026amp;() const; }; 一个转换成左值引用，一个转换成右值引用。如果它们俩只有一个能匹配，那就会选择那一个能匹配的。如果两个都能匹配，左值引用转换的优先级比右值引用高，会被优先选择，不会有重载决议的问题。\nstatic_assert(std::is_constructible_v\u0026lt;int, Any\u0026gt;); // true static_assert(std::is_constructible_v\u0026lt;int\u0026amp;, Any\u0026gt;); // true static_assert(std::is_constructible_v\u0026lt;int\u0026amp;\u0026amp;, Any\u0026gt;); // true static_assert(std::is_constructible_v\u0026lt;const int\u0026amp;, Any\u0026gt;); // true 很好，这样的话第一个问题，解决！\n默认构造函数的问题 # 为什么把默认构造函数删了就不行了呢？还记得我们最开始的那个Point类型吗？\nstruct Point{ int x; int y; }; 我们尝试的结果是0,1,2都可以，3不行。可是，如果说，{ }里面的数量多于Point的成员数量导致失败我能理解，为啥少于里面的成员数量可以成功呢？其实原因很简单，那就是你没有显式初始化的成员会被值初始化。于是{ }里面的参数，可以少于实际的字段数量。但是如果字段禁止了默认构造函数，就没法进行值初始化，就会编译错误\nstruct X { X() = delete; } // 默认构造函数被删除 struct B { X x; X y; int z; }; 对于下面这个类型，我们如果用Any尝试的话，应该是0,1不行,2,3可以,4,5,...以及往后的都不行。也就是说至少要让所有不能默认初始化的成员都初始化之后才行。 如果一个类型支持默认初始化，那么搜索它的有效区间是[0, N]其中N就是它的最大字段数量。如果不支持默认初始化，那其实搜索区间就变成了[M, N]，M是保证其不能默认初始化的成员全都初始化的最小数量。\n我们之前的搜索策略是从0开始搜索，如果当前这个是true，那就求下一个，直到false停止。显然这种搜索策略不适合现在这种情况了，因为在[0, M)之间，也符合之前的搜索策略搜索失败的情况。我们现在要改成，如果当前这个是ture并且下一个是false才停止搜索，这样刚好能搜到这个区间的上界。\ntemplate\u0026lt;typename T, int N = 0\u0026gt; constexpr auto member_count() { if constexpr(test\u0026lt;T, N\u0026gt;() \u0026amp;\u0026amp; !test\u0026lt;T, N + 1\u0026gt;()) { return N; } else { return member_count\u0026lt;T, N + 1\u0026gt;(); } } 测试一下\nstruct A{ int\u0026amp; x; }; static_assert(member_count\u0026lt;A\u0026gt;() == 1); struct X { X() = delete; }; // 默认构造函数被删除 struct B{ X x; X y; }; static_assert(member_count\u0026lt;B\u0026gt;() == 2); OK，第二个问题也解决了，实在是太酷了！\n数组的问题 # 如果在结构体的成员里面有数组，那么计算的时候最终得到的结果就是把数组的每一个成员都当成一个字段来计算，其实就是因为对标准数组的聚合初始化开了后门\nstruct Array { int x[2]; }; Array{ 1, 2 }; // OK 注意到没有，只有一个字段却可以填两个值。但是对数组开洞就导致了这样的困境，如果结构体里面含有数组就会最终得到错误的计数。那有没有什么办法能解决这个问题？\n注意：下面这部分可能有点难以理解\n考虑下面这个例子\nstruct D { int x; int y[2]; int z[2]; } 举例子，来看一下它初始化的情况：\nD{ 1, 2, 3, 4, 5 } // OK // 第 0 个位置 D{ {1}, 2, 3, 4, 5 } // OK, 0号位置最多放置 1 个元素 D{ {1, 2}, 3, 4, 5 } // Error // 第 1 个位置 D{ 1, {2}, 3, 4, 5 } // Error D{ 1, {2, 3}, 4, 5 } // OK, 1号位置最多放置 2 个元素 D{ 1, {2, 3, 4}, 5 } // Error // 第 3 个位置 D{ 1, 2, 3, {4}, 5} // Error D{ 1, 2, 3, {4, 5} } // OK, 3号位置最多放置 2 个元素 没错，我们可以利用嵌套初始化，来解决这个问题！我们先用原本的方法求出最大的可能的结构体字段数量（包含数组展开的，这里就是5个），然后再在每个位置尝试把原本的序列塞到这个嵌套初始化里面去，通过不停尝试就能找到这个位置所能放置的元素的最大数量，如果最大数量超过1的话，说明这个位置是个数组。这个最大数量就是数组的元素数量，我们在最后的结果中，把多余数量减掉就行了。\n听起来简单，实现起来还是有点复杂的哦。\n先写一个函数用来辅助，通过填不同的N1,N2,N3就能对应到上面不同情况了，注意I2那里的Any那里是嵌套初始化，多了一层括号\ntemplate\u0026lt;typename T, std::size_t N1, std::size_t N2, std::size_t N3\u0026gt; constexpr bool test_three_parts() { return []\u0026lt;std::size_t... I1, std::size_t... I2, std::size_t... I3\u0026gt; (std::index_sequence\u0026lt;I1...\u0026gt;, std::index_sequence\u0026lt;I2...\u0026gt;, std::index_sequence\u0026lt;I3...\u0026gt;) { return requires{ T{ Any(I1)..., { Any(I2)... }, Any(I3)... }; }; }(std::make_index_sequence\u0026lt;N1\u0026gt;{}, std::make_index_sequence\u0026lt;N2\u0026gt;{}, std::make_index_sequence\u0026lt;N3\u0026gt;{}); } 接下来我们要写一个函数，用来测试在指定位置用二层{ } 放置N个元素是不是可行的\ntemplate \u0026lt;typename T, std::size_t position, std::size_t N\u0026gt; constexpr bool try_place_n_in_pos() { constexpr auto Total = member_count\u0026lt;T\u0026gt;(); // 可能的最大字段数量 if constexpr (N == 0) // 放置 0 个和原本的效果是一样的肯定可行 { return true; } else if constexpr (position + N \u0026lt;= Total) // 元素数量之和的肯定不能超过总共的 { return test_three_parts\u0026lt;T, position, N, Total - position - N\u0026gt;(); } else { return false; } } 由于内容有点多，可能有点难以理解，我们这里先展示一下这个函数的测试结果，方便理解，这样如果你看不懂函数实现也没问题。 还是以之前那个结构体D为例子\ntry_place_n_in_pos\u0026lt;D, 0, 1\u0026gt;(); // 这其实就是在测试 D{ {1}, 2, 3, 4, 5 } 这种情况 // 在 0 号位置放置 1个元素 try_place_n_in_pos\u0026lt;D, 1, 2\u0026gt;(); // 这其实就是在测试 D{ 1, {2, 3}, 4, 5 } 这种情况 // 在 1 号位置放置 2 个元素 好了，看懂这个函数是在做什么事情就行了，在某一个位置不停地尝试就行了，然后就能找到这个位置能放置的最大的元素数量了。\ntemplate\u0026lt;typename T, std::size_t pos, std::size_t N = 0\u0026gt; constexpr auto search_max_in_pos() { constexpr auto Total = member_count\u0026lt;T\u0026gt;(); std::size_t result = 0; [\u0026amp;]\u0026lt;std::size_t... Is\u0026gt;(std::index_sequence\u0026lt;Is...\u0026gt;) { ((try_place_n_in_pos\u0026lt;T, pos, Is\u0026gt;() ? result = Is : 0), ...); }(std::make_index_sequence\u0026lt;Total + 1\u0026gt;()); return result; } 这里就是在这个位置搜索能放置的元素最大数量\nstatic_assert(search_max_in_pos\u0026lt;D, 0\u0026gt;() == 1); // 1, 0号位置最多放置 1 个元素 static_assert(search_max_in_pos\u0026lt;D, 1\u0026gt;() == 2); // 2, 1号位置最多放置 2 个元素 static_assert(search_max_in_pos\u0026lt;D, 3\u0026gt;() == 2); // 2, 3号位置最多放置 2 个元素 这与我们最开始的手动测试结果一致，接下来就是遍历所有位置，找出所有的额外的数组元素数量，然后从一开始的那个最大数量里面减掉这些多余的就行了。\ntemplate \u0026lt;typename T, std::size_t N = 0\u0026gt; constexpr auto search_all_extra_index(auto\u0026amp;\u0026amp; array) { constexpr auto total = member_count\u0026lt;T\u0026gt;(); constexpr auto num = search_max_in_pos\u0026lt;T, N\u0026gt;(); constexpr auto value = num \u0026gt; 1 ? num : 1; array[N] = value; if constexpr (N + value \u0026lt; total) { search_all_extra_index\u0026lt;T, N + value\u0026gt;(array); } } 这里就是递归的找，结果储存在数组里面。注意这里N + value，如果这里找到两个元素了，我们可以直接往后挑两个位置。例如1号位置可以放置2个元素，那我直接找3号位置就行了，不用找2号位置了。\n接下来就是把结果都存到数组里面然后，把多余的减掉就行了。\ntemplate\u0026lt;typename T\u0026gt; constexpr auto true_member_count() { constexpr auto Total = member_count\u0026lt;T\u0026gt;(); if constexpr (Total == 0) { return 0; } else { std::array\u0026lt;std::size_t, Total\u0026gt; indices = { 1 }; search_all_extra_index\u0026lt;T\u0026gt;(indices); std::size_t result = Total; std::size_t index = 0; while (index \u0026lt; Total) { auto n = indices[index]; result -= n - 1; index += n; } return result; } } 测试一下结果\nstruct D { int x; int y[2]; int z[2]; }; static_assert(true_member_count\u0026lt;D\u0026gt;() == 3); struct E { int\u0026amp; x; int y[2][2]; int z[2]; int\u0026amp;\u0026amp; w; }; static_assert(true_member_count\u0026lt;E\u0026gt;() == 4); 拿这里的E类型最后生成的数组举一下例子吧，可以都print出来看看\nindex: 0 num: 1 // 0 号位置对应 x， 数量是 1 合理 index: 1 num: 4 // 1 号位置对应 y， 数量是 4 合理 index: 5 num: 2 // 5 号位置对应 z， 数量是 2 合理 index: 7 num: 1 // 7 号位置对应 w， 数量是 1 合理 完美谢幕！我很佩服这个作者的想法，真的是太巧妙了，让人叹为观止。然而，在文章的末尾他却说道，\nAs it could be seen, I ran into some inconsistencies between gcc and clang (and for some reason I haven’t managed to make it work on MSVC at all, but that is another story).\n他说，他遇到了clang和gcc的行为不一致的情况，而且完全没法让这种方法在msvc上工作。\n看来事情远远没有结束！\n第三棒 YKIKO # 我花了一些时间读懂了刚才这位作者的文章，说实话他的模板写的我很难读懂，他不喜欢用if constexpr来做分支选择，用了很多特化来做选择，给可读性造成了很大影响。所以刚才那些代码并不完全是原作者中的代码，是我用我认为的，更好阅读的形式进行转译的。\n哪些情况会break第二位作者的代码呢？\n移动构造被删除 struct X { X(X\u0026amp;\u0026amp;) = delete; }; struct F{ X x; }; static_assert(true_member_count\u0026lt;F\u0026gt;() == 1); // error 结构体中含有其它结构体成员 struct Y{ int x; int y; }; struct G{ Y x; int y; }; static_assert(true_member_count\u0026lt;G\u0026gt;() == 2); // error MSVC的bug和GCC的bug 移动构造被删除的问题 # 这一切都源于C++17加入的一条新规则，是关于 copy elision 的。\nSince C++17, a prvalue is not materialized until needed, and then it is constructed directly into the storage of its final destination. This sometimes means that even when the language syntax visually suggests a copy/move (e.g. copy initialization), no copy/move is performed — which means the type need not have an accessible copy/move constructor at all.\n什么意思呢，举例子说明最清晰\nstruct M { M() = default; M(M\u0026amp;\u0026amp;) = delete; }; M m1 = M(); // ok in C++17, error in C++14 M m2 = std::move(M()); // error 啊？为什么会这样，第一个可以编译通过，第二个不行，难道我写std::move还多余了吗？\n其实第二个编译不通过的原因是很好理解的，因为移动构造函数被删除了，所以没法调用移动构造函数了，于是就编译失败了。注意到第一种情况在C++14和C++17中的行为是不一样的，C++14是先产生临时对象，然后调用移动构造函数，初始化m1，但是这样的行为其实是多余的，所以编译器可能会优化掉这步多余的步骤。但是这里还是有调用移动构造函数的可能性，所以删除构造函数了就GG了，编译失败。到了C++17这个优化直接变成语言强制性的要求了，所以完全没有移动构造这一步了，自然也不需要可访问的构造函数了，所以在C++17可以编译通过。\n这也就意味着，右值之间亦有差距。prvalue即纯右值可以直接复制消除构造对象（比如这里的非引用类型的函数返回值就是纯右值），但是xvalue也即亡值必须得有可调用的移动构造函数才行，也不行进行复制消除（右值引用类型的函数返回值就是亡值）。所以这里std::move反倒起了负面效果。\n回到我们的问题，注意到Any有一个转化成右值引用类型的转换函数，所以如果遇到了这种情况就没办法了。但是再次通过巧妙地修改，又能解决这个问题：\nstruct Any { constexpr Any(int) {} template\u0026lt;typename T\u0026gt; requires std::is_copy_constructible_v\u0026lt;T\u0026gt; operator T\u0026amp;(); template\u0026lt;typename T\u0026gt; requires std::is_move_constructible_v\u0026lt;T\u0026gt; operator T\u0026amp;\u0026amp;(); template\u0026lt;typename T\u0026gt; requires(!std::is_copy_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; !std::is_move_constructible_v\u0026lt;T\u0026gt;) operator T(); }; 注意到我们这里对类型做了约束，如果是不可移动的类型（移动构造被删除），那就对应到了最后一个类型转换函数。直接产生prvalue构造对象，这样就巧妙地解决了这个问题了。写拷贝构造的约束是为了防止重载决议歧义（同时在最后可以顺便修复MSVC的bug）。\n结构体中含有其它结构体成员 # 事实上作者原本的思路很好，但是忽略了一个问题，那就是不只有数组类型在可以使用二重{{ }}初始化，结构体也是可以的\nstruct A{ int x; int y; }; struct B{ A x; int y; }; B{ {1, 2}, 3 }; // ok 所以如果这个位置有是结构体成员的话，就会导致错误的计数。所以我们需要先判断一个下这个位置是不是结构体，如果是的话，就不用对这个位置尝试求最大放置数量了，直接去求下一个位置就行了\n那怎么判断当前位置成员是不是结构体呢？考虑下面这个例子\nstruct A{ int x; int y; }; struct B { A x; int y[2]; }; 手动枚举一下测试情况\nAny any(1); B{ any, any, any }; // ok B{ {any}, any, any }; // ok B{ {any, any}, any, any }; // ok B{ any, {any}, any }; // error B{ any, {any, any}, any }; // error OK其实答案很显然了，那就是如果当前位置是结构体的话，可以往这个位置额外添加元素。注意到原本的Total即最大可能的元素数量是3，但是如果当前位置是结构体的话，放4个元素也是可以，但是如果是数组就不行了。我们利用这个特性来判断当前位置的是不是结构体，如果是的话，就跳去下一个位置，如果不是就在这个位置搜索最大能放置的元素。\n其实就是在这个位置递归尝试放置元素，但是这里有一个问题是，当前位置的结构体成员中仍然可能含有不能默认初始化的成员。所以究竟放几个才能确定这个位置能被初始化呢？这还是不确定的，我这里设置的最大上线是10个，如果子结构体中不能默认初始化的成员位置在10之后的话这个方法就失败了。\ntemplate \u0026lt;typename T, std::size_t pos, std::size_t N = 0, std::size_t Max = 10\u0026gt; constexpr bool has_extra_elements() { constexpr auto Total = member_count\u0026lt;T\u0026gt;(); if constexpr (test_three_parts\u0026lt;T, pos, N, Total - pos - 1\u0026gt;()) { return false; } else if constexpr (N + 1 \u0026lt;= Max) { return has_extra_elements\u0026lt;T, pos, N + 1\u0026gt;(); } else { return true; } } 有了这个函数之后在把原来那个serach函数逻辑稍微改一下就行了\ntemplate\u0026lt;typename T, std::size_t pos, std::size_t N = 0\u0026gt; constexpr auto search_max_in_pos() { constexpr auto Total = member_count\u0026lt;T\u0026gt;(); if constexpr (!has_extra_elements\u0026lt;T, pos\u0026gt;()) { return 1; } else { // ... 原本的代码不变 } } 就是加一个分支判断，如果当前位置没有额外的元素就直接返回1，如果有的就去搜索（数组的）最大边界。这样的话就解决了原作者的代码中中的问题了\n仍然测试一下\nstruct Y{ int x; int y; }; struct G{ Y x; int y; }; static_assert(true_member_count\u0026lt;G\u0026gt;() == 2); // OK Nice！！！太好了。\nMSVC 的 bug 和 GCC 的 bug # 作者在原文中提到的GCC和MSVC的问题我也一并找出来了，MSVC目前有一个缺陷：\nstruct Any { template\u0026lt;typename T\u0026gt; // requires std::is_copy_constructible_v\u0026lt;T\u0026gt; operator T\u0026amp;() const; }; int main() { struct A { int x[2]; }; A a{ Any{} }; // 这里 Any 转化成 int(\u0026amp;)[2]类型了，即数组的引用 } 上述的代码可以正常编译，这意味着MSVC允许直接从数组的引用聚合初始化数组成员。但是这是C++标准所不允许的，这个Bug会导致在MSVC上对成员计数错误，解决办法其实很简单，前面我们已经顺便解决过这个问题了，只要把注释的那行加上就行了。因为数组是不可拷贝构造的类型，所以约束会把这个重载函数排除掉，这样就不会出现这个问题了。\nGCC 13也有一个严重的 缺陷，直接会导致ice，这个bug用下面几行代码就能复现出来：\nstruct Number { int x; operator int\u0026amp;(){ return x; } }; struct X { int\u0026amp; x; }; template\u0026lt;typename T\u0026gt; concept F = requires{ T{ { Number{} } }; }; int main() { static_assert(!F\u0026lt;X\u0026gt;); // internal compiler error } 这个显然是不应该导致ice的，而且只在GCC 13才有这个bug实在是很奇怪。测试代码在 godbolt 。clang没任何问题，但是GCC 13就直接内部编译器错误了。而GCC 12和clang的编译结果不一样...但是其实clang是对的。这也就是原作者文章里面说的clang和gcc不一致的地方。*注：后经评论区提醒，clang 15也会遇到类似的内部编译器错误。 *\n后记 # 后来又和评论区的各位讨论了一番，上面的处理仍然有些欠缺考虑。一个典型的例子是，当成员变量的构造函数是模板函数的时候就会出错，例如std::any，原因是不知道调用类型转换函数和模板构造函数中的哪一个（重载决议失败）\nstd::any any = Any(0); // conversion from \u0026#39;Any\u0026#39; to \u0026#39;std::any\u0026#39; is ambiguous // candidate: \u0026#39;Any::operator T\u0026amp;() [with T = std::any]\u0026#39; // candidate: \u0026#39;std::any::any(_Tp\u0026amp;\u0026amp;) 但是目前还没有一个完美的解决办法能解决这个问题，不能直接检测T能不能由Any构造来解决这个问题，这会涉及到递归的约束，最后导致无法求解，从而编译错误。这里用了一个比较取巧的办法\nstruct Any { constexpr Any(int) {} template \u0026lt;typename T\u0026gt; requires(std::is_copy_constructible_v\u0026lt;T\u0026gt;) operator T\u0026amp;(); template \u0026lt;typename T\u0026gt; requires(std::is_move_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; !std::is_copy_constructible_v\u0026lt;T\u0026gt;) operator T\u0026amp;\u0026amp;(); struct Empty{}; template \u0026lt;typename T\u0026gt; requires(!std::is_copy_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; !std::is_move_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; !std::is_constructible_v\u0026lt;T, Empty\u0026gt;) operator T(); }; 就是声明了一个空类，然后尝试用这个空类能不能转换成类型T，如果不行就能说明T的构造函数应该不是模板函数，于是类型转换可以生效。如果可以，则说明T的构造函数是模板函数，要排除这个类型转换函数。当然了，如果T的构造函数有一些奇怪的约束，比如直接把Empty排掉，但是接受Any。这样话还是会导致错误，但是这属于刻意为之了，正常情况下基本是不会遇到这个问题的，这个问题可以算是解决了\n除此之外还有一个和引用相关的问题，如果结构体中含有不可拷贝/复制类型的引用成员，那么也会失败，下面就拿左值引用举例子吧\nstruct CanNotCopy { CanNotCopy(const CanNotCopy\u0026amp;) = delete; }; struct X { CanNotCopy\u0026amp; x; }; X x{ Any(0) }; // error 这里T就会实例化成CanNotCopy类型。显然因为它不可拷贝，导致重载决议选到了operator T()上，然后实际产生的是右值没法绑定到左值引用，就编译错误了。那这个问题可能解决吗？非常困难。事实上，我们无法让下面两个表达式同时成立\nstruct X { CanNotCopy\u0026amp; x; }; struct Y { CanNotCopy x; }; X x{ Any(0) }; Y y{ Any(0) }; 在这两个聚合初始化里面，类型转换函数实例化的T都是CanNotCopy类型，但是如果想让x，y都良构，那么就意味对于同一个T要选择两个不同的重载函数，第一个选operator T\u0026amp;()，第二个选operator T()，但是这两个函数之间并没有哪个更优先，C++也没法对返回值进行重载，所以这是做不到的。一个可能的解决方案是写三种Any,分别转化成T\u0026amp;，T\u0026amp;\u0026amp;，T然后在每个位置使用这三种进行尝试，这样的话倒是可以解决这个问题，但是可能会导致模板实例化个数以3 ^ N次方的速度增长。这种实现比之前的遍历方式加起来开销都要大，所以这里我就不做展示了，理论可行，实践上会累跨编译器\n结语 # 本文的全部代码都在 Compiler Explorer - C++ 上，三大编译器均通过（gcc版本是12），有很多测试代码，如果你找到其它的concer case欢迎留言讨论\n好了，这篇文章到这里就结束了。如果你耐心看完了全文，相比你也是和我一样，喜欢这些好玩的东西。这种东西最有趣的地方就在于，利用C++暴露的一点点接口，去一步步扩展它，最后实现非常漂亮的接口出来。当然对于作者来说其实并不漂亮OvO。总之这种东西就像是游戏一样，是日常的消遣，没事给C++编译器找找bug，钻研这些犄角旮旯的特性，也是一份乐趣。如果非要谈实际价值，其实这种东西几乎不可能在实际的代码生产环境中使用。首先通过实例化大量模板来寻找结构体的字段数量，会大大拖慢编译速度，而且即使花费如此大的功夫，也只是实现了对聚合类型的遍历，还不支持其的非聚合类型。不仅副作用强，而且主要功能也不强。权衡一下考虑也是非常不值当了，对于这种需要类似反射的需求的时候，在C++加入静态反射之前（真正用上也许还得过十年！？），目前真正可行的自动化方案是采用代码生成来做这个事情。\n我也有相关的文章详细介绍了相关的原理，不依赖于这些奇淫巧技，真正可用于实际项目中的方案：\n写给 C++ 程序员的反射教程 https://www.ykiko.me/articles/669358870\n当然如果用这些功能仅仅是为了log，debug或者study的话，而不是用于任何核心的代码部分，又不想引入很重的依赖，那这些东西用一用也未尝不可。我专门写了一个C++20的库，把这些有用的奇淫巧技都合并起来了，方便进行log，debug之类的。目前还在更新中，欢迎star和报告问题呐\nmagic-cpp https://github.com/16bit-ykiko/magic-cpp\n","date":"December 25, 2023","externalUrl":null,"permalink":"/articles/674157958/","section":"Articles","summary":"引子 # 在C++17中引入了叫做「结构化绑定」的特性也就是St","title":"跨越 7 年的接力赛：获取 C++ 结构体字段数量","type":"articles"},{"content":"事情的起因是我最近在编写的一个库 magic cpp ，正在编写其中enum的相关部分。打算参考一下magic enum的相关实现，在翻 issue的时候翻到这么一个神奇的PR\n​pull request https://github.com/Neargye/magic_enum/pull/227\n我们都知道C++的constexpr/consteval函数可以在编译期执行，目前编译器对此的实现大概是内部实现了一个小型的解释器，用来直接执行代码。然而这个解释器具体是什么表现我们无从得知，但是这个 pr 的作者仅仅改了几行代码就让编译速度提升了不少。\n原代码\nchar const* str = name.data(); for (std::size_t i = name.size(); i \u0026gt; 0; --i) { if (!((name[i - 1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; name[i - 1] \u0026lt;= \u0026#39;9\u0026#39;) || (name[i - 1] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; name[i - 1] \u0026lt;= \u0026#39;z\u0026#39;) || (name[i - 1] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; name[i - 1] \u0026lt;= \u0026#39;Z\u0026#39;) ** 优化代码**\nchar const* str = name.data(); for (std::size_t i = name.size(); i \u0026gt; 0; --i) { char c = str[i - 1]; if (!((c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) || (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) || (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) 这两份代码唯一的区别在于第二份代码对数组的元素str[i - 1]做了一次缓存。如果编译器在编译期解释执行这个函数的时候不执行任何优化，那么第一种写法每次判断都得额外寻一次址，相比之下第二种做了缓存的效果明显会快很多。这也和作者的测试结果相符合，优化后的写法编译更快。\n作者还提到了，STL实现的许多容器有越界检测，但是在编译期这实际上是不必要的，编译期越界（读取未初始化的内存）的话会直接编译错误，例如下面这段代码\nconstexpr char f() { char a[3]; return a[0]; } constexpr auto c = f(); // compile error 直接编译错误，所以这些检测其实并没有任何实际的作用，反倒是无用的检查拖慢了constexpr函数的编译期执行速度，更好的办法是自己实现一份不带检查的编译期使用的数据结构。另外一个有关编译速度优化相关的PR是 这个 compile-time optimization · Issue #219\n实际上，如果对于运行期代码，编译器完全会把这两种代码优化成一种形式，我们是不用考虑这个问题的。但是这个PR的确表现出来一个问题，那就是C++编译器对于constexpr expression求值的效率问题，在以后C++引入静态反射之后，constexpr函数的使用会更加泛滥，如果编译器不能通过有效的手段加快它的执行速度，恐怕会更进一步加剧C++编译速度慢的问题。\n后来我在clang的社区提出了这个 问题 。他们回复表示，目前（即clang18以及之前），clang的constexpr expression的求值效率的确是有问题的，现在的tree evaluator效率低下，并且在将来会有有一个新的 Interpreter 来解决这个问题，现在在clang18中可以用-fexperimental-new-constant-interpreter来开启这个实验性的功能。\n这里有其主要贡献者 Timm Baeder 的两篇相关介绍文章：\nA new constant expression interpreter for Clang A new constant expression interpreter for Clang, Part 2 如果这个新的解释器被正式加入了，有关的情况应该会得到比较大的改善。但是在那之前如果你的项目中大量使用了常量求值相关的代码，可能需要你手动进行优化编译期求值的代码来换取更快的编译速度\n还剩下gcc和msvc的相关实现未调查，未完待续......\n","date":"December 23, 2023","externalUrl":null,"permalink":"/articles/673852429/","section":"Articles","summary":"事情的起因是我最近在编写的一个库 magic cpp ，正在编写其中enum的","title":"手动优化C++代码来加快编译速度？！","type":"articles"},{"content":" 静态与动态 # 静态类型和动态类型这两个词语相信大家都不陌生了，区分二者的关键在于类型检查的时机。什么意思呢？\n假设我们有如下的 C++ 代码\nstd::string s = \u0026#34;123\u0026#34;; int a = s + 1; 那我们知道，string是不能和int直接相加的，所以这里应该有一个 TypeError。C++ 在编译期检查类型错误，所以这段代码会触发一个 compile time error（编译时错误）。\n考虑对应的 Python 代码\ns = \u0026#34;123\u0026#34; a = s + 1 而 Python 则是在运行期检查错误，上述代码实际上会产生一个 runtime error（运行时错误）。\n有必要强调一下这里的编译期 compile time 和 runtime 指代的含义。这些词可能经常会见到，但是在不同的上下文中可以含义不太一样，在我们这里：\ncompile time：泛指将一种代码编译为目标代码的时候，这时候程序还没有运行起来\n对于 AOT 编译的语言，例如 C++，就是把 C++ 编译成机器码的过程 对于 JIT 编译的语言，例如如 C#/Java，一般是指把源码编译成 IR 的过程\n对于转译语言来说，例如 TypeScript，则是把 TypeScript 编译成 JavaScript 的过程\nruntime：泛指程序实际运行的时候，比如机器码在 CPU 上执行的时候，或者字节码在虚拟机上执行的时候\n因此 C++，Java，C#，TypeScript 被称作静态类型的语言。而 Python 虽然也有把源码编译到字节码这个阶段，但是这个阶段不进行类型检查，所以 Python 被称作动态类型的语言。\n然而这并不绝对，静态语言和动态语言之间的界限并没有那么清晰，虽然 C++，Java，C#，TypeScript 是静态类型的语言，但是都提供了若干方法来绕过静态类型检查，比如 C++ 的pointer，Java/C# 的Object， TypeScript 的Any。而动态类型语言也逐渐在引入静态类型检查，比如 Python 的type hint，JavaScript 的TypeScript等等，二者都在相互借鉴对方的特性。\n目前 C++ 只提供了std::any来进行类型擦除，但是很多时候它不够灵活。我们想要一些更加高级的功能，比如通过字段名访问成员，通过函数名调用函数，通过类型名创造类实例。 本文的目标就是在 C++ 中构建出类似 Java/C# 中的Object那样的动态的类型。\n元类型 # 我们这里不采用类似 Java/C# 中Object那种侵入式设计（继承），而是采用被叫做 fat pointer 非侵入式设计。所谓 fat pointer 其实就是一个结构体，包含了一个指向实际数据的指针，以及一个指向类型信息的指针。如果是继承的话，则是这个虚表指针存在对象头部。\nclass Any { Type* type; // type info, similar to vtable void* data; // pointer to the data uint8_t flag; // special flag public: Any() : type(nullptr), data(nullptr), flag(0) {} Any(Type* type, void* data) : type(type), data(data), flag(0B00000001) {} Any(const Any\u0026amp; other); Any(Any\u0026amp;\u0026amp; other); ~Any(); template \u0026lt;typename T\u0026gt; Any(T\u0026amp;\u0026amp; value); // box value to Any template \u0026lt;typename T\u0026gt; T\u0026amp; cast(); // unbox Any to value Type* GetType() const { return type; } // get type info Any invoke(std::string_view name, std::span\u0026lt;Any\u0026gt; args); // call method void foreach(const std::function\u0026lt;void(std::string_view, Any\u0026amp;)\u0026gt;\u0026amp; fn); // iterate fields }; 其中的成员函数将会在后面的章节逐步实现，接下来我们先来考虑这个Type类型里面存的是什么。\n元信息 # struct Type { std::string_view name; // type name void (*destroy)(void*); // destructor void* (*copy)(const void*); // copy constructor void* (*move)(void*); // move constructor using Field = std::pair\u0026lt;Type*, std::size_t\u0026gt;; // type and offset using Method = Any (*)(void*, std::span\u0026lt;Any\u0026gt;); // method std::unordered_map\u0026lt;std::string_view, Field\u0026gt; fields; // field info std::unordered_map\u0026lt;std::string_view, Method\u0026gt; methods; // method info }; 这里的内容很简单，我们在Type里面中存了类型名，析构函数，移动构造，拷贝构造，字段信息和方法信息。字段信息里面存的是字段类型和字段名，方法信息里面存的是方法名和函数地址。如果希望进一步扩展的话，还可以把父类的信息和重载函数的信息也存进来。由于这里只是做一个示例，就暂时不考虑它们了。\n函数类型擦除 # 为了把不同类型的成员函数存在同一个容器里面，我们必须要对函数类型进行擦除。所有类型的函数都被擦除成了 Any(*)(void*, std::span\u0026lt;Any\u0026gt;)这个类型。这里的Any类型就是我们上面定义的Any类型，这里的void*其实代表就是this指针，而std::span\u0026lt;Any\u0026gt;则是函数的参数列表。现在我们要考虑如何进行这种函数类型擦除。\n以下面给定的成员函数say为例：\nstruct Person { std::string_view name; std::size_t age; void say(std::string_view msg) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; say: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; 首先为了方便书写，我们把Any的cast实现一下：\ntemplate \u0026lt;typename T\u0026gt; Type* type_of(); // type_of\u0026lt;T\u0026gt; returns type info of T template \u0026lt;typename T\u0026gt; T\u0026amp; Any::cast() { if(type != type_of\u0026lt;T\u0026gt;()) { throw std::runtime_error{\u0026#34;type mismatch\u0026#34;}; } return *static_cast\u0026lt;T*\u0026gt;(data); } 利用 C++ 中无捕获的lambda能隐式转换成函数指针这个特性，可以轻松实现这种擦除。\nauto f = +[](void* object, std::span\u0026lt;Any\u0026gt; args) { auto\u0026amp; self = *static_cast\u0026lt;Person*\u0026gt;(object); self.say(args[0].cast\u0026lt;std::string_view\u0026gt;()); return Any{}; }; 其实原理很简单，只要写一个 wrapper 函数进行一下类型转换，然后转发调用就行了。但是如果每个成员函数都要手写这么一大段转发代码还是很麻烦的。我们可以考虑通过模板元进行代码生成，自动生成上面的代码，简化类型擦除的这个过程。\ntemplate \u0026lt;typename T\u0026gt; struct member_fn_traits; template \u0026lt;typename R, typename C, typename... Args\u0026gt; struct member_fn_traits\u0026lt;R (C::*)(Args...)\u0026gt; { using return_type = R; using class_type = C; using args_type = std::tuple\u0026lt;Args...\u0026gt;; }; template \u0026lt;auto ptr\u0026gt; auto* type_ensure() { using traits = member_fn_traits\u0026lt;decltype(ptr)\u0026gt;; using class_type = typename traits::class_type; using result_type = typename traits::return_type; using args_type = typename traits::args_type; return +[](void* object, std::span\u0026lt;Any\u0026gt; args) -\u0026gt; Any { auto self = static_cast\u0026lt;class_type*\u0026gt;(object); return [=]\u0026lt;std::size_t... Is\u0026gt;(std::index_sequence\u0026lt;Is...\u0026gt;) { if constexpr(std::is_void_v\u0026lt;result_type\u0026gt;) { (self-\u0026gt;*ptr)(args[Is].cast\u0026lt;std::tuple_element_t\u0026lt;Is, args_type\u0026gt;\u0026gt;()...); return Any{}; } else { return Any{(self-\u0026gt;*ptr)(args[Is].cast\u0026lt;std::tuple_element_t\u0026lt;Is, args_type\u0026gt;\u0026gt;()...)}; } }(std::make_index_sequence\u0026lt;std::tuple_size_v\u0026lt;args_type\u0026gt;\u0026gt;{}); }; } 这里的代码我就不解释了，如果看不懂也没关系。其实就是通过模板元，把成员函数类型擦除的这个过程自动化了一下。只要知道如何使用就行了，使用起来是非常简单的。这里的\u0026amp;Person::say是 pointer to member 的写法，不太熟悉的可以参考 C++ 成员指针完全解析。\nauto f = type_ensure\u0026lt;\u0026amp;Person::say\u0026gt;(); // decltype(f) =\u0026gt; Any (*)(void*, std::span\u0026lt;Any\u0026gt;) 类型信息注册 # 事实上我们需要给每个类型都生成一个对应的Type结构来保存它的信息，这样的话才能正确访问。而这个功能就由上文提到的type_of函数负责。\ntemplate \u0026lt;typename T\u0026gt; Type* type_of() { static Type type; type.name = typeid(T).name(); type.destroy = [](void* obj) { delete static_cast\u0026lt;T*\u0026gt;(obj); }; type.copy = [](const void* obj) { return (void*)(new T(*static_cast\u0026lt;const T*\u0026gt;(obj))); }; type.move = [](void* obj) { return (void*)(new T(std::move(*static_cast\u0026lt;T*\u0026gt;(obj)))); }; return \u0026amp;type; } template \u0026lt;\u0026gt; Type* type_of\u0026lt;Person\u0026gt;() { static Type type; type.name = \u0026#34;Person\u0026#34;; type.destroy = [](void* obj) { delete static_cast\u0026lt;Person*\u0026gt;(obj); }; type.copy = [](const void* obj) { return (void*)(new Person(*static_cast\u0026lt;const Person*\u0026gt;(obj))); }; type.move = [](void* obj) { return (void*)(new Person(std::move(*static_cast\u0026lt;Person*\u0026gt;(obj)))); }; type.fields.insert({\u0026#34;name\u0026#34;, {type_of\u0026lt;std::string_view\u0026gt;(), offsetof(Person, name)}}); type.fields.insert({\u0026#34;age\u0026#34;, {type_of\u0026lt;std::size_t\u0026gt;(), offsetof(Person, age)}}); type.methods.insert({\u0026#34;say\u0026#34;, type_ensure\u0026lt;\u0026amp;Person::say\u0026gt;()}); return \u0026amp;type; }; 我们提供一个默认实现，这样的话如果用到了内置的基础类型可以自动注册一些信息。然后可以通过特化给自定义的类型提供实现，好了，现在有了这些元信息我们可以把Any的成员函数实现补充完整了。\nAny 完整实现 # Any::Any(const Any\u0026amp; other) { type = other.type; data = type-\u0026gt;copy(other.data); flag = 0; } Any::Any(Any\u0026amp;\u0026amp; other) { type = other.type; data = type-\u0026gt;move(other.data); flag = 0; } template \u0026lt;typename T\u0026gt; Any::Any(T\u0026amp;\u0026amp; value) { type = type_of\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;(); data = new std::decay_t\u0026lt;T\u0026gt;(std::forward\u0026lt;T\u0026gt;(value)); flag = 0; } Any::~Any() { if(!(flag \u0026amp; 0B00000001) \u0026amp;\u0026amp; data \u0026amp;\u0026amp; type) { type-\u0026gt;destroy(data); } } void Any::foreach(const std::function\u0026lt;void(std::string_view, Any\u0026amp;)\u0026gt;\u0026amp; fn) { for(auto\u0026amp; [name, field]: type-\u0026gt;fields) { Any any = Any{field.first, static_cast\u0026lt;char*\u0026gt;(data) + field.second}; fn(name, any); } } Any Any::invoke(std::string_view name, std::span\u0026lt;Any\u0026gt; args) { auto it = type-\u0026gt;methods.find(name); if(it == type-\u0026gt;methods.end()) { throw std::runtime_error{\u0026#34;method not found\u0026#34;}; } return it-\u0026gt;second(data, args); } foreach的实现就是遍历所有的Field然后获取偏移量和类型，然后把它包装成Any类型。注意这里只是简单包装一下，实际上由于我们设置了flag，这个包装并不会导致多次析构。invoke就是从成员函数列表里面找出对应的函数，然后调用。\n示例代码 # int main() { Any person = Person{\u0026#34;Tom\u0026#34;, 18}; std::vector\u0026lt;Any\u0026gt; args = {std::string_view{\u0026#34;Hello\u0026#34;}}; person.invoke(\u0026#34;say\u0026#34;, args); // =\u0026gt; Tom say: Hello auto f = [](std::string_view name, Any\u0026amp; value) { if(value.GetType() == type_of\u0026lt;std::string_view\u0026gt;()) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; value.cast\u0026lt;std::string_view\u0026gt;() \u0026lt;\u0026lt; std::endl; } else if(value.GetType() == type_of\u0026lt;std::size_t\u0026gt;()) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; value.cast\u0026lt;std::size_t\u0026gt;() \u0026lt;\u0026lt; std::endl; } }; person.foreach(f); // name = Tom // age = 18 return 0; } 完整代码放在 Github 上了，至此我们就已经实现了一个极度动态，非侵入式的Any了。\n扩展和优化 # 本文给出的只是非常简单的原理介绍，考虑的情况也十分简单。比如这里没有考虑继承和函数重载，在运行效率上也有若干可以优化的地方。尽管如此，可能我写的功能对你来说仍然是过多的。本文想主要表达的意思是，对于 C++ 这种非常注重性能的语言来说，有时候的确会在一些场景需要这些比较动态的特性。然而高效性和通用性往往是矛盾的，语言层面因为要考虑通用性，所以效率往往不尽如人意。例如RTTI和dynamic_cast常常被人抱怨，不过好在编译器提供选项来关闭它们。同样的，我的实现也不一定完全符合你的场景，但是懂得这并不困难的原理之后你完全可以根据你的场景来实现一个更加适合你的版本。\n可以扩展的点：\n支持根据name来修改成员 添加一个全局的map用于记录所有类型的信息，从而支持根据类名创造类的实例 ... 可以优化的点：\n减少new的次数，或者自己实现一个对象池 或者目前储存的元信息过多，根据你自己的需求进行裁剪 除此之外，现在还有一个痛点是，这些元信息我们都要手写，很难维护。如果要修改类内的定义还得把这些注册代码一并修改，否则就会出错。这里一个实际可行的方案是使用代码生成器来自动生成这些机械的代码。关于如何进行这些操作，可以参考本系列的其它文章\n写给 C++ 程序员的反射教程 https://www.ykiko.me/articles/669358870\n","date":"December 3, 2023","externalUrl":null,"permalink":"/articles/670191053/","section":"Articles","summary":"静态与动态 # 静态类型和动态类型这两个词语相信大家都不陌生了，","title":"在 C++ 中实现 Object!","type":"articles"},{"content":" 首先什么是元信息？ # 来看下面一段python代码，我们希望能够根据传入的字符串来自动修改对应的字段值\nclass Person: def __init__(self, age, name): self.age = age self.name = name person = Person(10, \u0026#34;xiaohong\u0026#34;) setattr(person, \u0026#34;age\u0026#34;, 12) setattr(person, \u0026#34;name\u0026#34;, \u0026#34;xiaoming\u0026#34;) print(f\u0026#34;name: {person.name}, age: {person.age}\u0026#34;) # =\u0026gt; name: xiaoming, age: 12 setattr是python内置的一个函数，刚好可以实现我们的需求。根据输入的字段名，修改对应值。\n如果想要在C++中实现应该怎么办呢？C++可没有内置setattr这种函数。代码示例如下。（暂时就先考虑可以直接memcpy的类型了，也就是trivially copyable的类型）\nstruct Person { int age; std::string_view name; }; // 名字 -\u0026gt; 字段偏移量，字段大小 std::map\u0026lt;std::string_view, std::pair\u0026lt;std::size_t, std::size_t\u0026gt;\u0026gt; fieldInfo = { {\u0026#34;age\u0026#34;, {offsetof(Person, age), sizeof(int)}}, {\u0026#34;name\u0026#34;, {offsetof(Person, name), sizeof(std::string_view)}}, }; void setattr(Person* point, std::string_view name, void* data) { if (!fieldInfo.contains(name)) { throw std::runtime_error(\u0026#34;Field not found\u0026#34;); } auto\u0026amp; [offset, size] = fieldInfo[name]; std::memcpy(reinterpret_cast\u0026lt;char*\u0026gt;(point) + offset, data, size); } int main() { Person person = {.age = 1, .name = \u0026#34;xiaoming\u0026#34;}; int age = 10; std::string_view name = \u0026#34;xiaohong\u0026#34;; setattr(\u0026amp;person, \u0026#34;age\u0026#34;, \u0026amp;age); setattr(\u0026amp;person, \u0026#34;name\u0026#34;, \u0026amp;name); std::cout \u0026lt;\u0026lt; person.age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; person.name \u0026lt;\u0026lt; std::endl; // =\u0026gt; 10 xiaohong } 可以发现我们基本上自己实现了setattr这个函数，而且这样的实现似乎可以是通用的。只要为特定的类型提供属于它的fieldInfo就行了。这个fieldInfo里面存了字段名，字段的偏移量，字段的类型大小。它就可以被看做元信息,除此之外可能还有变量名，函数名，等等。这些信息不直接参与程序的运行，而是提供关于程序结构、数据、类型等方面的附加信息。元信息里面存的东西似乎也都是死套路，对于我们都是已知信息。因为它们就存在程序的源代码里面。那C/C++编译器提供这种功能吗？答案是：对于debug模式下的程序可能会保留一部分用于程序调试，而在release模式下什么都不会存。这样做的好处是很显然的，因为这些信息并不是程序运行起来必须要的信息，不保留它们可以显著减少二进制可执行文件的大小。\n为什么这些信息是不必要的，什么时候需要？ # 接下来我会以C语言为例，将它的源码与二进制表示对应起来。看看执行代码究竟需要哪些信息？\n变量定义 # int value; 事实上变量声明并没有直接对应的二进制表示，它仅仅是告诉编译器需要分配一块空间来存储名为value的变量，究竟分配多大的内存则由它的类型决定。所以如果变量声明的时候类型大小是未知的，则会编译错误。\nstruct A; A x; // error: storage size of \u0026#39;x\u0026#39; isn\u0026#39;t known A* y; // ok the size of pointer is always konwn struct Node { int val; Node next; }; // error Node is not a complete type // 其实意思就是定义 Node 类型的时候它的大小还是未知的 struct Node { int val; Node* next; }; // ok 相信你想到了这和malloc似乎有点像，的确如此。区别在于，malloc是在运行时的堆上分配内存。而直接的变量声明一般是在数据区或者栈上分配内存。编译器可能在内部会维护一个符号表，将变量名与它的地址映射起来，在你后续对这个变量进行操作的时候，实际上是对这块内存区域进行操作。\n内置运算符 # C语言内置的运算符一般直接和CPU指令直接对应，至于CPU是如何实现这些运算的，可以学习下数电相关知识。以x86_64为例，可能的对应如下\n| Operator | Meaning | Operator | Meaning | |----------|---------|----------|---------| | + | add | * | mul | | - | sub | / | div | | % | div | \u0026amp; | and | | \\| | or | ^ | xor | | ~ | not | \u0026lt;\u0026lt; | shl | | \u0026gt;\u0026gt; | shr | \u0026amp;\u0026amp; | and | | || | or | ! | not | | == | cmp | != | cmp | | \u0026gt; | cmp | \u0026gt;= | cmp | | \u0026lt; | cmp | \u0026lt;= | cmp | | ++ | inc | -- | dec | 赋值则可能是通过mov指令来完成的，比如\na = 3; // mov [addressof(a)] 3 结构体 # struct Point { int x; int y; } int main() { Point point; point.x = 1; point.y = 2; } 结构体的大小一般可以由特定规则算出从它的成员算出，往往要考虑内存对齐，而且是编译器决定的。例如 msvc。但总之在编译的时候结构体的大小就是已知的了，我们也可以通过sizeof获取类型或者变量的大小。那么这里的Point point变量定义就很好理解，类型大小已知，相对于在栈上分配了一块内存。\n下面来关注一下结构体成员访问，事实上C语言有一个宏可以获取结构体成员相对于结构体起始地址的偏移量，叫做offsetof（就算我们获取不到，编译器里面也是会计算字段偏移量的，所以偏移量信息对编译器总是已知的）。例如在这里offsetof(Point, x)就是0，offsetof(Point, y)就是4。所以上面的代码可以理解为\nint main() { char point[sizeof(Point)]; // 8 = sizeof(Point) *(int*)(point + offsetof(Point, x)) = 1; // point.x = 1 *(int*)(point + offsetof(Point, y)) = 2; // point.y = 2 } 编译器同样可能会维护一个字段名-\u0026gt;偏移量的符号表，字段名最终会替换为offset。也没有必要在程序中保留了。\n函数调用 # 一般通过函数调用栈实现，这个太常见了，就不仔细说了。函数名最后会直接被替换为函数地址。\n总结 # 通过上面的分析，相信你已经发现了，C语言中的符号名，类型名，变量名，函数名，结构体字段名等等信息都被替换成了数字，地址，偏移量等等。缺少了它们对程序运行并没有什么影响。所以选择把它们抛弃掉，减少二进制文件的大小。对于C++来说情况基本也是类似的，C++只会在一些特殊的情况下保留部分元信息，比如type_info，而且可以手动选择关闭掉RTTI从而确保不会产生这种信息。\n那什么时候我们需要使用这些信息？显然最开始介绍的setattr是需要的。在程序调试的时候，我们得知道一个地址对应的变量名，函数名，成员名等等，方便我们调试，这时候我们也是需要的。当把结构体序列化为json的时候，我们需要知道它的字段名，我们也需要这些信息。把类型擦除成void*了之后，我们还是需要知道它实际对应的类型是什么，这时候我们也是需要的。总之，为了在运行期区分这串二进制内容倒是原本是什么东西的时候，我们就需要这些信息（当然在编译期想要利用这些信息进行代码生成，也是需要的）。\n如何获取这些信息？ # C/C++编译器并没有提供给我们接口让我们获取这些信息，但是前面已经说了，这些信息显然就在源代码里面啊。变量名，函数名，类型名，字段名。我们可以选择通过人工理解代码，然后手动去存储元信息。几千个类，几十个成员函数，可能写个几个月就好了吧。开玩笑的，或者我们可以写一些程序，比如正则表达式匹配之类的帮我们获取到这些信息？不过，其实我们有更好的选择来获取这些信息，那就是通过AST。\nAST(Abstract Syntax Tree) # AST是抽象语法树（Abstract Syntax Tree）的缩写。它是编程语言处理中的一种数据结构，用于表示源代码的抽象语法结构。AST是源代码经过解析器（parser）处理后的结果，它捕捉了代码中的语法结构，但不包含所有细节，比如空白字符或注释。在AST中，每个节点代表源代码中的一个语法结构，例如变量声明、函数调用、循环等。这些节点之间通过父子关系和兄弟关系连接，形成了一棵树状结构，这样的结构更容易被计算机程序理解和处理。如果你的电脑里面装了clang编译器，可以使用下面这个命令查看一个源文件的语法树\nclang -Xclang -ast-dump -fsyntax-only \u0026lt;your.cpp\u0026gt; 输出如下，我筛选出了重要的信息，无关的已经被删除了\n|-CXXRecordDecl 0x2103cd9c318 \u0026lt;col:1, col:8\u0026gt; col:8 implicit struct Point |-FieldDecl 0x2103cd9c3c0 \u0026lt;line:4:5, col:9\u0026gt; col:9 referenced x \u0026#39;int\u0026#39; |-FieldDecl 0x2103e8661f0 \u0026lt;line:5:5, col:9\u0026gt; col:9 referenced y \u0026#39;int\u0026#39; `-FunctionDecl 0x2103e8662b0 \u0026lt;line:8:1, line:13:1\u0026gt; line:8:5 main \u0026#39;int ()\u0026#39; `-CompoundStmt 0x2103e866c68 \u0026lt;line:9:1, line:13:1\u0026gt; |-DeclStmt 0x2103e866b30 \u0026lt;line:10:5, col:16\u0026gt; | `-VarDecl 0x2103e866410 \u0026lt;col:5, col:11\u0026gt; col:11 used point \u0026#39;Point\u0026#39;:\u0026#39;Point\u0026#39; callinit | `-CXXConstructExpr 0x2103e866b08 \u0026lt;col:11\u0026gt; \u0026#39;Point\u0026#39;:\u0026#39;Point\u0026#39; \u0026#39;void () noexcept\u0026#39; |-BinaryOperator 0x2103e866bb8 \u0026lt;line:11:5, col:15\u0026gt; \u0026#39;int\u0026#39; lvalue \u0026#39;=\u0026#39; | |-MemberExpr 0x2103e866b68 \u0026lt;col:5, col:11\u0026gt; \u0026#39;int\u0026#39; lvalue .x 0x2103cd9c3c0 | | `-DeclRefExpr 0x2103e866b48 \u0026lt;col:5\u0026gt; \u0026#39;Point\u0026#39;:\u0026#39;Point\u0026#39; lvalue Var 0x2103e866410 \u0026#39;point\u0026#39; \u0026#39;Point\u0026#39;:\u0026#39;Point\u0026#39; | `-IntegerLiteral 0x2103e866b98 \u0026lt;col:15\u0026gt; \u0026#39;int\u0026#39; 1 `-BinaryOperator 0x2103e866c48 \u0026lt;line:12:5, col:15\u0026gt; \u0026#39;int\u0026#39; lvalue \u0026#39;=\u0026#39; |-MemberExpr 0x2103e866bf8 \u0026lt;col:5, col:11\u0026gt; \u0026#39;int\u0026#39; lvalue .y 0x2103e8661f0 | `-DeclRefExpr 0x2103e866bd8 \u0026lt;col:5\u0026gt; \u0026#39;Point\u0026#39;:\u0026#39;Point\u0026#39; lvalue Var 0x2103e866410 \u0026#39;point\u0026#39; \u0026#39;Point\u0026#39;:\u0026#39;Point\u0026#39; `-IntegerLiteral 0x2103e866c28 \u0026lt;col:15\u0026gt; \u0026#39;int\u0026#39; 2 或者如果你的vscode装了clangd这个插件，可以右键选择一块代码，然后右键show AST来看这块代码片段的ast。可以发现上面的确是把源码内容以树的方式呈现给我们了，既然是一颗树，我们就可以自由的遍历树的节点，然后筛选获取我们想要的信息。上面两例都是可视化的输出，通常情况下也会有直接的代码接口来直接获取。比如python内置就有ast模块来获取，C++一般是通过clang相关的工具来获取这些内容。如果想知道具体该如何使用clang工具，可以参考这篇文章\n使用 clang 工具自由的支配 C++ 代码吧！ https://www.ykiko.me/articles/669360731\n如果你好奇编译器究竟是如何把源代码变成ast的，你可以去学习一下编译原理前端的内容。\n以何种方式存储这些信息？ # 这个问题听起来让人有些困惑，实际上这个问题可能只有C++程序员需要考虑\n其实一切原因都是constexpr引起的。把信息下面这样存储起来\nstruct FieldInfo { std::string_view name; std::size_t offset; std::size_t size; }； struct Point { int x; int y; }； constexpr std::array\u0026lt;FieldInfo, 2\u0026gt; fieldInfos = {{ {\u0026#34;x\u0026#34;, offsetof(Point, x), sizeof(int)}, {\u0026#34;y\u0026#34;, offsetof(Point, y), sizeof(int)}, }}; 就意味着我们不仅仅能在运行期查询这些信息，还能在编译期查询这些信息\n更有甚者，还可以存到模板参数里面去，这样的话连类型也能存了\ntemplate\u0026lt;fixed_string name, std::size_t offset, typename Type\u0026gt; struct Field{}; using FieldInfos = std::tuple \u0026lt; Field\u0026lt;\u0026#34;x\u0026#34;, offsetof(Point, x), int\u0026gt;, Field\u0026lt;\u0026#34;y\u0026#34;, offsetof(Point, y), int\u0026gt; \u0026gt;; 这样无疑给了我们更大的操作空间，那么有了这些信息之后，下一步该做些什么？事实上我们可以选择基于这部分信息进行代码生成，相关的内容可以浏览系列文章中的其它小节。总目录的链接在下方：\n写给 C++ 程序员的反射教程 https://www.ykiko.me/articles/669358870\n","date":"December 3, 2023","externalUrl":null,"permalink":"/articles/670190357/","section":"Articles","summary":"首先什么是元信息？ # 来看下面一段python代码，我们希望能","title":"为什么说 C/C++ 编译器不保留元信息？","type":"articles"},{"content":"Clang 是 LLVM 项目提供的一个 C 语言家族的编译器前端。它最初开发的目的是替代 GNU Compiler Collection (GCC) 的 C 语言前端，目标是提供更快的编译速度、更好的诊断信息和更灵活的架构。Clang 包含一个 C、C++ 和 Objective-C 编译器前端，这些前端设计为可以嵌入到其他项目中。Clang 的一个重要特点是其模块化架构，使开发者能够更轻松地扩展和定制编译器的功能。Clang 被广泛应用于许多项目，包括 LLVM 自身、一些操作系统内核的开发以及一些编程语言的编译器实现。\n除了作为编译器使用之外，Clang 还可以作为一个库提供，使开发者能够在其应用程序中利用编译器的功能，例如源代码分析和生成。Clang 可以用来获取 C++ 源文件的抽象语法树 (AST)，以便进一步处理这些信息。本文将介绍如何使用 Clang 工具。\nInstallation \u0026amp; Usage # 目前，Clang 被划分为以下库和工具：libsupport、libsystem、libbasic、libast、liblex、libparse、libsema、libcodegen、librewrite、libanalysis。由于 Clang 本身是用 C++ 编写的，所以相关的接口都是 C++ 的。然而，由于 C++ 接口本身的复杂性和不稳定性（例如：在 Windows 上由 GCC 编译出来的 DLL 无法给 MSVC 使用，或者 Clang 自身版本升级导致 API 变动，从而出现不兼容性），官方并不推荐优先使用 C++ 接口。\n除了 C++ 接口之外，官方还提供了一个叫做 libclang 的 C 语言接口，这个接口不仅使用起来相对简单，而且本身也比较稳定。唯一的缺点是无法获取完整的 C++ 抽象语法树 (AST)，不过鉴于 C++ 完整的语法树本身就极度复杂，很多时候我们只需要其中的一小部分信息，所以这个问题通常可以忽略，除非你真的有这方面的需求。\n如果你想要使用 libclang，你需要先安装 LLVM 和 Clang。在 LLVM Release 页面，有若干预发布的二进制包可以下载。如果你有定制化需求，请参考 Getting Started 页面进行手动编译。安装完成后，只需将llvm/lib目录下的libclang.dll链接到程序中，并包含llvm/include目录下的clang-c/Index.h头文件即可使用。\n然而，由于 C 语言没有一些高级抽象，操作字符串都很麻烦。如果大规模使用，还需要我们自己用 C++ 封装一层。幸好，官方基于这套 C 接口还提供了一个 Python 绑定，即 clang 这个包，这使得使用起来更加方便。然而，官方提供的 Python 绑定并没有打包 libclang 的这个 DLL，因此你仍然需要在电脑上手动配置 LLVM 的环境，这可能会有些麻烦。不过，社区中有人在 PyPI 上提供了打包好的包：libclang。\n于是如果你想使用 libclang 来获取 C++ 语法树，只需要\npip install libclang 什么额外的事情都不用做。本文就基于这个 python binding 的版本进行介绍。C 版本的 API 和 Python 版本的 API 基本是完全一致的，如果你觉得 Python 性能不够，你也可以参考这个教程对照着写 C 版本的代码。另外官方提供的包并没有 type hint，这样的话用 Python 写就没有代码补全，用起来也不舒服。我自己补了一个类型提示的 cindex.pyi，下载下来之后直接和 放在同一文件夹内就能有代码提示了。\nQuick Start # 示例的 C++ 源文件代码如下\n// main.cpp struct Person { int age; const char* name; }; int main() { Person person = {1, \u0026#34;John\u0026#34;}; return 0; } 解析它的 Python 代码如下\nimport clang.cindex as CX def traverse(node: CX.Cursor, prefix=\u0026#34;\u0026#34;, is_last=True): branch = \u0026#34;└──\u0026#34; if is_last else \u0026#34;├──\u0026#34; text = f\u0026#34;{str(node.kind).removeprefix(\u0026#39;CursorKind.\u0026#39;)}: {node.spelling}\u0026#34; if node.kind == CX.CursorKind.INTEGER_LITERAL: value = list(node.get_tokens())[0].spelling text = f\u0026#34;{text}{value}\u0026#34; print(f\u0026#34;{prefix}{branch} {text}\u0026#34;) new_prefix = prefix + (\u0026#34; \u0026#34; if is_last else \u0026#34;│ \u0026#34;) children = list(node.get_children()) for child in children: traverse(child, new_prefix, child is children[-1]) index = CX.Index.create(excludeDecls=True) tu = index.parse(\u0026#39;main.cpp\u0026#39;, args=[\u0026#39;-std=c++20\u0026#39;]) traverse(tu.cursor) 输出结果如下\nTRANSLATION_UNIT: main.cpp ├── STRUCT_DECL: Person │ ├── FIELD_DECL: age │ └── FIELD_DECL: name └── FUNCTION_DECL: main └── COMPOUND_STMT: ├── DECL_STMT: │ └── VAR_DECL: person │ ├── TYPE_REF: struct Person │ └── INIT_LIST_EXPR: │ ├── INTEGER_LITERAL: 1 │ └── STRING_LITERAL: \u0026#34;John\u0026#34; └── RETURN_STMT: └── INTEGER_LITERAL: 0 前面的是语法树节点类型，后面是节点的内容。可以发现还是非常清晰的，几乎能和源代码一一对应。\nBasic Types # 注意，本文假定读者对语法树有一定的认识，不在这里做过多介绍了。如果不知道语法树是什么的话，可以看一下 为什么说 C/C++ 编译器不保留元信息。下面对 cindex 中的一些常用类型做一些介绍\nCursor # 相当于语法树的基本节点，整个语法树都是由Cursor组成的。通过kind属性返回一个CursorKind类型枚举值，就代表了这个节点实际对应的类型。\nfor kind in CursorKind.get_all_kinds(): print(kind) 这样可以打印出所有支持的节点类型，也可以直接去源码查看。Cursor还有一些其它的属性和方法让我们使用，常用的有如下这些：\n@property def spelling(self) -\u0026gt; str: @property def displayname(self) -\u0026gt; str: @property def mangled_name(self) -\u0026gt; str: 获取节点的名字，例如一个变量声明的节点，它的spelling就是这个变量的名字。而displayname则是节点的简短名字，大多数时候和spelling是一样的。但是有些时候会有区别，例如一个函数的spelling会带上参数类型，例如func(int)，但是它的displayname就只是func。而mangled_name就是该符号经过 name mangling 之后用于链接的名字。\n@property def type(self) -\u0026gt; Type: 节点元素的类型，例如一个变量声明的节点，它的type就是这个变量的类型。或者一个字段声明的节点，它的type就是这个字段的类型。返回类型为Type。\n@property def location(self) -\u0026gt; SourceLocation: 节点的位置信息，返回类型为SourceLocation，其中携带了该节点在源码中的行数，列数，文件名等信息。\n@property def extent(self) -\u0026gt; SourceRange: 节点的范围信息，返回类型为SourceRange，由两个SourceLocation组成，其中携带了该节点在源码中的起始位置和结束位置\n@property def access_specifier(self) -\u0026gt; AccessSpecifier: 节点的访问权限，返回类型为AccessSpecifier。有PUBLIC, PROTECTED, PRIVATE, NONE, INVALID五种。\ndef get_children(self) -\u0026gt; iterable[Cursor]: 获取所有子节点，返回类型为Cursor的iterable。这个函数是最常用的，因为我们可以通过递归的方式遍历整个语法树。\ndef get_tokens(self) -\u0026gt; iterable[Token]: 获取代表该节点的所有token，返回类型为Token的iterable。token是语法树的最小单位，例如一个变量声明的节点，它的token就是int，a，;这三个。这个函数可以用来获取一些细节信息，例如获取整数字面量和浮点数字面量的值。\ndef is_definition(self) -\u0026gt; bool: def is_const_method(self) -\u0026gt; bool: def is_converting_constructor(self) -\u0026gt; bool: def is_copy_constructor(self) -\u0026gt; bool: def is_default_constructor(self) -\u0026gt; bool: def is_move_constructor(self) -\u0026gt; bool: def is_default_method(self) -\u0026gt; bool: def is_deleted_method(self) -\u0026gt; bool: def is_copy_assignment_operator_method(self) -\u0026gt; bool: def is_move_assignment_operator_method(self) -\u0026gt; bool: def is_mutable_field(self) -\u0026gt; bool: def is_pure_virtual_method(self) -\u0026gt; bool: def is_static_method(self) -\u0026gt; bool: def is_virtual_method(self) -\u0026gt; bool: def is_abstract_record(self) -\u0026gt; bool: def is_scoped_enum(self) -\u0026gt; bool: 这些函数基本就见名知意了，例如is_definition就是判断该节点是否是一个定义，is_const_method就是判断该节点是否是一个const方法。\nType # 如果该节点有类型的话，代表该节点的类型。常用的属性有\n@property def kind(self) -\u0026gt; TypeKind: 类型的类型，返回类型为TypeKind。例如INT, FLOAT, POINTER, FUNCTIONPROTO等等。\n@property def spelling(self) -\u0026gt; str: 类型的名字，例如int, float, void等等。\ndef get_align(self) -\u0026gt; int: def get_size(self) -\u0026gt; int: def get_offset(self, fieldname: str) -\u0026gt; int: 获取类型的对齐，大小，字段偏移量等等。\n以及一些is开头的函数，例如is_const_qualified, is_function_variadic, is_pod等等。这里也就不多说了。\nTranslationUnit # 一般来说一个 C++ 源文件就代表一个TranslationUnit，也就是我们常说的编译单元。\n常用的有\n@property def cursor(self) -\u0026gt; Cursor: 获取该TranslationUnit的根节点，也就是TRANSLATION_UNIT类型的Cursor。\n@property def spelling(self) -\u0026gt; str: 获取该TranslationUnit的文件名。\ndef get_includes(self, depth: int = -1) -\u0026gt; iterable[FileInclusion]: 获取该TranslationUnit的所有include，返回类型为FileInclusion的list，注意由于include的文件里面可能还会包含别的文件所以，可以用depth这个参数来限制，比如我只想获取第一层也就是直接包含的头文件可以这么写。\nindex = CX.Index.create() tu = index.parse(\u0026#39;main.cpp\u0026#39;, args=[\u0026#39;-std=c++20\u0026#39;]) for file in tu.get_includes(): if file.depth == 1: print(file.include.name) 这样就会打印出所有直接使用的头文件了。\nIndex # 一个Index就是一个TranslationUnit的集合，并且最终被链接到一起，形成一个可执行文件或者库。\n有一个静态方法create用于创建一个新的Index ，然后成员方法parse可以解析一个C++源文件，返回一个TranslationUnit。\ndef parse(self, path: str, args: list[str] | None = ..., unsaved_files: list[tuple[str, str]] | None = ..., options: int = ...) -\u0026gt; TranslationUnit: path是源文件路径，args是编译参数，unsaved_files是未保存的文件，options是一些定义在TranslationUnit.PARSE_XXX中的参数，例如PARSE_SKIP_FUNCTION_BODIES和PARSE_INCOMPLETE。可以用来定制化解析过程，加快解析速度，或者保留宏信息等。\nExamples # Namespace # 由于 clang 在解析的时候会把所有的头文件都展开，全部输出内容太多了。但是我们主要可能只是想要我们自己代码的信息，这时候就可以利用命名空间进行筛选了。示例如下：\n#include \u0026lt;iostream\u0026gt; namespace local { struct Person { int age; std::string name; }; } 解析代码如下\nimport clang.cindex as CX def traverse_my(node: CX.Cursor): if node.kind == CX.CursorKind.NAMESPACE: if node.spelling == \u0026#34;local\u0026#34;: traverse(node) # forward to the previous function for child in node.get_children(): traverse_my(child) index = CX.Index.create() tu = index.parse(\u0026#39;main.cpp\u0026#39;, args=[\u0026#39;-std=c++20\u0026#39;]) traverse_my(tu.cursor) 写一个函数对类型空间名进行筛选，然后转发到我们之前那个函数就行，这样就只会输出我们想要的的命名空间里面的内容了。\nClass \u0026amp; Struct # 我们主要是获取它们里面的字段名，类型，方法名，类型等，示例如下：\nstruct Person { int age; const char* name; void say_hello(int a, char b); }; 解析代码如下\ndef traverse_class(node: CX.Cursor): match node.kind: case CX.CursorKind.STRUCT_DECL | CX.CursorKind.CLASS_DECL: print(f\u0026#34;Class: {node.spelling}:\u0026#34;) case CX.CursorKind.FIELD_DECL: print(f\u0026#34; Field: {node.spelling}: {node.type.spelling}\u0026#34;) case CX.CursorKind.CXX_METHOD: print(f\u0026#34; Method: {node.spelling}: {node.type.spelling}\u0026#34;) for arg in node.get_arguments(): print(f\u0026#34; Param: {arg.spelling}: {arg.type.spelling}\u0026#34;) for child in node.get_children(): traverse_class(child) # Class: Person: # Field: age: int # Field: name: const char * # Method: say_hello: void (int, char) # Param: a: int # Param: b: char Comment # 可以获取 Doxygen 风格的注释\n@property def brief_comment(self) -\u0026gt; str: @property def raw_comment(self) -\u0026gt; str: brief_comment获取@brief后面的内容，raw_comment获取整个注释的内容。\n/** * @brief func description * @param param1 * @return int */ int func(int param1){ return param1 + 10000000; } 解析代码如下\ndef traverse_comment(node: CX.Cursor): if node.brief_comment: print(f\u0026#34;brief_comment =\u0026gt; {node.brief_comment}\u0026#34;) if node.raw_comment: print(f\u0026#34;raw_comment =\u0026gt; {node.raw_comment}\u0026#34;) for child in node.get_children(): traverse_comment(child) # brief_comment =\u0026gt; func description # raw_comment =\u0026gt; /** # * @brief func description # * @param param1 # * @return int # */ Enum # 获取枚举名以及对应的枚举常量值，还有它的底层类型\nenum class Color{ RED = 0, GREEN, BLUE }; 解析代码如下\ndef traverse_enum(node: CX.Cursor): if node.kind == CX.CursorKind.ENUM_DECL: print(f\u0026#34;enum: {node.spelling}, underlying type: {node.enum_type.spelling}\u0026#34;) print(f\u0026#34;is scoped?: {node.is_scoped_enum()}\u0026#34;) for child in node.get_children(): print(f\u0026#34; enum_value: {child.spelling}: {child.enum_value}\u0026#34;) for child in node.get_children(): traverse_enum(child) # enum: Color, underlying type: int # is scoped?: True # enum_value: RED: 0 # enum_value: GREEN: 1 # enum_value: BLUE: 2 Attribute # C++11 加入了新的 attribute 语法：[[ ... ]]，可以用来给函数或者变量添加额外的信息。例如[[nodiscard]]和[[deprecated]]。但是我们有时候在自己定义一些标记来给我们的与预处理工具使用，比如标记一个类型需要不需要生成元信息，我们也希望这些标记也能被 libclang 识别出来。但是遗憾的是如果直接写不被标准支持的属性会被 libclang 忽略，也就是最终的 AST 中是没有它的\nstruct [[Reflect]] Person{}; // ignored 一个可行的解决办法是利用get_tokens获取声明中的所有token，然后自己裁剪出来。比如这里获取到的结果就是struct,[,[,Reflect,],],Person,{,}，我们可以从中获取出我们想要的信息。\n但是 clang 给我们提供了一种更好的办法。那就是利用clang::annotate(...)这个 clang 的扩展属性，例如像下面这样\n#define Reflect clang::annotate(\u0026#34;reflect\u0026#34;) struct [[Reflect]] A {}; 这样对于A这个Cursor来说，它的子节点中就会有一个ANNOTATE_ATTR的类型的Cursor，而spelling就是里面存的信息，这里就是reflect。这样我们就可以很方便的获取到我们自定义的属性了。而且 C++ 标准规定了，当编译器遇到一个不认识的 attribute 的时候，它会忽略这个 attribute，而不是报错。这样的话，这个属性它就只作用于我们的预处理器，不会影响到正常编译。\nMacro # clang 在实际解析语法树之前，会把所有的预处理指令都替换成实际的代码。所以最后的语法树信息中就没有它们了。但是有些时候我们的确想要获取到这些信息，比如我们想要获取到#define的信息，这里需要把parse的options参数设为TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD。如果想要获取宏的内容就用get_tokens就行了。\n#define CONCAT(a, b) a#b auto x = CONCAT(1, 2); 解析代码如下\ndef traverse_macro(node: CX.Cursor): if node.kind == CX.CursorKind.MACRO_DEFINITION: if not node.spelling.startswith(\u0026#39;_\u0026#39;): # Exclude internal macros print(f\u0026#34;MACRO: {node.spelling}\u0026#34;) print([token.spelling for token in node.get_tokens()]) elif node.kind == CX.CursorKind.MACRO_INSTANTIATION: print(f\u0026#34;MACRO_INSTANTIATION: {node.spelling}\u0026#34;) print([token.spelling for token in node.get_tokens()]) for child in node.get_children(): traverse_macro(child) # MACRO: CONCAT # [\u0026#39;CONCAT\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;b\u0026#39;] # MACRO_INSTANTIATION: CONCAT # [\u0026#39;CONCAT\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;)\u0026#39;] Rewrite # 有时候我们希望对源代码进行一些简单的修改，在某个位置插入一段代码或者删除一段代码。这时候我们可以使用Rewriter这个类。示例如下：\nvoid func(){ int a = 1; int b = 2; int c = 3; } 使用下面的代码对源文件进行修改\ndef rewrite(node: CX.Cursor, rewriter: CX.Rewriter): if node.kind == CX.CursorKind.VAR_DECL: if node.spelling == \u0026#34;a\u0026#34;: rewriter.replace_text(node.extent, \u0026#34;int a = 100\u0026#34;) elif node.spelling == \u0026#34;b\u0026#34;: rewriter.remove_text(node.extent) elif node.spelling == \u0026#34;c\u0026#34;: rewriter.insert_text_before(node.extent.start, \u0026#34;[[maybe_unused]]\u0026#34;) for child in node.get_children(): rewrite(child, rewriter) index = CX.Index.create() tu = index.parse(\u0026#39;main.cpp\u0026#39;, args=[\u0026#39;-std=c++20\u0026#39;]) rewriter = CX.Rewriter.create(tu) rewrite(tu.cursor, rewriter) rewriter.overwrite_changed_files() 运行之后，main.cpp的内容就变成了\nvoid func() { int a = 100; ; [[maybe_unused]] int c = 3; } Conclusion # 如果要获取类型的size, align, offset等 ABI 相关的内容，需要注意 platform。不同 ABI 的情况下它们的值可能不同，例如 MSVC 和 GCC 一般关于这些内容就不同，可以通过在编译参数中指定-target来指定目标平台。如果需要和 MSVC 一致的结果，可以使用--target=x86_64-pc-windows-msvc。如果是 GCC 的话，可以使用--target=x86_64-pc-linux-gnu。\n前文提到，libclang 无法提供完整的 C++ 语法树。例如，它在解析 Expr 方面缺少许多接口。这意味着，如果你需要解析具体的表达式内容，那么使用其 C++ 接口可能更为适合，因为它提供了完整且复杂的语法树。\n国内关于 Clang 工具具体使用的文章较少。本文尝试对一些常用功能进行了具体介绍，尽管并不十分完善。若有任何疑问，可直接阅读 Index.h 源码，其中的注释非常详尽。或者也可以在评论区留言，我会尽力解答。此外，若需要获取 libclang 不提供的信息，可使用 get_tokens 函数自行获取。例如，libclang 不支持获取整数和浮点数面值的值，这时可通过 get_tokens 手动获取。\n在从语法树中提取这些信息后，你可以进一步处理它们，如生成元信息或直接生成代码等。当然，这些都是后话，具体取决于你的需求。\n本文到这里就结束了，这是反射系列中的其中一篇，如果对其它的文章感兴趣，可以点击下面的链接进行阅读其它文章。\n写给 C++ 程序员的反射教程 https://www.ykiko.me/articles/669358870\n","date":"November 29, 2023","externalUrl":null,"permalink":"/articles/669360731/","section":"Articles","summary":"Clang 是 LLVM 项目提供的一个 C 语言家族的编译器前端。它最初开发的目的","title":"使用 Clang 工具自由的支配 C++ 代码吧","type":"articles"},{"content":" 引入 # 刚好拿最近的一个需求作为引入吧。我们都知道 markdown 可以用lang来填入代码块，并支持代码高亮。可是我想支持自己定义的代码高亮规则，遇到了如下问题：\n有些网站对 markdown 渲染是静态的，不能运行脚本，所以没法直接调用那些 Javascript 的代码高亮库。例如 Github 上面对 markdown 文件的渲染 究竟支持哪些语言一般是由渲染引擎决定的，比如 Github 的渲染支持和 的所支持的就不同。如果要针对不同的渲染引擎写扩展，每个都得写一份，工作量太大了，而且相关的资料很少 那真就没有办法了吗？唉，办法还是有的，幸好大多数引擎都支持直接用 html 的规则，比如\u0026lt;code\u0026gt;来进行渲染\n\u0026lt;code style= \u0026#34;color: #5C6370;font-style: italic;\u0026#34;\u0026gt; # this a variable named \u0026amp;#x27;a\u0026amp;#x27; \u0026lt;/code\u0026gt; 这为我们添加自定义样式提供了可能。但是我们写 markdown 的源文件不能手写这种代码的啊。如果一个语句有三种不同颜色，如果是let a = 3;这样的语句，意味着光一句话我们就得写三个不同的\u0026lt;span\u0026gt;。非常难写，后面维护起来也不好维护，\n事实上我们可以这么做，读取 markdown 的源文件，源文件就按照正常的 markdown 语法写，然后我们在读取的时候，遇到lang的时候，把文本提取出来，然后交给负责渲染的库渲染成 dom 文本，我选择的是highlight.js这个库。然后把原来的文本替换掉，单独输出在新的文件夹里，比如原来的叫文件夹叫 src，新的叫 out。这样的话源文件不需要任何修改，然后实际渲染的是 out 文件夹里面的内容就好了。每次我们更改完源文件，运行一下这个程序做一下转换就行了。\n什么是Code Generation # 其实上面的案例就是一个典型的使用『代码生成』也即 code generation 解来决问题的案例。那究竟什么是代码生成呢？这其实也是一个含义相当广泛的词汇。一般来说\n代码生成是指是指通过使用计算机程序来生成其他程序或代码的过程\n包括但不限于：\n编译器生成目标代码： 这是最典型的例子，其中编译器将高级编程语言的源代码翻译成机器可执行的目标代码 使用配置文件或 DSL 生成代码：通过特定的配置文件或领域特定语言 (DSL)，生成实际的代码。一个示例是使用 XML 配置文件来定义 UI 界面，然后生成相应的代码 语言内建特性生成代码： 一些编程语言具有内建的特性，如宏、泛型等，可以在编译时或运行时生成代码。这样的机制可以提高代码的灵活性和重用性。 外部代码生成器： 某些框架或库使用外部代码生成器来创建所需的代码。例如，Qt 框架使用元对象编译器 (MOC) 来处理元对象系统，生成与信号和槽相关的代码。 下面就这几点来举一些具体的例子：\n编译时代码生成 # 宏 # C 语言的 marcomacro 就是一种最经典，也最简单的编译期代码生成技术。纯文本替换，比如我们想重复\u0026quot;Hello World\u0026quot;这个字符串 100 次。那怎么办呢？显然我们不想手动粘贴复制。考虑使用宏来完成这个工作\n#define REPEAT(x) (REPEAT1(x) REPEAT1(x) REPEAT1(x) REPEAT1(x) REPEAT1(x)) #define REPEAT1(x) REPEAT2(x) REPEAT2(x) REPEAT2(x) REPEAT2(x) REPEAT2(x) #define REPEAT2(x) x x x x int main(){ const char* str = REPEAT(\u0026#34;Hello world \u0026#34;); } 这里主要运用了 C 语言中的一个特性就是\u0026quot;a\u0026quot;\u0026quot;b\u0026quot;等价于\u0026quot;ab\u0026quot;。然后通过宏展开5*5*4刚好一百次，然后就轻松的完成了这个任务。 当然了C语言的宏由于其本质上只是 Token 替换，而且不允许使用者获取 Token 流进行输入分析，所以功能十分有限。尽管如此，还是有一些比较有意思的用法的。感兴趣的可以阅读下这篇文章C/C++ 宏编程的艺术。当然了宏可不止C语言有，其它的编程语言也是有的，而且还可以支持更强的特性。例如 Rust 中的宏灵活性就比C语言强很多，关键就在于 Rust 允许你对输入的 Token Stream 进行分析，而不是简简单单的执行替换了，你可以根据输入 Token 的不同选择生成不同的代码。更有甚者像 Lisp 中的宏就超级灵活了。\n泛型/模板 # 在一些编程语言中**泛型 (Generic) **也被看作是一种代码生成的技术，根据不同的类型生成实际不同的代码。当然这是最基础的了，一些编程语言还支持更强大的特性，比如在C++中还可以通过模板元编程进行一些高级的代码生成。典型的案例是在编译期打一个函数指针表（跳转表）\ntemplate\u0026lt;std::size_t N, typename T, typename F\u0026gt; void helper(T t, F f) { f(std::get\u0026lt;N\u0026gt;(t)); } template\u0026lt;typename Tuple, typename Func\u0026gt; constexpr void access(std::size_t index, Tuple\u0026amp;\u0026amp; tuple, Func\u0026amp;\u0026amp; f){ constexpr auto length = std::tuple_size\u0026lt;std::decay_t\u0026lt;decltype(tuple)\u0026gt;\u0026gt;::value; using FuncType = void (*)(decltype(tuple), decltype(f)); constexpr auto fn_table = []\u0026lt;std::size_t... I\u0026gt;(std::index_sequence\u0026lt;I...\u0026gt;){ std::array\u0026lt;FuncType, length\u0026gt; table = { helper\u0026lt;I, decltype(tuple), decltype(f)\u0026gt;... }; return table; }(std::make_index_sequence\u0026lt;length\u0026gt;{}); return fn_table[index](std::forward\u0026lt;Tuple\u0026gt;(tuple), std::forward\u0026lt;Func\u0026gt;(f)); } int main(){ std::tuple a = { 1, \u0026#39;a\u0026#39;, \u0026#34;123\u0026#34; }; auto f = [](auto\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }; std::size_t index = 0; access(index, a, f); // =\u0026gt; 1 index = 2; access(index, a, f); // =\u0026gt; 123 } 这样我们就实现了根据运行期的index来访问tuple中的元素的效果了，具体原理就是手动打了一个函数指针表，然后根据索引来进行分派。\n代码生成器 # 上面两点说的都是语言内建的特性。然而在很多场景，语言内置的特性，不够灵活，并不能满足我们的需求。比如在C++中想整块整块的生成函数和类型，那么无论是宏还是模板都做不到。\n但是代码就是源文件中的字符串而已，基于这一点想法。我们完全可以编写一个专门的程序用来生成这样的字符串。例如写一个python代码来生成上面那个100次Hello World的C程序\ns = \u0026#34;\u0026#34;; for i in range(100): s += \u0026#39;\u0026#34;Hello World \u0026#34;\u0026#39; code = f\u0026#34;\u0026#34;\u0026#34; int main() {{ const char* str = {s}; }}\u0026#34;\u0026#34;\u0026#34; with open(\u0026#34;hello.c\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(code) 好了，这样的话就生成了上面那个源文件。当然这只是最简单的应用。亦或者我们可以用Protocol Buffer来进行自动生成序列化和反序列化的代码。又或者我们可以从AST中获取信息，连类型的元信息都由代码生成器生成，这种程序的原理很简单，就是字符串拼接，而它的上限完全取决于你的代码是怎么写的。\n但是更多时候还是语言内建的特性使用的更加方便一些，使用外部的代码生成器会让编译流程变得复杂一些。然而也有一些语言，将这个特性作为了语言内置的特性之一，比如C#的code generation。\n运行期代码生成 # exec # 好了，说了很多静态语言的特征。接下来让我们来看看足够动态的代码生成。 首先向我们走来的是Python/JavaScript等语言中的eval和exec等特性，这些特性允许我们在运行期直接把字符串加载为了代码并执行\neval是一种将字符串解析为可执行代码的机制。在Python中，eval函数可以接受一个字符串作为参数，并执行其中的表达式，返回结果。这为动态计算和代码生成提供了强大的工具。 result = eval(\u0026#34;2 + 3\u0026#34;) print(result) # 输出: 5 exec与eval不同的是，exec可以执行多个语句，甚至包含函数和类的定义。 Copy code code_block = \u0026#34;\u0026#34;\u0026#34; def multiply(x, y): return x * y result = multiply(4, 5) \u0026#34;\u0026#34;\u0026#34; exec(code_block) print(result) # 输出: 20 毫无疑问，仅仅通过字符串拼接就能在运行期生成代码，在合适的场景使用它们，可以轻松完成一些比较苛刻的需求。\n动态编译 # 现在有一个问题，C语言能做到上面的动态编译特性吗？当然你可能会说我们可以实现一个C语言的解释器，那自然不就行了。但其实其实有更简单的办法。\n主要有两点：\n运行期编译代码 如果你的电脑上装了gcc，则可以通过下面运行两条命令\n# 将源文件编译成目标文件 gcc -c source.c source.o # 将目标文件中的.text段提取出来，生成二进制文件 objcopy -O binary -j .text source.o source.bin 通过这样的方式就能获取source.c文件中代码的二进制形式了，但是光有代码还不行，我们需要执行它。\n**申请可执行内存 ** 代码也是二进制数据，只要把刚才得到的代码数据写入一块内存，然后jmp过去执行不就行了？想法很直接，但是很遗憾，大多数操作系统对内存都是有保护的，一般的申请内存是不可执行的。如果尝试写入数据然后执行则会直接段错误。但是我们可以通过VirtualAlloc或者mmap来申请一块有执行权限内存，然后把代码写入进去，再执行就行了。\n// Windows VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Linux mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); 结合这两点然后稍作处理，就可以实现从命令行读取代码和输入，然后直接运行输出结果了\n#include \u0026lt;fstream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #ifdef _WIN32 #include \u0026lt;Windows.h\u0026gt; #define Alloc(size) VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) #elif __linux__ #include \u0026lt;sys/mman.h\u0026gt; #define Alloc(size) mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) #endif int main(int argc, char* argv[]) { std::ofstream(\u0026#34;source.c\u0026#34;) \u0026lt;\u0026lt; argv[1]; system(\u0026#34;gcc -c source.c \u0026amp;\u0026amp; objcopy -O binary -j .text source.o source.bin\u0026#34;); std::ifstream file(\u0026#34;source.bin\u0026#34;, std::ios::binary); std::string source((std::istreambuf_iterator\u0026lt;char\u0026gt;(file)), {}); auto p = Alloc(source.size()); memcpy(p, source.c_str(), source.size()); using Fn = int (*)(int, int); std::cout \u0026lt;\u0026lt; reinterpret_cast\u0026lt;Fn\u0026gt;(p)(std::stoi(argv[2]), std::stoi(argv[3])) \u0026lt;\u0026lt; std::endl; return 0; } 最后的效果\n.\\main.exe \u0026#34;int f(int a, int b){ return a + b; }\u0026#34; 1 2 # output: 3 .\\main.exe \u0026#34;int f(int a, int b){ return a - b; }\u0026#34; 1 2 # output: -1 完美实现\n结束 # 本文主要介绍了代码生成的一些基本概念和示例，以及一些简单的应用。代码生成是一种非常强大的技术，如果仅仅把眼光局限在编程语言内建的特性，很多时候我们无法完成一些复杂的需求，如果将眼光放宽广一些，则会意外发现新世界。这是反射系列文章中的一篇，欢迎阅读系列其它文章！\nYKIKO：写给 C++ 程序员的反射教程 https://www.ykiko.me/articles/669358870\n","date":"November 29, 2023","externalUrl":null,"permalink":"/articles/669359855/","section":"Articles","summary":"引入 # 刚好拿最近的一个需求作为引入吧。我们都知道 markdown 可以用la","title":"各种姿势进行代码生成","type":"articles"},{"content":" What is Reflection? # 反射 (Reflection) 这个词相信大家都不陌生了，也许你没用过但是你一定听过。然而，就像 CS 领域很多其它的惯用词一样，对于反射，并没有一个清晰而准确的定义。于是就会出现这种情况：对于 C#, Java, Python 这些拥有反射的语言，谈论到反射可以很自然的联想到对应语言中相关的设施，API 和代码示例，非常的具体。而对于 C, C++, Rust 这些没有反射的语言，当谈论起反射的时候，大家都不确定对方指的是什么，非常的不具体。比如有人问告诉我说 Rust 有反射，他给出的例子是 Rust 的官方的文档中对 std::Any 模块 的介绍。里面提到了\nUtilities for dynamic typing or type reflection 用于动态类型或类型反射的工具\n但是尴尬就尴尬在，你说它是反射吧，功能非常鸡肋，你说它不是吧，硬要说有这种体现也不是不行。\n类似的情况在 C++ 中也经常发生。相信你也经常能听到如下观点：C++ 只有非常弱的反射即 RTTI(Run Time Type Information)，但是 C++ 的一些框架比如 QT，UE 自己实现了反射。在最近的讨论中，网上的博客中又或者 C++ 新标准的提案中，你可能又会听到所谓：\n静态反射 (static reflection) 动态反射 (dynamic reflection) 编译期反射 (compile time reflection) 运行期反射 (runtime reflection) 这样一大堆名词实在是让人听的云里雾里，晕头转向。而且 static, dynamic, compile time, runtime 这些前缀词本身也都是惯用词，经常和各种词组合起来，于语境不同有非常多的含义。\n有的读者可能会说，我查了 WIKI，反射 明明就是有定义的啊，如下：\nIn computer science, reflective programming or reflection is the ability of a process to examine, introspect, and modify its own structure and behavior. 反射是程序具有自省，检查和修改它自身结构和行为的一种能力。\n那首先，WIKI 也是人写的，不具有绝对的权威性，如果你对这个定义不满意，是可以自己修改的。其次这里的用词也是很模糊的，什么叫自省 (introspect)？自我反省，在 CS 中这个词又是什么意思呢？所以这个定义也是很尴尬的。那怎么办呢？我选择把它拆分成几个过程进行解释，这样我们就不用去纠结「反射究竟是什么」这个概念问题了。取而代之的是，弄明白了这几个过程，自然而然的你就明白反射是在做什么事情了。\nHow to Understand Reflection? # 所有语言的反射都可以看成下面这三步：\nGenerate Metadata # 首先什么是元数据 (Metadata) 呢？我们在写代码的时候都会给变量，类型，结构体字段什么的取名字。这些名字主要是为了方便程序员理解和维护源代码。对于 C/C++ 来说，这些名字在编译之后通常会被丢弃，为了节省二进制空间嘛，可以理解。详细的讨论请见 为什么说 C/C++编译器不保留元信息。\n但是渐渐地，我们发现某些情况下是需要这些数据的。比如把结构体序列化成json的时候就需要结构体字段名，在打印日志的时候不希望打印枚举值，而是直接打印对应的枚举名。怎么办呢？早期，只能通过 hard code 的方式，也就是手写，高级点的可能来点宏。这样其实是很不方便的，不利于后续的代码维护。\n后来有一些语言，例如 Java 和 C#。他们的编译器在编译的时候会保留包括这些名字在内的很多数据，这些数据就叫做元数据（Metadata）。同时，也有一些手段允许程序员自己附加元数据在某些结构上，例如 C# 的attribute，Java 的annotation。\n对于 C++ 来说呢？目前 C++ 编译器只会保留类型名用于实现 RTTI，即标准中std::type_info的相关设施。其它的信息，编译器都会抹除掉。怎么办呢？手动编写元数据对于少量的类来说还可以接受，但当项目规模增大时，例如有几十或上百个类时，将变得非常繁琐和容易出错。其实，我们可以在实际编译运行一个脚本来负责生成这些数据，也就是所谓的代码生成 (Code Generation)。相关内容请参考 使用 clang 工具自由的支配 C++ 代码吧。\nQuery Metadata # 生成完之后，接下来就是查询元数据了。很多语言内置的反射模块，例如 Python 的inspect，Java 的Reflection，C# 的System.Reflection，其实就是封装了一些操作，使得用户不用直接接触原始的元数据，用起来更加方便。\n值得注意的是，上面这些案例中的查询都是发生在运行时的。在运行时根据字符串进行搜索和匹配，这其实是一个比较慢的过程，所以我们常说反射调用方法比正常调用方法慢。\n对于 C++ 来说，编译器提供了一些有限的接口让我们在编译时访问（反射）一些信息，例如使用decltype可以获取一个变量的类型，进一步还能判断两个变量类型是否相等，是否是某个类型的子类等等，但是功能十分有限。\n不过，可以按照上一小节的方法自己生成元信息，把它们都标记为 constexpr，然后就可以在编译期进行查询。事实上 C++26 的静态反射也就是这个思路，由编译器生成元信息，暴露给用户一些接口进行查询。相关内容请见 C++26 静态反射提案解析。而查询的时机也就是所谓的动态反射和静态反射的区别。\n当然了，编译期可做的事情肯定是没有运行期那么多的，例如希望根据运行时的类型名创建类实例，无论如何编译期肯定没法做到。但你可以基于这些静态的元信息构建动态反射。相关内容请见 在 C++ 中实现 Object。\nOperate Metadata # 然后，就是根据元数据进行进一步的操作，比如代码生成。这个在 C++ 中可以理解为编译期的代码生成，在 Java 和 C# 则可以认为是运行期的代码生成。详见 各种姿势进行代码生成 。\nConclusion # 最后，我们来用上面三个步骤分解一下不同语言中的反射：\nPython, JavaScript, Java, C#：由编译器/解释器生成元数据，标准库提供接口，用户可以在运行时查询元数据，同时由于有虚拟机（VM），可以方便地生成代码。 Go：由编译器生成元数据，标准库提供接口，用户可以在运行时查询元数据。但是由于 Go 主要是 AOT（Ahead-of-Time）编译，运行时生成代码并不方便。 Zig, C++26 静态反射：由编译器生成元数据，标准库提供接口，用户可以在编译时查询元数据。同样由于是 AOT 编译，运行时生成代码并不方便，但是可以在编译期进行代码生成。\n而 QT 和 UE 则是通过代码生成，自己生成了元数据，封装了接口，用户可以在运行时查询元数据。实现原理上类似 Go 的反射。\n希望这个系列教程对你有所帮助！如果有错误欢迎评论区讨论，感谢你的阅读。\n","date":"November 29, 2023","externalUrl":null,"permalink":"/articles/669358870/","section":"Articles","summary":"What is Reflection? # 反射 (Reflection) 这个词相信大家都不陌生了，也许你没用过但是你一","title":"写给 C++ 程序员的反射教程","type":"articles"},{"content":"最近打算写一个系列文章详细讨论反射（reflection）这一概念，刚好 C++26 有了新的反射提案，发现知乎上又没有相关的文章，而这个话题又经常被讨论。所以借此机会来聊一聊属于 C++ 的静态反射（static reflection），作为系列预热了。\nwhat is static reflection? # 首先反射是指什么呢？这个词就像计算机科学领域很多其他的惯用词一样，并没有详细而准确的定义。关于这个问题，我不打算在这个文章讨论，后续的文章我会详细的解释。本文的重点是 C++ 的 static reflection，为什么强调 static 呢？主要是因为平常我们谈论到反射的时候几乎总是指 Java，C#，Python 这些语言中的反射，而它们的实现方式无一不是把类型擦除，在运行期进行信息的查询。这种方式当然有不可避免的运行时开销，而这种开销显然是违背了 C++ zero cost abstraction 的原则的。为了和它们的反射区分开来，故加上 static 作为限定词，也指示了 C++ 的反射是在编译期完成的。当然，这种说法仍然缺乏一些严谨性。详细的讨论在后续的文章给出，你只需要知道 C++ 的静态反射和 Java，C#，Python 的反射不同，并且主要是在编译期完成的就行了。\nwhat can static reflection do? # type as value # 我们都知道随着 C++ 版本的不断更新，编译期计算的功能在不断的增强，通过constexpr/consteval函数我们能很大程度上直接复用运行期的代码，方便的进行编译期计算。完全取代了很久之前使用模板元进行编译期计算的方法。不仅写起来更加方便，编译速度也更快。\n观察下面几段编译期计算阶乘的代码：\n在 C++03/98 的时候，我们只能通过模板递归实例化来实现，而且无法将代码复用到运行期\ntemplate\u0026lt;int N\u0026gt; struct factorial { enum { value = N * factorial\u0026lt;N - 1\u0026gt;::value }; }; template\u0026lt;\u0026gt; struct factorial\u0026lt;0\u0026gt; { enum { value = 1 }; }; C++11 中第一次引入了constexpr函数的概念，使得我们可以编写编译期和运行期复用的代码。但是限制很多，没有变量和循环，我们只能按照纯函数式的风格来编写代码\nconstexpr int factorial(int n) { return n == 0 ? 1 : n * factorial(n - 1); } int main() { constexpr std::size_t a = factorial(5); // 编译期计算 std::size_t\u0026amp; n = *new std::size_t(6); std::size_t b = factorial(n); // 运行期计算 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; } 随着 C++14/17 的到来，constexpr函数中的的限制被进一步放开，现在能在 constexpr 函数中使用局部变量和循环了，就像下面这样\nconstexpr std::size_t factorial(std::size_t N) { std::size_t result = 1; for (std::size_t i = 1; i \u0026lt;= N; ++i) { result *= i; } return result; } C++20 之后，我们还可以在编译期使用new/delete，我们可以在编译期代码里面使用vector。很多运行期的代码可以直接在编译期复用，而不需要任何更改，只需要在函数前面加上一个 constexpr 标记，再也不用为了进行编译期计算而使用晦涩难懂的模板元编程了。但是，上面的示例仅仅适用于 value，在 C++ 里面除了 value 还有 type 和 higher kind type\ntemplate\u0026lt;typename ...Ts\u0026gt; struct type_list; template\u0026lt;typename T, typename U, typename ...Ts\u0026gt; struct find_first_of { constexpr static auto value = find_first_of\u0026lt;T, Ts...\u0026gt;::value + 1; }; template\u0026lt;typename T, typename ...Ts\u0026gt; struct find_first_of\u0026lt;T, T, Ts...\u0026gt; { constexpr static std::size_t value = 0; }; static_assert(find_first_of\u0026lt;int, double, char, int, char\u0026gt;::value == 2); 由于 type 和 higher kind type 只能是 template arguments，所以还是只能通过模板递归匹配处理它们。要是我们能像 value 一样操作它们就好了，这样的话 constexpr 函数也能处理它们了。但是 C++ 又不是像 Zig 那样的语言，type is value。怎么办呢？没关系，我们把 type 映射到 value 不就行了？实现 type as value 的效果。在静态反射加入之前，我们可以通过一些 trick 来实现这个效果。可以在编译期把类型映射到类型名，于是只要对类型名进行计算就好了。关于如何进行这种映射，可以参考 C++ 中如何优雅进行 enum 到 string 的转换。\ntemplate\u0026lt;typename ...Ts\u0026gt; struct type_list{}; template\u0026lt;typename T, typename ...Ts\u0026gt; constexpr std::size_t find(type_list\u0026lt;Ts...\u0026gt;) { // type_name 用于获取编译期类型名 std::array arr{ type_name\u0026lt;Ts\u0026gt;()... }; for(auto i = 0; i \u0026lt; arr.size(); i++) { if(arr[i] == type_name\u0026lt;T\u0026gt;()) { return i; } } } 非常直观的代码，但是如果我们想把值映射回类型就比较困难了。不过没关系，在即将到来的 static reflection 中，这种类型和值的双向映射已经成为语言特性了，我们不再需要去手动处理了。\n使用^运算符将类型映射到值\nconstexpr std::meta::info value = ^int; 使用[: ... :]将它映射回去，注意这是 symbol 级别的映射\nusing Int = typename[:value:]; // 在此语境下，typename 可以省略 typename[:value:] a = 3; // 相当于 int a = 3; 现在我们就能写出下面这样的代码了。\ntemplate\u0026lt;typename ...Ts\u0026gt; struct type_list { constexpr static std::array types = {^Ts...}; template\u0026lt;std::size_t N\u0026gt; using at = typename[:types[N]:]; }; using Second = typename type_list\u0026lt;int, double, char\u0026gt;::at\u0026lt;1\u0026gt;; static_assert(std::is_same_v\u0026lt;Second, double\u0026gt;); 再也不用递归匹配了，我们可以把类型像值一样计算。只要理解了这种映射关系，代码写起来非常简单。用于类型计算的模板元可以退出历史舞台了！\n其实^其实不仅能够映射类型，主要有下面这些功能:\n^:: —— 代表全局命名空间 ^namespace-name—— 命名空间名称 ^type-id—— 类型 ^cast-expression —— 特殊表达式，目前包括包括： 表示函数或者成员函数的主表达式 表示变量，静态成员变量，结构化绑定的主表达式 表示非静态成员的主表达式 表示模板的主表达式 常量表达式 同样的[: ... :]也能还原成对应的东西，注意是还原到对应的符号，所以这个运算符被叫做，拼接器（Splicers）\n[: r :] —— 还原成对应的实体或者表达式 typename[: r :] —— 还原成对应的类型 template[: r :] —— 还原成模板参数 namespace[: r :] —— 还原成命名空间 [:r:]:: —— 还原成对应的命名空间，类，枚举嵌套说明符 看下面的使用示例\nint x = 0; void g() { [:^x:] = 42; // Okay. Same as: x = 42; x = [:^(2 * x):]; // Error: \u0026#34;2 * x\u0026#34; is a general non-constant expression constexpr int N = 42; x = [:^(2 * N):]; // Okay: \u0026#34;2 * N\u0026#34; is a constant-expression } 如果还原的东西和原本储存的不一样，则会编译错误\ntypename[: ^:: :] x = 0; // Error metainfo # 光是上面一个特性，就足以让人心动了。然而远远不止如此，获取class等实体元信息的功能也有了。\n最基础的，获取类型名（变量名，字段名都可以用这个函数）\nnamespace std::meta { consteval auto name_of(info r) -\u0026gt; string_view; consteval auto display_name_of(info r) -\u0026gt; string_view; } 比如可以\ndisplay_name_of(^std::vector\u0026lt;int\u0026gt;) // =\u0026gt; std::vector\u0026lt;int\u0026gt; name_of(^std::vector\u0026lt;int\u0026gt;) // =\u0026gt; std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt;\u0026gt; 判断一个模板是不是另一个高阶模板的特化 和 萃取高阶模板里面的参数\nnamespace std::meta { consteval auto template_of(info r) -\u0026gt; info; consteval auto template_arguments_of(info r) -\u0026gt; vector\u0026lt;info\u0026gt;; } std::vector\u0026lt;int\u0026gt; v = {1, 2, 3}; static_assert(template_of(type_of(^v)) == ^std::vector); static_assert(template_arguments_of(type_of(^v))[0] == ^int); 把模板参数填到高阶模板中去\nnamespace std::meta { consteval auto substitute(info templ, span\u0026lt;info const\u0026gt; args) -\u0026gt; info; } constexpr auto r = substitute(^std::vector, std::vector{^int}); using T = [:r:]; // Ok, T is std::vector\u0026lt;int\u0026gt; 获取struct,class，,union,enum的成员信息\nnamespace std::meta { template\u0026lt;typename ...Fs\u0026gt; consteval auto members_of(info class_type, Fs ...filters) -\u0026gt; vector\u0026lt;info\u0026gt;; template\u0026lt;typename ...Fs\u0026gt; consteval auto nonstatic_data_members_of(info class_type, Fs ...filters) -\u0026gt; vector\u0026lt;info\u0026gt; { return members_of(class_type, is_nonstatic_data_member, filters...); } template\u0026lt;typename ...Fs\u0026gt; consteval auto bases_of(info class_type, Fs ...filters) -\u0026gt; vector\u0026lt;info\u0026gt; { return members_of(class_type, is_base, filters...); } template\u0026lt;typename ...Fs\u0026gt; consteval auto enumerators_of(info class_type, Fs ...filters) -\u0026gt; vector\u0026lt;info\u0026gt;; template\u0026lt;typename ...Fs\u0026gt; consteval auto subobjects_of(info class_type, Fs ...filters) -\u0026gt; vector\u0026lt;info\u0026gt;; } 待会用这个我们就可以实现遍历结构体，枚举等功能。进一步就可以实现序列化，反序列化等高级功能。后文会有一些示例。除此之外，还有一些其它的功能的编译期函数，上面只展示了一部分内容，更多的 API 可以参考提案中的内容。由于提供了直接获取高级模板里面参数的函数，再也不用用模板去进行类型萃取了！用于类型萃取的模板元也可以退出历史舞台了。\nbetter compile facilities # 反射的主题部分大致已经介绍完了，现在来聊聊其它的。虽然这部分是其它提案的内容，但是他们可以使代码写起来更见轻松，让代码有更强的表达能力。\ntemplate for # 在 C++ 里面如何生成大量的代码段是一个非常不好解决的问题，得益于 C++ 独（逆）特（天）的机制，目前的代码片段生成几乎都是基于 lambda 表达式 + 可变参数包展开。看下面的例子\nconstexpr auto dynamic_tuple_get(std::size_t N, auto\u0026amp; tuple) { constexpr auto size = std::tuple_size_v\u0026lt;std::decay_t\u0026lt;decltype(tuple)\u0026gt;\u0026gt;; [\u0026amp;]\u0026lt;std::size_t ...Is\u0026gt;(std::index_sequence\u0026lt;Is...\u0026gt;) { auto f = [\u0026amp;]\u0026lt;std::size_t Index\u0026gt; { if(Index == N) { std::cout \u0026lt;\u0026lt; std::get\u0026lt;Index\u0026gt;(tuple) \u0026lt;\u0026lt; std::endl; } }; (f.template operator()\u0026lt;Is\u0026gt;(), ...); }(std::make_index_sequence\u0026lt;size\u0026gt;{}); } int main() { std::tuple tuple = {1, \u0026#34;Hello\u0026#34;, 3.14, 42}; auto n1 = 0; dynamic_tuple_get(n1, tuple); // 1 auto n2 = 3; dynamic_tuple_get(n2, tuple); // 42 } 一个很经典的例子，原理是通过多个分支判断，将运行期变量分发到编译期常量。实现根据运行期的index来访问tuple里面的元素。注：这里效率更高的办法是，编译期生成一个函数指针数组，然后直接根据index进行跳转，不过这里只是做个展示，不用纠结太多。\n上面的代码展开后相当于\nconstexpr auto dynamic_tuple_get(std::size_t N, auto\u0026amp; tuple) { if(N == 0) { std::cout \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(tuple) \u0026lt;\u0026lt; std::endl; } // ... if(N == 3) { std::cout \u0026lt;\u0026lt; std::get\u0026lt;3\u0026gt;(tuple) \u0026lt;\u0026lt; std::endl; } } 可以发现，我们用了极其别扭的写法只是为了实现极其简单的效果。而且由于 lambda 其实是个函数，其实没法直接从 lambda 里面直接返回到上一级函数。导致我们多做了很多多余的if判断。\n换成template for则代码看起来清爽很多\nconstexpr void dynamic_tuple_get(std::size_t N, auto\u0026amp; tuple) { constexpr auto size = std::tuple_size_v\u0026lt;std::decay_t\u0026lt;decltype(tuple)\u0026gt;\u0026gt;; template for(constexpr auto num : std::views::iota(0, size)) { if(num == N) { std::cout \u0026lt;\u0026lt; std::get\u0026lt;num\u0026gt;(tuple) \u0026lt;\u0026lt; std::endl; return; } } } 可以认为template for是 lambda 展开的语法糖加强版，反正非常好用就是了。如果这个加入了，利用模板元生成函数（代码）就可以退休了。\nnon-transient constexpr allocation # 这个提案主要是将两个问题联合起来讨论了。\nC++ 可以通过控制模板实例化 static 成员在数据段预留位置，可以看作编译期内存分配 template\u0026lt;auto... items\u0026gt; struct make_array { using type = std::common_type_t\u0026lt;decltype(items)...\u0026gt;; static inline type value[sizeof ...(items)] = {items...}; }; template\u0026lt;auto... items\u0026gt; constexpr auto make_array_v = make_array\u0026lt;items...\u0026gt;::value; int main() { constexpr auto arr = make_array_v\u0026lt;1, 2, 3, 4, 5\u0026gt;; std::cout \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; std::endl; //成功在数据段预留位置，存放的是 1 2 3 4 5 } C++20 允许了constexpr中进行new，但是编译期new的内存必需要在编译期delete。 constexpr auto size(auto... Is) { std::vector\u0026lt;int\u0026gt; v = {Is...}; return v.size(); } 那就不能在编译期new里之后，不delete？实际数据放在数据段？这就是这个提案要解决的问题，它希望我们能使用\nconstexpr std::vector\u0026lt;int\u0026gt; v = {1, 2, 3, 4, 5}; // 全局的 主要难点是，在数据段分配的内存不像在堆上的内存一样有所有权，不需要delete。只要解决了这个问题，就能使用编译期的std::map，std::vector并且保留到运行期。这个作者的做法是进行标记。具体的细节这里就不说了。如果这个加入了，利用模板元打常量表也可以退出了。\ndo something fun # 好了，上面说了那么多，让我们用它们来做些有趣的东西！\nprint any type # template\u0026lt;typename T\u0026gt; constexpr auto print(const T\u0026amp; t) { template for(constexpr auto member : nonstatic_data_members_of(type_of(^t))) { if constexpr (is_class(type_of(member))) { // 如果是 class 就递归遍历成员 println(\u0026#34;{}= \u0026#34;, name_of(member)); print(t.[:member:]); } else { //非类类型可以直接打印 std::println(\u0026#34;{}= {}\u0026#34;, name_of(member), t.[:member:]); } } } enum to string # template \u0026lt;typename E\u0026gt; requires std::is_enum_v\u0026lt;E\u0026gt; constexpr std::string enum_to_string(E value) { template for (constexpr auto e : std::meta::members_of(^E)) { if (value == [:e:]) { return std::string(std::meta::name_of(e)); } } return \u0026#34;\u0026lt;unnamed\u0026gt;\u0026#34;; } conclusion # 花费了很长的篇幅介绍 C++ 的 static reflection。其实我非常喜欢 C++ 的编译期计算，对它的发展史也非常感兴趣。C++ 的编译期计算是一步步摸索出来的，有很多富有智慧的大师提出他们的独特想法，让不可能的事情变成现实。从 C++03 的变态模板元，到 C++11 的constexpr变量，到 C++14 ~23 对constexpr函数中的限制逐渐放开，把越来越多的操作移到编译期。再到如今的 static reflection，C++ 正在逐步脱离模板元的魔爪。之前那些老旧的模板元写法全都可以淘汰掉了！！！如果你没写过以前的老式模板元代码，大概是体会不到它有多可怕的。\n为了让静态反射能早点进入标准，作者团队特地选了原本提案的一部分核心子集。希望如作者所愿，静态反射能在 C++26 进入标准！当然，核心部分先进入，之后再补充更多更加有用的功能，所以这绝不是反射的全部内容。本文只是对该提案的粗略解读和翻译，想要详细了解的还请阅读下方链接中的提案，相关进展持续更新中：\nReflection for C++26 - P2996R0 https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html#ref-P2670R1\nReflection for C++26 - P2996R1 https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r1.html\nReflection for C++26 - P2996R2 https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2024/p2996r2.html\nReflection for C++26 - P2996R3 https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r3.html\n实验编译器：\n在线尝试： https://godbolt.org/z/13anqE1Pa 本地构建： clang-p2996 反射系列文章：\nhttps://www.ykiko.me/articles/669358870\n","date":"October 16, 2023","externalUrl":null,"permalink":"/articles/661692275/","section":"Articles","summary":"最近打算写一个系列文章详细讨论反射（reflection）这","title":"C++26 静态反射提案解析","type":"articles"},{"content":" Introduction # 在 C++ 中，形如\u0026amp;T::name的表达式返回的结果就是成员指针。写代码的时候偶尔会用到，但是这个概念可能很多人都并不熟悉。考虑如下代码\nstruct Point { int x; int y; }; int main() { Point point; *(int*)((char*)\u0026amp;point + offsetof(Point, x)) = 20; *(int*)((char*)\u0026amp;point + offsetof(Point, y)) = 20; } 在 C 语言中，我们经常通过这样计算 offset 的方式来访问结构体成员。如果把它封装成函数，还能用来根据传入的参数动态访问结构体的成员变量。然而上面的代码在 C++ 中是 undefined behavior，具体的原因可以参考 Stack Overflow 上的这个讨论。但是如果我们确实有这样需求，那该怎么合法的实现需求呢？C++ 为我们提供了一层抽象：pointers to members，用来合法进行这样的操作。\nUsage # pointer to data member # 一个指向类C非静态成员m的成员指针可以用\u0026amp;C::m进行初始化。当在C的成员函数里面使用\u0026amp;C::m会出现二义性。即既可以指代对m成员取地址\u0026amp;this-\u0026gt;m，也可以指代成员指针。为此标准规定，\u0026amp;C::m表示成员指针，\u0026amp;(C::m)或者\u0026amp;m表示对m成员取地址。可以通过运算符.*和-\u0026gt;*来访问对应的成员。示例代码如下\nstruct C { int m; void foo() { int C::*x1 = \u0026amp;C::m; // pointer to member m of C int* x2 = \u0026amp;(C::m); // pointer to member this-\u0026gt;m } }; int main() { int C::*p = \u0026amp;C::m; // type of a member pointer is: T U::* // T is the type of the member, U is the class type // here, T is int, U is C C c = {7}; std::cout \u0026lt;\u0026lt; c.*p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // same as c.m, print 7 C* cp = \u0026amp;c; cp-\u0026gt;m = 10; std::cout \u0026lt;\u0026lt; cp-\u0026gt;*p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // same as cp-\u0026gt;m, print 10 } 指向基类的数据成员指针 可以隐式转换成 非虚继承的 派生类数据成员指针 struct Base { int m; }; struct Derived1 : Base {}; // non-virtual inheritance struct Derived2 : virtual Base {}; // virtual inheritance int main() { int Base::*bp = \u0026amp;Base::m; int Derived1::*dp = bp; // ok, implicit cast int Derived2::*dp2 = bp; // error Derived1 d; d.m = 1; std::cout \u0026lt;\u0026lt; d.*dp \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; d.*bp \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // ok, prints 1 1 } 根据传入的指针，动态访问结构体字段 struct Point { int x; int y; }; auto\u0026amp; access(Point\u0026amp; point, auto pm) { return point.*pm; } int main() { Point point; access(point, \u0026amp;Point::x) = 10; access(point, \u0026amp;Point::y) = 20; std::cout \u0026lt;\u0026lt; point.x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; point.y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 10 20 }} pointer to member function # 一个指向非静态成员函数f的成员指针可以用\u0026amp;C::f进行初始化。由于不能对非静态成员函数取地址，\u0026amp;(C::f)和\u0026amp;f什么都不表示。类似的可以通过运算符.*和-\u0026gt;*来访问对应的成员函数。如果成员函数是重载函数，想要获取对应的成员函数指针，请参考 如何获取重载函数的地址。示例代码如下\nstruct C { void foo(int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } }; int main() { using F = void(int); // function type using MP = F C::*; // pointer to member function using T = void (C::*)(int); // pointer to member function static_assert(std::is_same_v\u0026lt;MP, T\u0026gt;); auto mp = \u0026amp;C::foo; T mp2 = \u0026amp;C::foo; static_assert(std::is_same_v\u0026lt;decltype(mp), T\u0026gt;); C c; (c.*mp)(1); // call foo, print 1 C* cp = \u0026amp;c; (cp-\u0026gt;*mp)(2); // call foo, print 2 } 指向基类的成员函数指针 可以隐式转换成非虚继承的派生类成员函数指针 struct Base { void f(int) {} }; struct Derived1 : Base {}; // non-virtual inheritance struct Derived2 : virtual Base {}; // virtual inheritance int main() { void (Base::*bp)(int) = \u0026amp;Base::f; void (Derived1::*dp)(int) = bp; // ok, implicit cast void (Derived2::*dp2)(int) = bp; // error Derived1 d; (d.*dp)(1); // ok } 根据传入参数动态调用成员函数 struct C { void f(int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl;} void g(int x) { std::cout \u0026lt;\u0026lt; x + 1 \u0026lt;\u0026lt; std::endl;} }; auto access(C\u0026amp; c, auto pm, auto... args){ return (c.*pm)(args...); } int main(){ C c; access(c, \u0026amp;C::f, 1); // 1 access(c, \u0026amp;C::g, 1); // 2 } Implementation # 首先要明确的是，C++ 标准并没有规定成员指针是什么实现的。在这一点上和虚函数一样，即标准没有规定虚函数是怎么实现的，只规定了虚函数的行为。所以成员指针相关的实现完全是 implementation defined。本来只需要了解怎么使用就足够了，不要关心底层实现。但是奈何网络上相关话题的错误文章太多了，已经严重的产生了误导，所以有必要进行澄清。\n对于三大主流编译器，GCC 遵循 Itanium C++ ABI ，MSVC 则遵守 MSVC C++ ABI，Clang 通过不同的编译选项可以分别设置为这两种 ABI。关于 ABI 的详细讨论请移步 彻底理解 C++ ABI 和 MSVC 与 GCC 产生的动态库如何才能相互替换，这里不过多介绍。\nItanium ABI 具有公开的文档，之后的相关描述主要参考这个文档 MSVC ABI 没有公开的文档，之后的相关描述主要参考 MSVC C++ ABI Member Function Pointers 这篇博客 请注意：文章具有时效性，未来的实现可能会改变，所以仅作参考使用。还是以官方文档为准。\n首先尝试打印一个成员指针的值\nstruct C { int m; void foo(int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl;} }; int main(){ int C::* p = \u0026amp;C::m; void (C::* p2)(int) = \u0026amp;C::foo; std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; // 1 std::cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; std::endl; // 1 } 输出的结果都是1。鼠标移到\u0026lt;\u0026lt;就会发现，这是发生了到bool的隐式类型转换。\u0026lt;\u0026lt;并没有重载成员指针类型。想要打出它具体的值，必须要强制类型转换。\nItanium C++ ABI # pointer to data member # 一般来说可以用下述结构体表示，数据成员指针。表示相对于对象首地址的偏移量。如果是nullptr则里面存的是-1。此时成员指针大小就是sizeof(ptrdiff_t)。\nstruct data_member_pointer{ ptrdiff_t offset; }; 由于 C++ 标准不允许虚继承的成员函数指针转换。所以在发生类型转换的时候，编译器就可以自动算出转换需要的 offset。没有虚继承，也不需要在运行期去查虚表找 offset。\nstruct A { int a; }; struct B { int b; }; struct C : A, B {}; void log(auto mp) { std::cout \u0026lt;\u0026lt; \u0026#34;offset is \u0026#34; \u0026lt;\u0026lt; *reinterpret_cast\u0026lt;ptrdiff_t*\u0026gt;(\u0026amp;mp) // or use std::bit_cast after C++20 // std::bit_cast\u0026lt;std::ptrdiff_t\u0026gt;(mp) \u0026lt;\u0026lt; std::endl; } int main() { auto a = \u0026amp;A::a; log(a); // offset is 0 auto b = \u0026amp;B::b; log(b); // offset is 0 int C::*c = a; log(c); // offset is 0 // implicit cast int C::*c2 = b; log(c2); // offset is 4 } 这种实现方式有一点缺陷，在文档里面详细说明了，这里就不说了。\npointer to member function # 在主流的平台上，一般来说可以用下述结构体表示，成员函数指针:\nstruct member_function_pointer { std::ptrdiff_t ptr; // function address or vtable offset // if low bit is 0, it\u0026#39;s a function address, otherwise it\u0026#39;s a vtable offset ptrdiff_t offset; // offset to the base(unless multiple inheritance, it\u0026#39;s always 0) }; 这个实现依赖于一些大多数平台的假定：\n考虑到地址对齐，非静态成员函数的地址最低位几乎总是 0 空的函数指针是 0，所以空函数指针可以和虚表偏移区分开来 体系结构是字节寻址，并且指针大小是偶数，所以虚表偏移量是偶数， 只要知道虚表的地址，虚表索引和函数类型就可以进行函数调用。大多数平台上，虚表指针位于this处，虚表索引和函数类型（调用约定）则由编译器根据 ABI 来决定 当然也有一些平台不满足上述假设，例如 ARM32 平台的某些情况，这时候它的实现方式就和我们刚才说的不同了。所以你现在应该能更加理解什么叫实现定义的行为了。即使编译器相同，目标平台不同，相关的实现都有可能不同。\n在我的环境 x86_64 windows 上，符合主流实现的要求。于是对着这个 ABI，进行了\u0026quot;解糖\u0026quot;。\nstruct member_func_pointer { std::size_t ptr; ptrdiff_t offset; }; template \u0026lt;typename Ret, typename... Args\u0026gt; Ret invoke(void* object, auto ptr, Args... args) { member_func_pointer fp = *reinterpret_cast\u0026lt;member_func_pointer*\u0026gt;(\u0026amp;ptr); bool is_virtual = fp.ptr \u0026amp; 1; // low bit auto this_ptr = reinterpret_cast\u0026lt;void*\u0026gt;((char*)object + fp.offset); if(is_virtual) { auto vptr = *reinterpret_cast\u0026lt;void***\u0026gt;(object); // vptr auto fn_address = *reinterpret_cast\u0026lt;void**\u0026gt;((char*)vptr + fp.ptr - 1); // voffset auto func = reinterpret_cast\u0026lt;Ret (*)(void*, Args...)\u0026gt;(fn_address); return func(this_ptr, args...); } else { auto func = reinterpret_cast\u0026lt;Ret (*)(void*, Args...)\u0026gt;(fp.ptr); return func(this_ptr, args...); } } struct A { int a; virtual void foo(int b) { std::cout \u0026lt;\u0026lt; \u0026#34;A::foo \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; } void bar(int b) { std::cout \u0026lt;\u0026lt; \u0026#34;A::bar \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; } }; int main() { A a = {4}; invoke\u0026lt;void, int\u0026gt;(\u0026amp;a, \u0026amp;A::foo, 3); // A::foo 43 invoke\u0026lt;void, int\u0026gt;(\u0026amp;a, \u0026amp;A::bar, 3); // A::bar 43 } MSVC C++ ABI # MSVC 对于此的实现非常复杂，还对 C++ 标准进行了扩展。如果想要细致全面的了解，还是建议阅读上面那篇博客。\nC++ 标准不允许虚基类成员指针向子类成员指针转换，但是 MSVC 允许。\nstruct Base { int m; }; struct Derived1 : Base {}; // non-virtual inheritance struct Derived2 : virtual Base {}; // virtual inheritance int main() { int Base::*bp = \u0026amp;Base::m; int Derived1::*dp = bp; // ok, implicit cast int Derived2::*dp2 = bp; // ok in MSVC， error in GCC } 为了不浪费空间，即使在同一程序中 msvc 的成员指针大小也可能是不同的大小（GCC 中由于统一实现，所以都是一样大的）。MSVC 对不同情况做了不同处理。另外请注意 MSVC 对于虚继承的是实现和 Itanium 也是不一样的。详见 C++中虚函数、虚继承内存模型 这篇文章中的相关介绍。\npointer to data member # 对于非虚继承的情况下，实现的和 GCC 类似。除了大小有点区别。64位程序中 GCC 是8字节，MSVC 是4字节。都是用-1表示nullptr。\nstruct data_member_pointer{ int offset; }; 对于虚继承的情况下（标准扩展），需要额外存储一个 voffset。用于运行期从虚表里面找到对应虚基类成员的 offset。\nstruct Base { int m; }; struct Base2 { int n; }; struct Base3 { int n; }; struct Derived : virtual Base, Base2, Base3 {}; struct dmp { int offset; int voffset; }; template \u0026lt;typename T\u0026gt; void log(T mp) { dmp d = *reinterpret_cast\u0026lt;dmp*\u0026gt;(\u0026amp;mp); std::cout \u0026lt;\u0026lt; \u0026#34;offset is \u0026#34; \u0026lt;\u0026lt; d.offset \u0026lt;\u0026lt; \u0026#34;, voffset is \u0026#34; \u0026lt;\u0026lt; d.voffset \u0026lt;\u0026lt; std::endl; } int main() { int Derived::*dp = \u0026amp;Base::m; log(dp); // offset is 0, voffset is 4 dp = \u0026amp;Base3::n; log(dp); // offset is 4, voffset is 0 } pointer to member function # 对于成员函数指针就更复杂了，有四种情况：\n非虚继承，非多继承 struct member_function_ptr{ void* address; }; 非虚继承，多继承 struct member_function_ptr{ void* address; int offset; }; 虚继承，多继承 struct member_function_ptr{ void* address; int offset; int vindex; }; 未知继承 struct member_function_ptr{ void* address; int offset; int vadjust; // use to find vptr int vindex; }; 还要注意：32程序中成员函数的调用约定和普通函数不一样。所以如果希望转换成函数指针并调用，需要在函数指针里面把函数调用约定写上才行，不然会导致调用失败。\nConclusion # 讨论 C++ 问题千万不要想当然，你在特定平台上的测试结果，不代表所有可能的实现。而且 MSVC 已经告诉你了，即使是同一个程序内，你的测试也可能没有覆盖到所有的 case。之前发现 MSVC 的成员函数指针大小变来变去的时候给我吓了一跳，以外是我的代码出了问题。如果希望自己写一个类似std::function的容器，并希望执行 SBO 优化，最好把 SBO 大小设置在16字节以上，这样能覆盖掉绝大部分的成员函数指针。\n如果需要成员函数作为回调函数的，推荐使用 lambda 表达式包裹一层。 像下面这样\nstruct A { int a; void bar(int b) { std::cout \u0026lt;\u0026lt; \u0026#34;A::bar \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; } }; int main() { auto f = +[](A\u0026amp; a, int b) { a.bar(b); }; // + is unary plus operator, use to cast a non-capturing lambda to a function pointer // f is function pointer } 在 C++23 之后，如果使用 explicit this 定义成员函数，则\u0026amp;C::f可以直接获取对应成员函数的函数指针，不需要像上面那样多一层包裹了\nstruct A { void bar(this A\u0026amp; self, int b); }; auto p = \u0026amp;A::bar; // p is function pointer, rather than member function pointer ","date":"October 4, 2023","externalUrl":null,"permalink":"/articles/659510753/","section":"Articles","summary":"Introduction # 在 C++ 中，形如\u0026amp;T::name的表达式返回的结果就","title":"C++ 成员指针完全解析","type":"articles"},{"content":"在 C++ 中，模板（Template）这个概念已经存在二十多年了。作为 C++ 最重要的一个语言构成之一，相关的讨论数不胜数。很可惜的是，相关深入的有价值的讨论很少，尤其是提供多个视角看待这一技术。很多文章在谈论模板的时候往往会把它和各种语法细节缠绕在一起，容易给人一种云里雾里的感觉。类似的例子还发生在其它话题上面，比如介绍协程就和各种 IO 混在一起谈，谈到反射似乎就限定了 Java，C# 中的反射。这样做并不无道理，但是往往让人感觉抓不到本质。看了一大堆，但却不得其要领，反倒容易把不同的概念混淆在一起。\n就我个人而言，讨论一个问题喜欢多层次，多角度的去讨论，而不仅限某一特定的方面。这样一来，既能更好的理解问题本身，也不至于让自己的视野太狭隘。故本文将尝试从模板诞生之初开始讲起，以四个角度来观察，理清模板这一技术在 C++ 中的发展脉络。注意，本文并不是教学文章，不会深入语法细节。更多的谈论设计哲学和 trade-off 。掌握一点点模板的基础知识就能看懂，请放心食用。当然这样可能严谨性有所缺失，如有错误欢迎评论区讨论。\n我们主要讨论四个主题：\n控制代码生成，实现泛型 做泛型约束 编译期计算 对类型做计算 其中第一个主题一般认为就是普通的 Template。而后三者一般被规划到「TMP」中去。TMP 即 Template meta programming 也就是模板元编程。因为模板设计之初的意图并不是实现后面这三个功能，但是能以比较抽搐的语法来实现这些功能，代码写起来也比较抽象难懂，所以一般叫做元编程。\n代码生成，实现泛型 # 事实上，这一点正是模板被设计之初的用法，用于实现泛型。在加入模板之前，常常使用宏来实现泛型。考虑下面这个简单的示例：\n#define add(T) _ADD_IMPL_##T #define ADD_IMPL(T) \\ T _ADD_IMPL_##T(T a, T b) { return a + b; } ADD_IMPL(int); ADD_IMPL(float); int main() { add(int)(1, 2); add(float)(1.0f, 2.0f); } 原理倒是很简单，其实就是把函数里面的类型替换成了宏参数。然后通过IMPL来「实例化」一个函数定义，最后直接使用就行了。但是上面的代码有很多缺点：\n代码可读性差，宏的拼接和代码逻辑耦合 没法调试，宏只有展开后才能调试 ，报错信息不好阅读 在使用对应的函数之前，必须手动实例化，比如上面的ADD_IMPL(int) 需要显式写出对应的泛型类型，没法自动推导泛型类型 这些问题，在模板中都被解决了：\ntemplate \u0026lt;typename T\u0026gt; T add(T a, T b) { return a + b; } template int add\u0026lt;\u0026gt;(int, int); // 显式实例化 int main() { add\u0026lt;int\u0026gt;(1, 2); // 显式指定模板参数 T add(1, 2); // 自动推导模板参数 T add(1.0f, 2.0f); // 自动推导并且隐式实例化 } 模板就是占位符，不需要拼接字符串，完全不影响代码的可读性 模板的报错信息相对友好，当类型不匹配时，会提示对应的类型 模板既可以隐式实例化也可以显式实例化 既可以自动推导模板参数，也可以显式指明模板参数 除此之外，模板还支持偏特化，特化，可变模板参数，类成员模板等等一系列特性，这些都是宏做不到的。而且通过模板这一特性的的确确实现了 STL 这样通用的标准库。经常听见很多人问为什么 C 语言没有别的语言那样的容器，算法标准库呢？一个很重的原因就是 C 语言抽象能力不够，没法实现一套这样通用的方案。而且结合后面聊的三个主题，我们可以通过模板实现一些更高级的代码生成。比如经常说的编译期打表，打函数表这种**。**\n别的我都同意，但是你这上面的 模板的报错信息相对友好，当类型不匹配时，会提示对应的类型。难道这不是五十步笑百步吗？甚至有过之而无不及。轻松产生几百，几千行的代码报错，只有 C++ 的模板能做到吧。\n哎，别急，这就是下面我要讲到的问题。\n对类型做约束 # 首先我们要讨论的问题是，为什么 C++ 的编译错误信息这么长？而且有时候非常难读懂。\n函数重载 # struct A {}; int main() { std::cout \u0026lt;\u0026lt; A{} \u0026lt;\u0026lt; std::endl; return 0; } 在我的 GCC 编译器上，足足产生了 239 行报错信息。不过好消息是 GCC 把重点信息标记出来了，如下所示：\nno match for \u0026#39;operator\u0026lt;\u0026lt;\u0026#39; (operand types are \u0026#39;std::ostream\u0026#39; {aka \u0026#39;std::basic_ostream\u0026lt;char\u0026gt;\u0026#39;} and \u0026#39;A\u0026#39;) 9 | std::cout \u0026lt;\u0026lt; A{} \u0026lt;\u0026lt; std::endl; | ~~~~~~~~~ ^~ ~~~ | | | | | A | std::ostream {aka std::basic_ostream\u0026lt;char\u0026gt;} 那大概还是能读懂的的，意思就是没有找到匹配的重载函数。也就是说我们需要为A重载operator\u0026lt;\u0026lt;。当然这个只是入门级别的，还是能轻松看懂的。但是我们好奇的是，剩下的两百行报错在干嘛呢？其实关键就在于重载函数和隐式类型转换。让我们来看其中一段信息。\nnote: template argument deduction/substitution failed: note: cannot convert \u0026#39;A()\u0026#39; (type \u0026#39;A\u0026#39;) to type \u0026#39;const char*\u0026#39; 9 | std::cout \u0026lt;\u0026lt; A{} \u0026lt;\u0026lt; std::endl; 意思就是尝试用A类型匹配const char*这个重载（通过隐式类型转换），结果失败了。标准库类似这样的函数，都实现了很多的重载函数，比如这个operator\u0026lt;\u0026lt;就重载了int,bool,long,double 等等，将近几十个函数。结果报错信息就是把所有重载函数尝试失败的原因都列出来，于是轻松就有几百行了，再加上标准库诡异的命名，看起来就像天书一样。\n模板 # 函数重载是导致报错信息难以读懂的一部分原因，但不是全部。实际上如上面所示，仅仅是把所有可能性枚举出来，不过几百行报错。要知道我们还能产出上千行呢，量级上的差距可不是能用数量轻松堆叠出的。况且本小节要说的是约束，和报错有什么关系呢。 来看下面这个简单的例子：\nstruct A {}; struct B {}; template \u0026lt;typename T\u0026gt; void test(T a, T b) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; } int main() { test(A{}, B{}); // 短短几行报错 test(A{}, A{}); // 几百行报错 } 究竟为什么会出现如此大的差距呢？还记得我们在第一部分里面说的模板相比于宏的两个优点吗？一个是自动类型推导，一个是隐式实例化。对于模板报错来说也基本是从这两个角度入手，test(A{}, B{})这里模板参数推导失败了。因为test函数隐含了一个重要的条件，那就是 a 和 b 的类型是一样的，于是实际上它报的错误是找不到匹配的函数，然后把推断失败的模板函数的原因列出来。而第二个函数test(A{}, A{})则是模板参数推导成功了，进入到实例化的阶段了，但是在实例化的阶段出错了。也就是说T已经被推断为A了，尝试把A代入函数体的时候，出错了。于是就只能把替换失败的原因列出来了。\n那对类型做约束有什么用呢？看下面这个例子\nstruct A {}; template \u0026lt;typename T\u0026gt; void print1(T x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } template \u0026lt;typename T\u0026gt; // requires requires (T x) { std::cout \u0026lt;\u0026lt; x; } // C++20 加入的requires语法，意思就是要求 std::cout \u0026lt;\u0026lt; x 是合法的。 void print2(T x) { print1(x); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } int main() { print2(A{}); return 0; } 短短几行，在我的 GCC 上产生了 700 行的编译错误。稍微改动一下，把注释掉的那行代码加上。相比之下这种情况的代码报错只有短短几行：\nIn substitution of \u0026#39;template\u0026lt;class T\u0026gt; requires requires(T x) {std::cout \u0026lt;\u0026lt; x;} void print2(T) [with T = A]\u0026#39;: required from here required by the constraints of \u0026#39;template\u0026lt;class T\u0026gt; requires requires(T x) {std::cout \u0026lt;\u0026lt; x;} void print2(T)\u0026#39; in requirements with \u0026#39;T x\u0026#39; [with T = A] note: the required expression \u0026#39;(std::cout \u0026lt;\u0026lt; x)\u0026#39; is invalid 15 | requires requires (T x) { std::cout \u0026lt;\u0026lt; x; } 意思就是A类型的实例x不满足requires语句std::cout \u0026lt;\u0026lt; x。事实上通过这样的语法，我们就可以把错误限制在类型推断的阶段，而不去进行实例化。于是报错就友好一万倍了。也就是说通过requires我们能阻止编译错误的传播。 但是可惜的是，相关的约束语法是在 C++20 才加入的。那在这之前呢？\nC++20之前 # 在 C++20 之前，我们并没有这么好用的方法。只能通过一种叫做 SFINAE的技术来实现类似的功能，对类型实现约束。比如上面那个功能，在 C++20 之前只能这么写：\ntemplate \u0026lt;typename T, typename = decltype(std::cout \u0026lt;\u0026lt; std::declval\u0026lt;T\u0026gt;())\u0026gt; void print2(T x) { print1(x); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } 具体的规则在这里就不介绍了，感兴趣的可以去搜搜相关的文章看看。\n结果就是typename = decltype(std::cout \u0026lt;\u0026lt; std::declval\u0026lt;T\u0026gt;())这行代码，完全让人不知所云。只有深入了解相关的规则之后才能看懂这究竟是在干嘛。被口诛笔伐自然是少不了的，如此常用的功能直到 C++20 才加入，实在是很让人很流汗黄豆啊。不过据 C++ 之父本人 自述 ，其实他早就意识到这个问题了，需要对泛型添加某种约束，不过一直拖到 C++20 而已（笑）。别的支持泛型的语言，也基本都有类似的东西。例如 Rust 和 C# 都通过where来表达类似的约束。\n编译期计算 # 意义 # 首先要肯定的一点是，编译期计算肯定是有用的。具体到特定场景，意义有多大，倒是没法判断。有很多人谈编译期计算色变，什么代码难懂，屠龙技，没有价值云云。这样的确很容易误导初学者。事实上相关的需求的确存在。如果编程语言没有这个功能，但是确有需求，程序员也会想方设法的通过其它的办法来实现。\n我将举两个例子来说明：\n首先是编译器对常量表达式的优化，相信这个大家都并不陌生。极其简单的情况，像1+1+x这样的表达式，必然是会被优化成2+x。事实上现代编译器对于类似的情况能做的优化非常多，比如这个 问题。提问者提问 C 语言的strlen函数在参数是常量字符串的时候，会不会把函数调用直接优化成一个常量。比如strlen(\u0026quot;hello\u0026quot;)会不会直接优化成5。从主流编译器的实验结果来看，答案是肯定的。类似的情况数不胜数，不知不觉中你就在使用编译期计算。只是它被归到编译器优化的一部分去了。而编译器的优化能力总归是有上限的，允许使用者自己定义这种优化规则，会更加灵活和自由。比如在 C++ 里面明确了strlen是constexpr的，这种优化必然会发生\n其而是在程序语言发展早期，编译器优化能力还没那么强的时候。就已经开始广泛的使用外部脚本语言提前算好数据（甚至生成好代码）用来减少运行时开销了。典型的例子是算好三角函数表这种常量表，然后运行期直接用就行了（比如在编译代码之前，运行一段python脚本用来生成一些需要的代码） C++ 的编译期计算有明确的语义保证，并且内嵌于语言之中，能和其它部分良好的交互。从这个角度来说，很好的解决了上面两点问题。当然很多人对它的讨伐并不无道理，通过模板元编程进行的编译期计算。代码丑陋且晦涩难懂，牵扯到的语法细节多，并且大大拖慢编译时间，增加二进制文件大小。无可否认的是，这些问题的确存在。但是随着 C++ 版本的不断更新，编译期计算现在已经非常容易理解了，不再需要去写那些复杂的模板元代码，新手也能很快学会。因为和运行期代码几乎一样了。接下来伴随着它的发展史，我们将逐步阐明。\n发展史 # 从历史上看，TMP 是一个偶然事件。在标准化 C++ 语言的过程中发现它的模板系统恰好是图灵完备的，即原则上能够计算任何可计算的东西。第一个具体演示是 Erwin Unruh 编写的一个程序，该程序计算素数，尽管它实际上并未完成编译：素数列表是编译器在尝试编译代码时生成的错误消息的一部分。具体的示例，请参考 这里。\n作为入门级别的编程案例，可以展示一个编译期计算阶乘的方法：\ntemplate \u0026lt;int N\u0026gt; struct Factorial { enum { value = N * Factorial\u0026lt;N - 1\u0026gt;::value }; }; template \u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; { enum { value = 1 }; }; constexpr auto value = Factorial\u0026lt;5\u0026gt;::value; // =\u0026gt; 120 这段代码即使在 C++11 之前也能通过编译，在那之后 C++ 引入了很多新的东西用于简化编译期计算。最重要的就是constexpr关键字了。可以发现在 C++11 之前，我们并没有合适的办法表示编译期常量这一概念，只能借用enum来表达。而 C++11 之后，我们可以这么写：\ntemplate \u0026lt;int N\u0026gt; struct Factorial { constexpr static int value = N * Factorial\u0026lt;N - 1\u0026gt;::value; }; template \u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; { constexpr static int value = 1; }; 尽管进行了一些简化，但实际上我们仍然是借助模板来进行编译期计算。这样写出的代码是难以读懂的，主要原因有以下两点：\n模板参数只能是编译期常量，并没有编译期变量的概念，无论是全局还是局部都没有 只能通过递归而不能通过循环来进行编程 想象一下，如果平常写代码，把变量和循环给你禁了，那写起来是有多难受啊。\n那有没有满足上面两个特征的编程语言呢？其实满足上面两点的编程语言，一般称为 pure functional 也即纯函数式的编程语言。Haskell 就是一个典型的例子。 但是 Haskell 它有强大的模式匹配，在熟悉了 Haskell 的思维之后，也能写出短小优美的代码（而且 Haskell 本身也能用 do 语法模拟出局部变量，因为使用局部变量，其实就相当于把它作为函数参数一级级传递下去）。而 C++ 这些都没有，属于是把别人缺点都继承来了，优点一个没有，自然是被声讨的对象。所幸的是，上面这些问题都在cosntexpr function中都被解决了。\nconstexpr std::size_t factorial(std::size_t N) { std::size_t result = 1; for(std::size_t i = 1; i \u0026lt;= N; ++i) { result *= i; } return result; } int main() { constexpr auto a = factorial(5); // compile-time std::size_t\u0026amp; n = *new std::size_t(6); auto b = factorial(n); // run-time } 事实上，C++ 允许在一个函数前面直接加上constexpr关键字修饰。表示这个函数既可以在运行期调用，也可以在编译期调用，而函数本身的内容几乎不需要任何改变。这样一来，我们可以直接把运行期的代码复用到编译期。也允许使用循环和局部变量进行编程，可以说和平常写的代码没有任何区别。很令人震惊对吧，所以编译期计算在 C++ 里面早已经是一件司空见惯的事情了，用户压根就不需要去写复杂的模板元。在 C++20 之后几乎所有的标准库函数也都是constexpr的了，我们可以轻松的调用它们，比如编译期排序。\nconstexpr auto sort(auto\u0026amp;\u0026amp; range) { std::sort(std::begin(range), std::end(range)); return range; } int main() { constexpr auto arr = sort(std::array{1, 3, 4, 2, 3}); for(auto i: arr) { std::cout \u0026lt;\u0026lt; i; } } 真正意义上的代码复用！如果你想要这个函数只在编译期执行，你也可以用consteval标记它。同时，在 C++20 中还允许了编译期动态内存分配，可以在constexpr function中使用new来进行内存分配，但是编译期分配的内存必须要在编译期释放。你也可以直接在编译期使用vector和string这样的容器。而且请注意，相比于利用模板进行编译期计算，constexpr函数的编译速度会快很多 。如果你好奇编译期是如何实现这一强大的特性的，可以认为，C++编译器内部内嵌了一个小的解释器，这样遇到constexpr函数的时候用这个解释器解释一下，再把计算结果返回就行了。\n相信你已经充分见识到 C++ 在编译期计算方面所做的努力，编译期计算早就和模板元脱离关系了，在 C++ 中已经成为一种非常自然的特性，不需要特殊的语法，却能发挥强大的威力。所以以后千万不要一谈到 C++ 的编译期计算就十分恐慌，以为是什么屠龙之技。现在它早已经变得十分温柔美丽。\n尽管编译期计算已经脱离了模板元的魔爪，但是 C++ 并没有。还有两种情况，我们不得不编写蹩脚的模板元代码。\n无法迈过的坎 # 对类型做计算 # 如何判断两个类型相等呢，或者说判断两个变量的类型相等。可能有人会想，这不是多此一举吗，变量的类型都是编译期已知的，还需要判断吗？其实这个问题可以说是伴随着泛型编程而出现的，考虑下面的示例：\ntemplate \u0026lt;typename T\u0026gt; void test() { if(T == int) { /* ... */ } } 这样的代码是符合我们直觉的，可惜 C++ 并不允许你这么写。不过在 Python / Java 等语言中确实有这种写法，但是它们的判断大多都是在运行时的。C++ 的确允许我们在编译期对类型进行操作，但是可惜的是类型并不能作为一等公民，作为普通的值，只能作为模板参数。我们只能写出如下的代码：\ntemplate \u0026lt;typename T\u0026gt; void test() { if constexpr(std::is_same_v\u0026lt;T, int\u0026gt;) { /* ... */ } } 类型只能存在于模板参数里面，这直接导致上一小节的constexpr编译计算提到的优势全都消失了。我们又回到了刀耕火种的时代，没有变量和循环。\n下面是判断两个type_list满足不满足子序列关系的代码:\ntemplate \u0026lt;typename... Ts\u0026gt; struct type_list {}; template \u0026lt;typename SubFirst, typename... SubRest, typename SuperFirst, typename... SuperRest\u0026gt; constexpr auto is_subsequence_of_impl(type_list\u0026lt;SubFirst, SubRest...\u0026gt;, type_list\u0026lt;SuperFirst, SuperRest...\u0026gt;) { if constexpr(std::is_same_v\u0026lt;SubFirst, SuperFirst\u0026gt;) if constexpr(sizeof...(SubRest) == 0) return true; else return is_subsequence_of(type_list\u0026lt;SubRest...\u0026gt;{}, type_list\u0026lt;SuperRest...\u0026gt;{}); else if constexpr(sizeof...(SuperRest) == 0) return false; else return is_subsequence_of(type_list\u0026lt;SubFirst, SubRest...\u0026gt;{}, type_list\u0026lt;SuperRest...\u0026gt;{}); } template \u0026lt;typename... Sub, typename... Super\u0026gt; constexpr auto is_subsequence_of(type_list\u0026lt;Sub...\u0026gt;, type_list\u0026lt;Super...\u0026gt;) { if constexpr(sizeof...(Sub) == 0) return true; else if constexpr(sizeof...(Super) == 0) return false; else return is_subsequence_of_impl(type_list\u0026lt;Sub...\u0026gt;{}, type_list\u0026lt;Super...\u0026gt;{}); } int main() { static_assert(is_subsequence_of(type_list\u0026lt;int, double\u0026gt;{}, type_list\u0026lt;int, double, float\u0026gt;{})); static_assert(!is_subsequence_of(type_list\u0026lt;int, double\u0026gt;{}, type_list\u0026lt;double, long, char, double\u0026gt;{})); static_assert(is_subsequence_of(type_list\u0026lt;\u0026gt;{}, type_list\u0026lt;\u0026gt;{})); } 写起来非常难受，我把相同的代码逻辑用constexpr函数写一遍，把类型参数换成std::size_t\nconstexpr bool is_subsequence_of(auto\u0026amp;\u0026amp; sub, auto\u0026amp;\u0026amp; super) { std::size_t index = 0; for(std::size_t i = index; index \u0026lt; sub.size() \u0026amp;\u0026amp; i \u0026lt; super.size(); i++) { if(super[i] == sub[index]) { index++; } } return index == sub.size(); } static_assert(is_subsequence_of(std::array{1, 2}, std::array{1, 2, 3})); static_assert(!is_subsequence_of(std::array{1, 2, 4}, std::array{1, 2, 3})); 瞬间清爽一万倍，仅仅是因为在 C++ 中类型不是一等公民，只能作为模板参数，在涉及到类型相关的计算的时候，我们就不得不编写繁琐的模板元代码。事实上对类型做计算的需求一直都存在，典型的例子是std::variant。在编写operator=的时候，我们需要从一个类型列表里面（variant的模板参数列表）里面查找某个类型并返回一个索引，其实就是从一个数组里面查找一个满足特定条件的元素。相关的实现这里就不展示了。其实可怕的并不是使用模板元编程本身，而是就 C++ 自身而言，把类型当作值这样的改动是完全不可接受 unacceptable 的。也就是说这样的状况会一直持续下去，以后都不会有什么本质上的改变，这一事实才是最让人悲伤的。不过仍然要清楚的一个事实是，支持对类型做计算的语言并不多，像 Rust 对于这方面的支持几乎没有。C++ 的代码虽然写起来蹩脚，但是至少能写。\n但是还好这里有还有另外一条路可以走。就是通过一些手段把类型映射到值。例如把类型映射到字符串，匹配类型可以类似于匹配字符串，只要对字符串进行计算就好了，也能实现一定程度上的type as value。C++23之前 并没有标准化的手段进行这种映射，通过一些特殊的编译器扩展能做到，可以参考 C++ 中如何优雅进行 enum 到 string 的转换\ntemplate \u0026lt;typename... Ts\u0026gt; struct type_list {}; template \u0026lt;typename T, typename... Ts\u0026gt; constexpr std::size_t find(type_list\u0026lt;Ts...\u0026gt;) { // type_name returns the name of the type std::array arr = {type_name\u0026lt;Ts\u0026gt;()...}; for(auto i = 0; i \u0026lt; arr.size(); i++) { if(arr[i] == type_name\u0026lt;T\u0026gt;()) { return i; } } } 在 C++23 之后也可以直接用typeid实现映射，而不使用字符串映射。但是类型映射到值简单，把值映射到类型回去可一点都不简单，除非你利用 STMP 这种黑魔法，才能方便的把值映射回类型。但是，如果静态反射将来被引入，那么这种从类型和值的双向映射会非常简单。这样的话虽然不能直接支持把类型当成值来进行操作，但是也基本差不多了。不过还有很长一段路要走，具体什么时候能加入标准，还是个未知数。如果对静态反射感兴趣，可以下面这篇文章\nC++26 静态反射提案解析 https://www.ykiko.me/articles/661692275\n编译期变量之痛 # 除了上面说的对类型做计算不得不用到模板元编程之外，如果需要在编译期计算的同时实例化模板，也不得不用模板元编程。\nconsteval auto test(std::size_t length) { return std::array\u0026lt;std::size_t, length\u0026gt;{}; // error length is not constant expression } 报错的意思就是length不是编译期常量，一般认为它属于编译期变量。这样就很让人讨厌了，考虑如下需求：我们要实现一个完全类型安全的format。也就是说根据第一个常量字符串的内容，来约束后面函数参数的个数。比如是\u0026quot;{}\u0026quot; 的话，后面format的函数参数个数就是1个\nconsteval auto count(std::string_view fmt) { std::size_t num = 0; for(auto i = 0; i \u0026lt; fmt.length(); i++) { if(fmt[i] == \u0026#39;{\u0026#39; \u0026amp;\u0026amp; i + 1 \u0026lt; fmt.length()) { if(fmt[i + 1] == \u0026#39;}\u0026#39;) { num += 1; } } } return num; } template \u0026lt;typename... Args\u0026gt; constexpr auto format(std::string_view fmt, Args\u0026amp;\u0026amp;... args) requires (sizeof...(Args) == count(fmt)) { /* ... */ } 事实上我们并没有办法保证一个函数参数是编译期常量，所以上面的代码是没法编译通过的。想要编译期常量，只能把这部分内容填到模板参数里面去，比如上面的函数可能会最后修改成format\u0026lt;\u0026quot;{}\u0026quot;\u0026gt;(1)这样的形式。虽然只是形式上的差别，但这无疑给使用者带来了困难。这样来看，也就不难理解为什么std::make_index_sequence这样的东西大行其道了。想要真正意义上可以做模板参数的编译期变量，也可以通过 STMP 这种黑魔法做到，但是如前文所述，难以在日常的编程中真正使用它。\n心中所向往的 # 非常值得一提的是，有一个比较新的语言叫 Zig。它解决了上述提到的问题，不仅支持编译期变量，还支持把把类型作为一等公民来进行操作。得益于 Zig 独特的comptime机制，被它标记的变量或代码块都是在编译期执行的。这样一来，我们就可以写出如下的代码：\nconst std = @import(\u0026#34;std\u0026#34;); fn is_subsequence_of(comptime sub: anytype, comptime super: anytype) bool { comptime { var subIndex = 0; var superIndex = 0; while(superIndex \u0026lt; super.len and subIndex \u0026lt; sub.len) : (superIndex += 1) { if(sub[subIndex] == super[superIndex]) { subIndex += 1; } } return subIndex == sub.len; } } pub fn main() !void { comptime var sub = [_] type { i32, f32, i64 }; comptime var super = [_] type { i32, f32, i64, i32, f32, i64 }; std.debug.print(\u0026#34;{}\\n\u0026#34;, .{comptime is_subsequence_of(sub, super)}); comptime var sub2 = [_] type { i32, f32, bool, i64 }; comptime var super2 = [_] type { i32, f32, i64, i32, f32 }; std.debug.print(\u0026#34;{}\\n\u0026#34;, .{comptime is_subsequence_of(sub2, super2)}); } 写出了我们梦寐以求的代码，啊，实在是太优雅了！在对类型计算这方面 Zig 可以说是完胜目前的 C++，感兴趣的读者可以自己去 Zig 官网了解一下，不过在类型计算以外的其它方面，比如泛型和代码生成，Zig 其实做的并不好，这并不是本文的重点，所以就不讨论了。\n结尾 # 到这里文章就结束了，主要对 C++ 模板的不同方面进行探索和讨论。把这庞大的怪物一层层拆开后其实也没那么可怕了，也让我们更加接近它的本质。稍微总结一下吧：\n模板元编程并不等于编译期计算，现在的 C++ 编译期计算和运行期代码逻辑几乎一致。除非需要对类型进行计算 ，否则不需要模板元编程 requires解决了 C++ 代码报错冗长的问题？requires的确让模板报错更加清晰了，但是并没法完全解决 C++ 报错冗长。因为另一罪魁祸首函数重载和隐式类型转换仍然存在 ","date":"September 12, 2023","externalUrl":null,"permalink":"/articles/655902377/","section":"Articles","summary":"在 C++ 中，模板（Template）这个概念已经存在二十多年了。","title":"雾里看花：真正意义上的理解 C++ 模板(Template)","type":"articles"},{"content":" 前情提要： # C++ 禁忌黑魔法: STMP https://www.ykiko.me/articles/646752343\n什么是 STMP 多态 # struct Any{ void* data; std::size_t index; }; int main() { Set\u0026lt;\u0026gt;(); std::vector\u0026lt;Any\u0026gt; vec = make_any(1, std::string(\u0026#34;hello\u0026#34;), 3.14); for(auto\u0026amp;\u0026amp; any: vec) { visit([](auto\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, any); } vec.push_back(make_any(std::string_view(\u0026#34;world\u0026#34;))); vec.push_back(make_any(A{})); std::cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; std::endl; for(auto\u0026amp;\u0026amp; any: vec) { visit([](auto\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, any); } } STMP多态把所有类型都擦成了Any类型，但是与std::any不同的是，std::any需要显示进行类型转换，非常麻烦，但是我们的Any可以方便的使用visit进行访问，不需要任何显示类型转换。这是因为我们利用了STMP，实现了类型的自动注册。\n相关的代码仍然放 Compiler Explorer 上。为了防止链接失效，同样放在 Github。\n书接上文 # 上一篇文章我们实现了一个简单编译期计数器。可以返回一个递增的序列。但是这还不够。我们这篇文章来实现编译器类型容器，可以在编译期动态的添加和删除类型。\ntype_list 工具箱 # 由于我们要实现对类型列表的操作，所以一套称手的工具箱是必要的。我们简单写一些，不求多，只求够用就行。看不懂也没关系，看测试用例明白怎么用就行了。原理我就不讲解了，是非常基础的元编程知识。\n// type_list template \u0026lt;typename... Types\u0026gt; struct type_list { using type = type_list\u0026lt;Types...\u0026gt;; }; // push_back template \u0026lt;typename List, typename T\u0026gt; struct list_push_back; template \u0026lt;typename... Types, typename T\u0026gt; struct list_push_back\u0026lt;type_list\u0026lt;Types...\u0026gt;, T\u0026gt; { using type = type_list\u0026lt;Types..., T\u0026gt;; }; template \u0026lt;typename List, typename T\u0026gt; using list_push_back_t = typename list_push_back\u0026lt;List, T\u0026gt;::type; // push_front template \u0026lt;typename List, typename T\u0026gt; struct list_push_front; template \u0026lt;typename... Types, typename T\u0026gt; struct list_push_front\u0026lt;type_list\u0026lt;Types...\u0026gt;, T\u0026gt; { using type = type_list\u0026lt;T, Types...\u0026gt;; }; template \u0026lt;typename List, typename T\u0026gt; using list_push_front_t = typename list_push_front\u0026lt;List, T\u0026gt;::type; // pop_back template \u0026lt;typename List\u0026gt; struct list_pop_back; template \u0026lt;typename T, typename... Types\u0026gt; struct list_pop_back\u0026lt;type_list\u0026lt;T, Types...\u0026gt;\u0026gt; { using type = list_push_front_t\u0026lt;typename list_pop_back\u0026lt;type_list\u0026lt;Types...\u0026gt;\u0026gt;::type, T\u0026gt;; }; template \u0026lt;typename T\u0026gt; struct list_pop_back\u0026lt;type_list\u0026lt;T\u0026gt;\u0026gt; { using type = type_list\u0026lt;\u0026gt;; }; template \u0026lt;typename List\u0026gt; using list_pop_back_t = typename list_pop_back\u0026lt;List\u0026gt;::type; 测试用例如下\nusing list0 = type_list\u0026lt;int, double, char\u0026gt;; using list1 = list_push_back_t\u0026lt;list0, bool\u0026gt;; static_assert(std::is_same_v\u0026lt;list1, type_list\u0026lt;int, double, char, bool\u0026gt;\u0026gt;); using list2 = list_push_front_t\u0026lt;list1, float\u0026gt;; static_assert(std::is_same_v\u0026lt;list2, type_list\u0026lt;float, int, double, char, bool\u0026gt;\u0026gt;); using list3 = list_pop_back_t\u0026lt;list2\u0026gt;; static_assert(std::is_same_v\u0026lt;list3, type_list\u0026lt;float, int, double, char\u0026gt;\u0026gt;); 返回不同的类型 # 先来看一个简单案例\ntemplate \u0026lt;std::size_t N\u0026gt; struct reader { friend auto counted_flag(reader\u0026lt;N\u0026gt;); }; template \u0026lt;std::size_t N, typename T\u0026gt; struct setter { friend auto counted_flag(reader\u0026lt;N\u0026gt;) { return T{}; } }; int main() { setter\u0026lt;0, int\u0026gt; setter0; // set auto a = counted_flag(reader\u0026lt;0\u0026gt;{}); // read static_assert(std::is_same_v\u0026lt;decltype(a), int\u0026gt;); setter\u0026lt;1, double\u0026gt; setter1; // set auto b = counted_flag(reader\u0026lt;1\u0026gt;{}); // read static_assert(std::is_same_v\u0026lt;decltype(b), double\u0026gt;); setter\u0026lt;2, std::string\u0026gt; setter2; // set auto c = counted_flag(reader\u0026lt;2\u0026gt;{}); // read static_assert(std::is_same_v\u0026lt;decltype(c), std::string\u0026gt;); } 发现没有，可以在某一个位置注册信息。然后仅仅通过这个位置的序号就可以读取到对应的类型。就像一个数组一样，是不是非常神奇。原理就是很好理解，利用了类型推导以及友元函数的 ADL 查找。\n编译期类型容器 # 让我们结合把这个特性和程序计数器结合起来，神奇的事情就发生了。\n// counter template \u0026lt;std::size_t N\u0026gt; struct reader { friend auto counted_flag(reader\u0026lt;N\u0026gt;); }; template \u0026lt;std::size_t N, typename T\u0026gt; struct setter { friend auto counted_flag(reader\u0026lt;N\u0026gt;) { return T{}; } }; template \u0026lt;auto tag = [] {}, auto N = 0, bool condition = requires(reader\u0026lt;N\u0026gt; red) { counted_flag(red); }\u0026gt; consteval auto count() { if constexpr(!condition) { return N - 1; } else { return count\u0026lt;tag, N + 1\u0026gt;(); } } template \u0026lt;typename... Ts\u0026gt; consteval void Set() { setter\u0026lt;0, type_list\u0026lt;Ts...\u0026gt;\u0026gt; s [[maybe_unused]]{}; } template \u0026lt;auto tag = [] {}\u0026gt; using value = decltype(counted_flag(reader\u0026lt;count\u0026lt;tag\u0026gt;()\u0026gt;{})); template \u0026lt;typename T, auto tag = [] {}\u0026gt; consteval void push() { constexpr auto len = count\u0026lt;tag\u0026gt;(); setter\u0026lt;len + 1, list_push_back_t\u0026lt;value\u0026lt;tag\u0026gt;, T\u0026gt;\u0026gt; s [[maybe_unused]]{}; } template \u0026lt;auto tag = [] {}\u0026gt; consteval void pop() { constexpr auto len = count\u0026lt;tag\u0026gt;(); using last = value\u0026lt;tag\u0026gt;; setter\u0026lt;len + 1, list_pop_back_t\u0026lt;value\u0026lt;tag\u0026gt;\u0026gt;\u0026gt; s [[maybe_unused]]{}; } int main() { Set\u0026lt;int\u0026gt;(); static_assert(std::is_same_v\u0026lt;value\u0026lt;\u0026gt;, type_list\u0026lt;int\u0026gt;\u0026gt;); push\u0026lt;double\u0026gt;(); static_assert(std::is_same_v\u0026lt;value\u0026lt;\u0026gt;, type_list\u0026lt;int, double\u0026gt;\u0026gt;); push\u0026lt;char\u0026gt;(); static_assert(std::is_same_v\u0026lt;value\u0026lt;\u0026gt;, type_list\u0026lt;int, double, char\u0026gt;\u0026gt;); pop(); static_assert(std::is_same_v\u0026lt;value\u0026lt;\u0026gt;, type_list\u0026lt;int, double\u0026gt;\u0026gt;); } 这里我们实现了一个count函数，它的原理是前面的next类似，不同的是，next每次会进行递增，而count仅仅是返回实例化的目标模板数量。\n剩下的逻辑就很简单了：\nSet函数用来初始化一个setter，这个setter里面包含了一个类型列表，这个列表表示初始值。 value用count取出最后一个状态。 push用count取出最后一个状态的index，取出对应的type_list，然后对这个type_list进行操作。通过实例化一个新的模板，添加一个新的状态，把新得到的type_list存进去。 pop与push类似，只不过对type_list的操作变成了删除。 按照这个原理，可以轻松的扩展很多类似的操作，其实只要对type_list进行操作就行了。\n挑战C++的极限 # 好了时候到了最终实现的时候了，让我们看看C++的极限在哪里。\n// Any struct Any { void* data; std::size_t index; }; template \u0026lt;typename T, auto tag = [] {}\u0026gt; constexpr auto make_any(T\u0026amp;\u0026amp; t) { auto ls = push\u0026lt;std::decay_t\u0026lt;T\u0026gt;, tag\u0026gt;(); return Any{new auto(std::forward\u0026lt;T\u0026gt;(t)), count\u0026lt;tag\u0026gt;()}; } template \u0026lt;typename... Ts\u0026gt; requires (sizeof...(Ts) \u0026gt; 1) constexpr auto make_any(Ts\u0026amp;\u0026amp;... ts) { return std::vector{make_any(std::forward\u0026lt;Ts\u0026gt;(ts))...}; } template \u0026lt;typename Fn, typename T, auto tag = [] {}\u0026gt; constexpr auto wrap(Fn\u0026amp;\u0026amp; fn, void* ptr) { auto\u0026amp; value = *static_cast\u0026lt;T*\u0026gt;(ptr); using ret = decltype(fn(value)); if constexpr(std::is_same_v\u0026lt;ret, void\u0026gt;) { fn(value); return Any{nullptr, 0}; } else { push\u0026lt;ret, tag\u0026gt;(); return Any{new auto(fn(value)), count\u0026lt;tag\u0026gt;()}; } } template \u0026lt;typename Fn, auto tag = [] {}\u0026gt; constexpr auto visit(Fn\u0026amp;\u0026amp; fn, Any any) { constexpr auto size = count\u0026lt;tag\u0026gt;(); using Wrapper = Any (*)(Fn\u0026amp;\u0026amp;, void*); constexpr auto wrappers = []\u0026lt;typename... Ts\u0026gt;(type_list\u0026lt;Ts...\u0026gt;) { return std::array\u0026lt;Wrapper, size\u0026gt;{wrap\u0026lt;Fn, Ts\u0026gt;...}; }(value\u0026lt;tag\u0026gt;()); return wrappers[any.index](std::forward\u0026lt;Fn\u0026gt;(fn), any.data); } 到这里实现了对Any的自动注册。每次当你调用make_any的时候，就会自动注册一个新的类型，到全局的状态表里。然后visit的时候，其实我们是生成了一些Wrapper函数，打了一个表，然后通过index去调用对应的函数。这样就实现了对Any的自动访问。这里的关键步骤就是，向全局的状态表里面自动注册信息。其余的步骤都和std::visit实现类似。感兴趣的可以去看看std::visit的实现。\n结语 # 事实上，这个系列算是了解了笔者一直以来的心愿。经常听到有人调侃，男人两大爱好是：拉良家妇女下水 劝风尘女子从良。程序员，也有两大爱好：让静态类型的语言变的更动态，为动态语言加上类型检查。事实上自从我学C++以来，一直有这样的心愿，想要实现类型的自动注册。很遗憾，网络上相关的讨论很少。在那之后，我尝试了各种方法，包括但不限于，使用宏元编程，采用libclang等库parse对C++的源码进行解析，但是效果都不如STMP好。当我了解STMP，并且意识到它所能达到的高度之后。我立马通宵写完了文章和案例，毕竟它是如此的令人着迷。在这里，我不想讨论什么可读性，可维护性。由于STMP尚未被标准认可，所以运用到实际项目的编程里，事实上是很困难的。再一次强调，用到实际项目里面并不现实（具体可以看一下评论区讨论）。但是就像当初模板元编程的意外发现一样，这再一次证明了，一门语言能够能多么疯狂的超过它所预期的能力。本文实现的STMP多态，在其它任何一门语言里面都是不可能出现的，这就是C++的魅力所在！\n","date":"July 30, 2023","externalUrl":null,"permalink":"/articles/646812253/","section":"Articles","summary":"前情提要： # C++ 禁忌黑魔法: STMP https://www.ykiko.me/articles/646752343 什么是 STMP 多态 # struct Any{ void* data; std::size_t index; }; int","title":"C++ 禁忌黑魔法: STMP 多态","type":"articles"},{"content":"STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。\n但是事实真的如此吗？\n在不触发未定义行为的情况下，下面的代码可能通过编译吗？ constexpr auto a = f(); constexpr auto b = f(); static_assert(a != b); 再考虑下这样计数器的实现，这可能做到吗？ constexpr auto a = f(); constexpr auto b = f(); constexpr auto c = f(); static_assert(a == 0 \u0026amp;\u0026amp; b == 1 \u0026amp;\u0026amp; c == 2); 事实上通过一些编译器内置的宏，我们是可以做到的。比如\nconstexpr auto a = __COUNTER__; constexpr auto b = __COUNTER__; constexpr auto c = __COUNTER__; static_assert(a == 0 \u0026amp;\u0026amp; b == 1 \u0026amp;\u0026amp; c == 2); 利用主流 C++ 编译器都内置的__COUNTER__宏可以实现上述的效果。但是即使三大编译器都有这个宏，它也不是标准的语法。并且这个计数器是全局唯一的，我们并不能创建很多个计数器。那还有别的办法吗？并且不依赖于编译器扩展？\n答案是肯定的，不管多么难以置信。相关的讨论，早在2015年的时候就有了。知乎上也有相关讨论的 文章。但是时过境迁，这篇文章发布的时间是在 2017 年，使用的 C++ 版本还是14，文章里面已经有很多的内容不适用了。更何况现在 C++26 的相关标准都开始制定了，有很多东西需要被重新讨论。我们将要选择的版本是 C++20。\n如果你只对代码感兴趣，我已经将相关的代码放在 Compiler Explorer - C++ 。三大编译器 C++20 均编译通过，你可以直接看到编译器的输出结果。防止链接失效，也放到 GitHub 上。如果你想要了解它的原理，欢迎继续往下阅读。C++ 标准极其复杂，作者也没法保证文章内容百分百正确，如果有任何错误，欢迎评论区讨论。\n注意：本文仅仅只是技术讨论，请不要将相关的代码运用于实际生产中。事实上，相关的代码似乎被认为是 ill formed。而且非常容易造成 ODR 违反。相关的提案在 CWG 2015 年就有了。但是似乎好像并没有进一步被解决，而且在 C++20 中标准库还主动加入了具有类似作用的库，那就是std::source_location::line。当line作为函数默认参数的时候，随着函数调用位置不同，实际上默认参数取值也是不同的。\n都是友元惹的祸 # 我们都知道 C++ 的 friend 关键字，可以对一个函数进行标记，然后允许这个函数访问类的私有成员。让我们考虑下面这两种情况。\n友元声明在全局空间 class A; void touch(A\u0026amp;); class A { int member; friend void touch(A\u0026amp;); }; void touch(A\u0026amp; ref) { ref.member = 123; } int main() { A a; touch(a); } 友元声明在类内部 class A { int member = 0; friend void touch(A\u0026amp; ref) { ref.member = 123; } }; int main() { A a; touch(a); // OK } 上面的两段代码都是 well defined 的，而且函数touch都能访问类A的私有成员。但是这两种实现方式之间，有微小的区别。在全局空间声明的友元函数，就和普通的函数一样，作用域也是一样的。都在全局命名空间，和全局普通的函数访问是一模一样的。而在类内部声明的友元函数，只能通过 C++ 的 Argument-dependent lookup 进行访问。\n非 ADL 查找 class A; void touch(A); class A { int member; friend void touch(A); public: A(int a) : member(a) {} }; void touch(A ref) { std::cout \u0026lt;\u0026lt; ref.member \u0026lt;\u0026lt; std::endl; } int main() { A a(10); touch(a); // normal lookup touch(1); // implicit conversion } ADL 查找 class A { int member = 0; public: friend void touch(A ref) { std::cout \u0026lt;\u0026lt; ref.member \u0026lt;\u0026lt; std::endl; } A(int a) : member(a) {} }; int main() { A a(10); touch(a); touch(1); // error A::touch(1); // error } 这里你就会发现了，第一次调用成功了，第二，三次调用失败了。这是因为，ADL会在函数参数对应的类型的命名空间中查找函数。在第一种情况下，touch函数的参数类型是A，发生了ADL查找。而1的类型是int，两者并不相关，所以 ADL 不会发生。\n模板显式实例化 # 考虑下面这种情况\nauto flag(auto); template \u0026lt;bool val\u0026gt; struct flag_setter { friend auto flag(auto) {} }; int main() { flag(1); // error flag_setter\u0026lt;true\u0026gt;{}; flag(1); // ok } 首先直接调用flag会发生错误，因为它的返回值类型尚未确定。需要在函数定义里面推导。所以第一个调用就失败了。后面我们进行了一次类模板显式实例化，可以认为模板显式实例化的时候会在全局命名空间添加一个该类型模板的特化（通过友元函数），而这个特化版本实现了flag()。因为flag函数有了定义，返回值类型也就确定了，所以第二次调用就成功了。\n一元常量表达式开关 # 有了上面那些技巧，我们就可以来实现，本文开头所提到的常量开关了。\nauto flag(auto); template \u0026lt;bool val\u0026gt; struct flag_setter { bool value = false; friend auto flag(auto) {} }; template \u0026lt;auto arg = 0, auto condition = requires { flag(arg); }\u0026gt; consteval auto value() { if constexpr(!condition) { return flag_setter\u0026lt;condition\u0026gt;{}.value; } return condition; } int main() { constexpr auto a = value(); constexpr auto b = value(); static_assert(a != b); } 它的原理很简单，首先 C++20 加入的requires语句可以用于检查表达式的合法性。最开始的时候，由于flag_setter还尚未实例化，所以flag函数还没有定义，所以flag(arg)是不合法的表达式的。所以condition的值就会是false。然后我们通过if constexpr来判断condition的值，如果是false，那么我们就实例化一个flag_setter，并且返回false的值。如果是true，那么我们就返回condition的值。这样就实现了一元常量表达式开关。相比于 C++14 的版本，这个版本更加的简洁也更好理解。\n值得注意的一点是，可能有人会问为什么不能直接写requries{ flag(0); }呢？这是由于模板的 two phase lookup，如果直接写requries{ flag(0); }，会在第一阶段就进行查找，然后查找发现错误，并且这个错误是一个 hard error，会直接导致编译失败。如果让这个表达式依赖于模板变量，它就会变成 dependent names，在第二阶段进行查找，并且可以被requires检测表达式是否合法。\n编译期常量计数器 # 基于上述的原理，更进一步，我们可以直接实现一个编译期的计数器！\ntemplate \u0026lt;std::size_t N\u0026gt; struct reader { friend auto counted_flag(reader\u0026lt;N\u0026gt;); }; template \u0026lt;std::size_t N\u0026gt; struct setter { friend auto counted_flag(reader\u0026lt;N\u0026gt;) {} std::size_t value = N; }; template \u0026lt;auto N = 0, auto tag = [] {}, bool condition = requires(reader\u0026lt;N\u0026gt; red) { counted_flag(red); }\u0026gt; consteval auto next() { if constexpr(!condition) { constexpr setter\u0026lt;N\u0026gt; s; return s.value; } else { return next\u0026lt;N + 1\u0026gt;(); } } int main() { constexpr auto a = next(); constexpr auto b = next(); constexpr auto c = next(); static_assert(a == 0 \u0026amp;\u0026amp; b == 1 \u0026amp;\u0026amp; c == 2); } 让我们来解释一下上面的代码。基本原理和一元开关情况类似。reader用来判断函数有没有被实现，setter用来生成实现的函数。然后在next里面，我们首先查看当前的N对应的函数，有没有被实现。如果被没有被实现，就实例化一个setter\u0026lt;N\u0026gt;的模板。如果实现了的话，就递归的查看N+1的情况。\n为了防止有些读者想不通，这里直接从第一次调用开始举例子\n第一次调用这个函数：\nN = 0时，检查发现setter\u0026lt;0\u0026gt;尚未实现，也就是condition是false。这样的话会走第一个分支，实例化一个setter\u0026lt;0\u0026gt;，并且返回0。 第二次调用这个函数：\nN = 0时，检查发现setter\u0026lt;0\u0026gt;已经实现了，也就是condition是true。这样的话会走第二个分支，递归调用next\u0026lt;1\u0026gt;()。 N = 1时，检查发现setter\u0026lt;1\u0026gt;尚未实现，也就是condition是false。这样的话会走第一个分支，实例化一个setter\u0026lt;1\u0026gt;，并且返回1。 第三次调用这个函数：\nN = 0时，检查发现setter\u0026lt;0\u0026gt;已经实现了，也就是condition是true。这样的话会走第二个分支，递归调用next\u0026lt;1\u0026gt;()。 N = 1时，检查发现setter\u0026lt;1\u0026gt;已经实现了，也就是condition是true。这样的话会走第二个分支，递归调用next\u0026lt;2\u0026gt;()。 N = 2时，检查发现setter\u0026lt;2\u0026gt;尚未实现，也就是condition是false。这样的话会走第一个分支，实例化一个setter\u0026lt;2\u0026gt;，并且返回2。 ......，也就是说，我们每一次调用这个函数，就会实例化一个对应的模板函数，这个计数器，其实记录的就是已经实例化的模板函数的数量。\n值得一提的是，上面有一个奇怪的写法。auto tag = []{}，你可能看的一脸懵逼。事实上，[]{}是一个简写的lambda表达式，其实就相当于[](){}。如果用不到函数参数的话，这个小括号可以省略。那为什么我们要在这里添加一个这个玩意呢，完全用不到啊。你可以尝试把它去掉，就会发现得到了错误的结果。变量的值并没有按照预期的结果进行递增。\n这里的原因是，编译器会对常量表达式的求值结果进行缓存，也就是说编译器认为next函数是常量表达式，返回的值应该是不会变的。那既然不会变，我只要求一次不就行了。于是它就把所有next的返回值都记录成相同的了。但是这不是我们想要的结果，我们想要它每次调用的时候都能计算表达式的值。加上这个标签之后，每次调用的模板参数实际是不同的，于是编译器就会重新计算它的值了。\n看下面这个例子\ntemplate \u0026lt;auto arg = [] {}\u0026gt; void test() { std::cout \u0026lt;\u0026lt; typeid(arg).name() \u0026lt;\u0026lt; std::endl; } int main() { test(); // class \u0026lt;lambda_1\u0026gt; test(); // class \u0026lt;lambda_2\u0026gt; test(); // class \u0026lt;lambda_3\u0026gt; } 打印出来的结果不同，表面每一次调用的test()的模板参数其实是不同的，那么这三个test()其实是三个不同的函数。利用这个特性，我们在每次调用next的时候，其实就是不同的模板函数（因为lambda模板参数类型不同）。这样我们就阻止了编译器的缓存。代码就像我们预期的那样进行调用了。\n彩蛋：合法访问类的私有成员 # 我们首先要明确一个观点：类的访问权限说明符private, public, protected仅仅只作用于编译期的检查。如果能通过某种手段避免编译期检查，那完全就可以合法的访问，类的私有成员。\n那么存在这样的方法吗？答案是存在。我们有模板显示实例化的时候可以忽略类作用域的访问权限\nThe C++11/14 standards state the following in note 14.7.2/12 [temp.explicit]: -The usual access checking rules do not apply to names used to specify explicit instantiations. [ Note: In particular, the template arguments and names used in the function declarator (including parameter types, return types and exception speciﬁcations) may be private types or objects which would normally not be accessible and the template may be a member template or member function which would not normally be accessible. — end note ]\n也就是说在显示实例化模板的时候，我们可以直接访问类的私有成员。\nclass Bank { double money = 999\u0026#39;999\u0026#39;999\u0026#39;999; public: void check() const { std::cout \u0026lt;\u0026lt; money \u0026lt;\u0026lt; std::endl; } }; template \u0026lt;auto mp\u0026gt; struct Thief { friend double\u0026amp; steal(Bank\u0026amp; bank) { return bank.*mp; } }; template struct Thief\u0026lt;\u0026amp;Bank::money\u0026gt;; double\u0026amp; steal(Bank\u0026amp; bank); int main() { Bank bank; steal(bank) = 100; bank.check(); return 0; } 成功输出100！\n续篇已出，欢迎阅读：\nC++ 禁忌黑魔法: STMP 多态 https://www.ykiko.me/articles/646812253\n参考文章：\nRevisiting Stateful Metaprogramming in C++20 b.atch: Non-constant constant-expressions in C++ How to Hack C++ with Templates and Friends ","date":"July 29, 2023","externalUrl":null,"permalink":"/articles/646752343/","section":"Articles","summary":"STMP 全名 stateful template meta programming，又叫状态元编程。之所以这","title":"C++ 禁忌黑魔法：STMP","type":"articles"},{"content":" sum type # 下面让我们来讨论 CS 中一个简单但非常有用的概念：sum type，直译过来就是和类型，是一种可以容纳多种类型的类型。什么意思呢？假设现在有一个Shape类型，它可以是Circle或者Rectangle，在 C 语言中怎么实现它呢？使用union我们不难写出如下的实现\nstruct Circle { double radius; }; struct Rectangle { double width; double height; }; struct Shape { enum Type { Circle, Rectangle } type; union { struct Circle circle; struct Rectangle rectangle; }; }; 这里使用了叫做 anonymous union 的特性，相当于声明了一个对应类型的 union 成员，并且把字段名字注入到当前作用域。\n这样我们就可以定义一个Shape类型的变量，给它赋不同类型的值。访问的时候根据type的值来判断它是Circle还是Rectangle就行了。上面这种写法也可以被叫做 tagged union，在C语言里面我们经常这么做。\n但在 C++ 中，事情就没这么简单了。考虑如下代码\nstruct Settings { enum class Type { int_, double_, string }; Type type; union { int i; double d; std::string s; }; }; int main(){ Settings settings; settings.type = Settings::Type::String; settings.s = std::string(\u0026#34;hello\u0026#34;); } 事实上这段代码，甚至没法通过编译。会报错use of deleted function Settings::Settings()。为什么Settings的构造函数被删除了呢？这其实是因为std::string的构造函数是 not trivial 的，当union中含有 not trivial 的类型的时候，编译期无法生成正确的默认构造函数（有多个成员，编译器不知道你要初始化哪一个）。详情请见的可以参考 cppreference 上对 union 的介绍。怎么解决呢？那就是我们自己来定义union的构造函数和析构函数，要确保对象都能正确构造析构，正确保证它们的 lifetime。\n事实上，在 C++ 中直接使用 C 语言的union来表示 sum type 是非常不方便的。原因有以下三点：\n当分配到一个新的类型的时候，我们需要手动更新这个表示当前活跃成员的 tag 当我们需要访问某个成员的时候，我们需要手动检查 tag 的值，确保访问的成员是 active 的 还要正确的调用构造函数和析构函数 这实在太让人抓狂了。如果哪一步忘记了，一不小心，就会写出 undefined behavior 的代码。这里难道就没有什么更好的方案吗？终于，在 C++17 我们等到了 std::variant。它会是我们的救星吗？\nstd::variant # 直接看代码\n#include \u0026lt;string\u0026gt; #include \u0026lt;variant\u0026gt; int main() { using Settings = std::variant\u0026lt;int, bool, std::string\u0026gt;; Settings settings; settings = std::string(\u0026#34;hello\u0026#34;); settings = 1; settings = true; } 上面的代码完全是 well defined 的，实在是太令人开心了。事实上variant可以完美解决上述三个问题中的第三个，它会帮你合适的调用构造函数和析构函数（通过模板类型的特化）。\n但光存不行，我想知道现在哪个类型是活跃的怎么办呢？其实variant有一个index成员函数，可以获取当前类型在你写的类型列表里面的索引，在更新类型的时候也会自动更新这个index的值。所以我们可以这样写\nSettings settings; settings = std::string(\u0026#34;hello\u0026#34;); std::cout \u0026lt;\u0026lt; settings.index() \u0026lt;\u0026lt; std::endl; // 2 settings = 1; std::cout \u0026lt;\u0026lt; settings.index() \u0026lt;\u0026lt; std::endl; // 0 settings = true; std::cout \u0026lt;\u0026lt; settings.index() \u0026lt;\u0026lt; std::endl; // 1 嗯很好，看来第一个问题也解决了。下面只剩第二个问题了。如何把值取出来用呢？这里有一个函数std::get可以用来取出对应类型的值。\nSettings settings; settings = std::string(\u0026#34;hello\u0026#34;); std::cout \u0026lt;\u0026lt; std::get\u0026lt;std::string\u0026gt;(settings) \u0026lt;\u0026lt; std::endl; // hello 但这样有些奇怪，我都知道里面存的是std::string了，再写一遍不是多此一举吗？也可以直接把index作为模板参数\nstd::cout \u0026lt;\u0026lt; std::get\u0026lt;2\u0026gt;(settings) \u0026lt;\u0026lt; std::endl; // hello 我悟了，既然能直接用index来获取对应的类型，那直接下面这样写不就好了？\nstd::cout \u0026lt;\u0026lt; std::get\u0026lt;settings.index()\u0026gt;(settings) \u0026lt;\u0026lt; std::endl; // error 很遗憾，这样的想法是好的，但是这样做是不行的。如果你看报错信息的话，可能会看见几百行。但是最重要的一句话是这样的：error: the value of 'settings' is not usable in a constant expression。不得不说 C++ 的报错实在是太容易让初学者望而却步了。如果我当时遇到这么长的报错，那我要晕过去了。现在问题是，假设我是初学者，就算我知道了这个报错的原因，我也不知道这是什么意思。setting的值不能在常量表达式里面使用？意思是这里的模板参数必须是编译期常量，相关的话题展开谈又是一大块内容了。想要真正理解这部分内容，可以参考下这篇文章 真正意义上的理解 C++ 模板 。\n别急让我们请std::visit上场。\nstd::visit # visit这个名字其实就来源于设计模式里面的那个visitor模式。我们可以写出下面这样的代码。\nSettings settings; settings = std::string(\u0026#34;hello\u0026#34;); std::visit([](auto\u0026amp;\u0026amp; arg) {std::cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; std::endl;}, settings); // hello settings = 1; std::visit([](auto\u0026amp;\u0026amp; arg) {std::cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; std::endl;}, settings); // 1 我们要做的就是给它一个callback，然后就可以访问到里面的值了。上面的callback是一个lambda表达式。那这里第二个问题解决了吗？并没有解决。我们的主要需求是，根据不同的类型做不同的事情，而不是对所有的类型做同一件事情，那该怎么办呢？有一种思路是采用std::holds_alternative来判断\nif (std::holds_alternative\u0026lt;std::string\u0026gt;(settings)){ std::cout \u0026lt;\u0026lt; std::get\u0026lt;std::string\u0026gt;(settings) \u0026lt;\u0026lt; std::endl; }else if (std::holds_alternative\u0026lt;int\u0026gt;(settings)){ std::cout \u0026lt;\u0026lt; std::get\u0026lt;int\u0026gt;(settings) \u0026lt;\u0026lt; std::endl; }else if (std::holds_alternative\u0026lt;bool\u0026gt;(settings)){ std::cout \u0026lt;\u0026lt; std::get\u0026lt;bool\u0026gt;(settings) \u0026lt;\u0026lt; std::endl; } 但是这样有很多重复代码，首先要在条件里面写上对应的类型，然后还得使用的时候再写一遍。完全算得上冗余代码了。这样的方案并不是很能接受，除此之外呢，还有别的解决方案吗？我们先来看看别的语言对 sum type是怎么处理的吧。\nHaskell:\ndata Settings = IntValue Int | BoolValue Bool | StringValue String deriving (Show, Eq) match :: Settings -\u0026gt; IO () match (IntValue x) = putStrLn $ \u0026#34;Int: \u0026#34; ++ show (x + 1) match (BoolValue x) = putStrLn $ \u0026#34;Bool: \u0026#34; ++ show (not x) match (StringValue x) = putStrLn $ \u0026#34;String: \u0026#34; ++ (x ++ \u0026#34; \u0026#34;) Rust:\nenum Settings{ Int(i32), Bool(bool), String(String), } fn main(){ let settings = Settings::Int(1); match settings{ Settings::Int(x) =\u0026gt; println!(\u0026#34;Int: {}\u0026#34;, x + 1), Settings::Bool(x) =\u0026gt; println!(\u0026#34;Bool: {}\u0026#34;, !x), Settings::String(x) =\u0026gt; println!(\u0026#34;String: {}\u0026#34;, x + \u0026#34; \u0026#34;), } } 哦老天爷，如此方便。使用match进行匹配的这种语法被叫做模式匹配 (pattern match)。其实关键的地方就在于，判断完类型之后，分支里面可以直接使用这个变量，而不需要额外再多写什么代码。那 C++ 里面有 pattern match 吗？很可惜并没有，只能通过一些模板元编程技巧来实现上面的效果。\npattern match # 想要在 C++ 写出类似上面代码的效果，有两种方案：\n利用函数重载 template\u0026lt;typename ...Ts\u0026gt; struct Overload : Ts... { using Ts::operator()...; }; template\u0026lt;typename ...Ts\u0026gt; Overload(Ts...) -\u0026gt; Overload\u0026lt;Ts...\u0026gt;; int main() { using Settings = std::variant\u0026lt;int, bool, std::string\u0026gt;; Settings settings = 1; Overload overloads{ [](int x) { std::cout \u0026lt;\u0026lt; \u0026#34;Int: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; }, [](bool x) { std::cout \u0026lt;\u0026lt; \u0026#34;Bool: \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; }, [](std::string x) { std::cout \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; }, }; std::visit(overloads, settings); } 利用type_traits int main() { using Settings = std::variant\u0026lt;int, bool, std::string\u0026gt;; Settings settings = 1; std::visit( [](auto\u0026amp;\u0026amp; arg) { using type = std::decay_t\u0026lt;decltype(arg)\u0026gt;; if constexpr(std::is_same_v\u0026lt;type, int\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#34;Int: \u0026#34; \u0026lt;\u0026lt; arg + 1 \u0026lt;\u0026lt; std::endl; } else if constexpr(std::is_same_v\u0026lt;type, bool\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#34;Bool: \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; !arg \u0026lt;\u0026lt; std::endl; } else if constexpr(std::is_same_v\u0026lt;type, std::string\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; std::endl; } }, settings); } 这里的代码就不做解释了，还是那句话，如果想要真正理解，参考上面的链接。\nthat is too bad ! # C++ 经常喜欢用模板来实现各种东西。和上面的variant类似的窘境还有遍历tuple的时候，我们不得不使用make_index_sequence + 可变模板参数展开。还有就是按index访问可变模板参数还得先转成tuple，才能继续进一步的操作。 这样不仅用起来很麻烦，是语法噪音，读起来不好读，而且因为要额外很多实例化模板，大大拖慢了编译速度。事实上，这些东西对编译器来说都是透明的，它能直接以较高的效率进行访问，不用额外实例化很多模板。于是像tuple和variant这种类型，虽然你可以自己手动实现。但是你自己实现的是没有编译器实现的编译速度快的，因为编译器对此做了特殊处理，也就是我们通常说的「开洞」。 不过还好，可变模板参数访问的问题在 C++26 被解决了，我们可以用...[index]来访问可变模板参数中的元素了，不再需要tuple了。相比之下模式匹配相关的提案还没有进入标准，不知道还要写多久。现在我们只能选择多写点代码了。\n","date":"July 25, 2023","externalUrl":null,"permalink":"/articles/645810896/","section":"Articles","summary":"sum type # 下面让我们来讨论 CS 中一个简单但非常有用的概念：sum t","title":"std::variant 很难用！","type":"articles"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]


<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ykiko">
  <meta name="keywords" content="">
  
    <meta name="description" content="STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。  但是事实真的如此吗？  在不触发未定义行为的情况下，下面的代码可能通过编译吗？  123constexpr auto a">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 禁忌黑魔法：STMP">
<meta property="og:url" content="https://www.ykiko.me/646752343/index.html">
<meta property="og:site_name" content="ykiko&#39;s blog">
<meta property="og:description" content="STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。  但是事实真的如此吗？  在不触发未定义行为的情况下，下面的代码可能通过编译吗？  123constexpr auto a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pica.zhimg.com/v2-0a5f7ba961aa8a8a2358511b09d2d6c6_720w.jpg?source=172ae18b">
<meta property="article:published_time" content="2023-07-29T02:20:50.000Z">
<meta property="article:modified_time" content="2024-05-26T07:05:38.000Z">
<meta property="article:author" content="ykiko">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pica.zhimg.com/v2-0a5f7ba961aa8a8a2358511b09d2d6c6_720w.jpg?source=172ae18b">
  
  
  
  <title>C++ 禁忌黑魔法：STMP - ykiko&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.ykiko.me","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ykiko&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ 禁忌黑魔法：STMP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-29 10:20" pubdate>
          2023年7月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          25 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++ 禁忌黑魔法：STMP</h1>
            
            
              <div class="markdown-body">
                
                <p>STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。</p>
<p><img src="https://pic1.zhimg.com/v2-17999d0f90003c348d733cd32c417a28_r.jpg" srcset="/img/loading.gif" lazyload></p>
<p>但是事实真的如此吗？</p>
<ul>
<li>在不触发未定义行为的情况下，下面的代码可能通过编译吗？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">f</span>();<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">f</span>();<br><span class="hljs-built_in">static_assert</span>(a != b);<br></code></pre></td></tr></table></figure>

<ul>
<li>再考虑下这样计数器的实现，这可能做到吗？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">f</span>();<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">f</span>();<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">f</span>();<br><span class="hljs-built_in">static_assert</span>(a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">1</span> &amp;&amp; c == <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>事实上通过一些编译器内置的宏，我们是可以做到的。比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> a = __COUNTER__;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> b = __COUNTER__;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> c = __COUNTER__;<br><span class="hljs-built_in">static_assert</span>(a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">1</span> &amp;&amp; c == <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>利用主流 C++ 编译器都内置的<code>__COUNTER__</code>宏可以实现上述的效果。但是即使三大编译器都有这个宏，它也不是标准的语法。并且这个计数器是全局唯一的，我们并不能创建很多个计数器。那还有别的办法吗？并且不依赖于编译器扩展？</p>
<p>答案是肯定的，不管多么难以置信。相关的讨论，早在2015年的时候就有了。知乎上也有相关讨论的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/24835482">文章</a>。但是时过境迁，这篇文章发布的时间是在 2017 年，使用的 C++ 版本还是14，文章里面已经有很多的内容不适用了。更何况现在 C++26 的相关标准都开始制定了，有很多东西需要被重新讨论。我们将要选择的版本是 C++20。</p>
<p>如果你只对代码感兴趣，我已经将相关的代码放在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://godbolt.org/z/MGPKeqPaj">Compiler Explorer - C++</a> 。三大编译器 C++20 均编译通过，你可以直接看到编译器的输出结果。防止链接失效，也放到 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/16bit-ykiko/blog/blob/main/code/compile-time-counter.cpp">GitHub</a> 上。如果你想要了解它的原理，欢迎继续往下阅读。C++ 标准极其复杂，作者也没法保证文章内容百分百正确，如果有任何错误，欢迎评论区讨论。</p>
<blockquote>
<p>注意：本文仅仅只是技术讨论，请不要将相关的代码运用于实际生产中。事实上，相关的代码似乎被认为是  ill formed。而且非常容易造成 ODR 违反。相关的提案在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cplusplus.github.io/CWG/issues/2118.html">CWG</a> 2015 年就有了。但是似乎好像并没有进一步被解决，而且在 C++20 中标准库还主动加入了具有类似作用的库，那就是<code>std::source_location::line</code>。当<code>line</code>作为函数默认参数的时候，随着函数调用位置不同，实际上默认参数取值也是不同的。 </p>
</blockquote>
<h1 id="都是友元惹的祸"><a href="#都是友元惹的祸" class="headerlink" title="都是友元惹的祸"></a>都是友元惹的祸</h1><p>我们都知道 C++ 的 friend 关键字，可以对一个函数进行标记，然后允许这个函数访问类的私有成员。让我们考虑下面这两种情况。</p>
<ul>
<li>友元声明在全局空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A&amp;)</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> member;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A&amp;)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A&amp; ref)</span> </span>&#123; ref.member = <span class="hljs-number">123</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-built_in">touch</span>(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>友元声明在类内部</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> member = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A&amp; ref)</span> </span>&#123; ref.member = <span class="hljs-number">123</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-built_in">touch</span>(a);  <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的两段代码都是 well defined 的，而且函数<code>touch</code>都能访问类<code>A</code>的私有成员。但是这两种实现方式之间，有微小的区别。在全局空间声明的友元函数，就和普通的函数一样，作用域也是一样的。都在全局命名空间，和全局普通的函数访问是一模一样的。而在类内部声明的友元函数，只能通过 C++ 的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.cppreference.com/w/cpp/language/adl">Argument-dependent lookup</a> 进行访问。</p>
<ul>
<li>非 ADL 查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A)</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> member;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">member</span>(a) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A ref)</span> </span>&#123; std::cout &lt;&lt; ref.member &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">touch</span>(a);  <span class="hljs-comment">// normal lookup</span><br>    <span class="hljs-built_in">touch</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// implicit conversion</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>ADL 查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> member = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(A ref)</span> </span>&#123; std::cout &lt;&lt; ref.member &lt;&lt; std::endl; &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">member</span>(a) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">touch</span>(a);<br>    <span class="hljs-built_in">touch</span>(<span class="hljs-number">1</span>);     <span class="hljs-comment">// error</span><br>    A::<span class="hljs-built_in">touch</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// error</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里你就会发现了，第一次调用成功了，第二，三次调用失败了。这是因为，ADL会在函数参数对应的类型的命名空间中查找函数。在第一种情况下，<code>touch</code>函数的参数类型是<code>A</code>，发生了<code>ADL</code>查找。而<code>1</code>的类型是<code>int</code>，两者并不相关，所以 ADL 不会发生。</p>
<h1 id="模板显式实例化"><a href="#模板显式实例化" class="headerlink" title="模板显式实例化"></a>模板显式实例化</h1><p>考虑下面这种情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-keyword">auto</span>)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> val&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flag_setter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-keyword">auto</span>)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">flag</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// error</span><br>    flag_setter&lt;<span class="hljs-literal">true</span>&gt;&#123;&#125;;<br>    <span class="hljs-built_in">flag</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先直接调用<code>flag</code>会发生错误，因为它的返回值类型尚未确定。需要在函数定义里面推导。所以第一个调用就失败了。后面我们进行了一次类模板显式实例化，可以认为模板显式实例化的时候会在全局命名空间添加一个该类型模板的特化（通过友元函数），而这个特化版本实现了<code>flag()</code>。因为<code>flag</code>函数有了定义，返回值类型也就确定了，所以第二次调用就成功了。</p>
<h1 id="一元常量表达式开关"><a href="#一元常量表达式开关" class="headerlink" title="一元常量表达式开关"></a>一元常量表达式开关</h1><p>有了上面那些技巧，我们就可以来实现，本文开头所提到的常量开关了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-keyword">auto</span>)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> val&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flag_setter</span> &#123;<br>    <span class="hljs-type">bool</span> value = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-keyword">auto</span>)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> arg = <span class="hljs-number">0</span>, <span class="hljs-keyword">auto</span> condition = <span class="hljs-keyword">requires</span> &#123; <span class="hljs-built_in">flag</span>(arg); &#125;&gt;<br><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(!condition)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> flag_setter&lt;condition&gt;&#123;&#125;.value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> condition;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">value</span>();<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">value</span>();<br>    <span class="hljs-built_in">static_assert</span>(a != b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它的原理很简单，首先 C++20 加入的<code>requires</code>语句可以用于检查表达式的合法性。最开始的时候，由于<code>flag_setter</code>还尚未实例化，所以<code>flag</code>函数还没有定义，所以<code>flag(arg)</code>是不合法的表达式的。所以<code>condition</code>的值就会是<code>false</code>。然后我们通过<code>if constexpr</code>来判断<code>condition</code>的值，如果是<code>false</code>，那么我们就实例化一个<code>flag_setter</code>，并且返回<code>false</code>的值。如果是<code>true</code>，那么我们就返回<code>condition</code>的值。这样就实现了一元常量表达式开关。相比于 C++14 的版本，这个版本更加的简洁也更好理解。</p>
<p>值得注意的一点是，可能有人会问为什么不能直接写<code>requries&#123; flag(0); &#125;</code>呢？这是由于模板的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.cppreference.com/w/cpp/language/two-phase_lookup">two phase lookup</a>，如果直接写<code>requries&#123; flag(0); &#125;</code>，会在第一阶段就进行查找，然后查找发现错误，并且这个错误是一个 hard error，会直接导致编译失败。如果让这个表达式依赖于模板变量，它就会变成 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent names</a>，在第二阶段进行查找，并且可以被<code>requires</code>检测表达式是否合法。</p>
<h1 id="编译期常量计数器"><a href="#编译期常量计数器" class="headerlink" title="编译期常量计数器"></a>编译期常量计数器</h1><p>基于上述的原理，更进一步，我们可以直接实现一个编译期的计数器！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">reader</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">counted_flag</span><span class="hljs-params">(reader&lt;N&gt;)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">setter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">counted_flag</span><span class="hljs-params">(reader&lt;N&gt;)</span> </span>&#123;&#125;<br><br>    std::<span class="hljs-type">size_t</span> value = N;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> N = <span class="hljs-number">0</span>,<br>          <span class="hljs-keyword">auto</span> tag = [] &#123;&#125;,<br>          <span class="hljs-type">bool</span> condition = <span class="hljs-built_in">requires</span>(reader&lt;N&gt; red) &#123; <span class="hljs-built_in">counted_flag</span>(red); &#125;&gt;<br><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(!condition)</span> </span>&#123;<br>        <span class="hljs-keyword">constexpr</span> setter&lt;N&gt; s;<br>        <span class="hljs-keyword">return</span> s.value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span>&lt;N + <span class="hljs-number">1</span>&gt;();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">next</span>();<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">next</span>();<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">next</span>();<br>    <span class="hljs-built_in">static_assert</span>(a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">1</span> &amp;&amp; c == <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>让我们来解释一下上面的代码。基本原理和一元开关情况类似。<code>reader</code>用来判断函数有没有被实现，<code>setter</code>用来生成实现的函数。然后在<code>next</code>里面，我们首先查看当前的<code>N</code>对应的函数，有没有被实现。如果被没有被实现，就实例化一个<code>setter&lt;N&gt;</code>的模板。如果实现了的话，就递归的查看<code>N+1</code>的情况。</p>
<p>为了防止有些读者想不通，这里直接从第一次调用开始举例子</p>
<p>第一次调用这个函数：</p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;0&gt;</code>，并且返回<code>0</code>。</li>
</ul>
<p>第二次调用这个函数： </p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;1&gt;()</code>。 </li>
<li><code>N = 1</code>时，检查发现<code>setter&lt;1&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;1&gt;</code>，并且返回<code>1</code>。</li>
</ul>
<p>第三次调用这个函数： </p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;1&gt;()</code>。 </li>
<li><code>N = 1</code>时，检查发现<code>setter&lt;1&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;2&gt;()</code>。 </li>
<li><code>N = 2</code>时，检查发现<code>setter&lt;2&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;2&gt;</code>，并且返回<code>2</code>。</li>
</ul>
<p><code>......</code>，也就是说，我们每一次调用这个函数，就会实例化一个对应的模板函数，这个计数器，其实记录的就是已经实例化的模板函数的数量。</p>
<p>值得一提的是，上面有一个奇怪的写法。<code>auto tag = []&#123;&#125;</code>，你可能看的一脸懵逼。事实上，<code>[]&#123;&#125;</code>是一个简写的<code>lambda</code>表达式，其实就相当于<code>[]()&#123;&#125;</code>。如果用不到函数参数的话，这个小括号可以省略。那为什么我们要在这里添加一个这个玩意呢，完全用不到啊。你可以尝试把它去掉，就会发现得到了错误的结果。变量的值并没有按照预期的结果进行递增。</p>
<p>这里的原因是，编译器会对常量表达式的求值结果进行缓存，也就是说编译器认为<code>next</code>函数是常量表达式，返回的值应该是不会变的。那既然不会变，我只要求一次不就行了。于是它就把所有<code>next</code>的返回值都记录成相同的了。但是这不是我们想要的结果，我们想要它每次调用的时候都能计算表达式的值。加上这个标签之后，每次调用的模板参数实际是不同的，于是编译器就会重新计算它的值了。</p>
<p>看下面这个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> arg = [] &#123;&#125;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">test</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(arg).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test</span>();  <span class="hljs-comment">// class &lt;lambda_1&gt;</span><br>    <span class="hljs-built_in">test</span>();  <span class="hljs-comment">// class &lt;lambda_2&gt;</span><br>    <span class="hljs-built_in">test</span>();  <span class="hljs-comment">// class &lt;lambda_3&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印出来的结果不同，表面每一次调用的<code>test()</code>的模板参数其实是不同的，那么这三个<code>test()</code>其实是三个不同的函数。利用这个特性，我们在每次调用<code>next</code>的时候，其实就是不同的模板函数（因为<code>lambda</code>模板参数类型不同）。这样我们就阻止了编译器的缓存。代码就像我们预期的那样进行调用了。</p>
<h1 id="彩蛋：合法访问类的私有成员"><a href="#彩蛋：合法访问类的私有成员" class="headerlink" title="彩蛋：合法访问类的私有成员"></a>彩蛋：合法访问类的私有成员</h1><p>我们首先要明确一个观点：类的访问权限说明符<code>private</code>, <code>public</code>, <code>protected</code>仅仅只作用于编译期的检查。如果能通过某种手段避免编译期检查，那完全就可以合法的访问，类的私有成员。</p>
<p>那么存在这样的方法吗？答案是存在。我们有<strong>模板显示实例化的时候可以忽略类作用域的访问权限</strong></p>
<blockquote>
<p> The C++11&#x2F;14 standards state the following in note 14.7.2&#x2F;12 [temp.explicit]: -The usual access checking rules do not apply to names used to specify explicit instantiations. [ Note: In particular, the template arguments and names used in the function declarator (including parameter types, return types and exception speciﬁcations) may be private types or objects which would normally not be accessible and the template may be a member template or member function which would not normally be accessible. — end note ] </p>
</blockquote>
<p>也就是说在显示实例化模板的时候，我们可以直接访问类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-type">double</span> money = <span class="hljs-number">999&#x27;999&#x27;999&#x27;999</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> mp&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Thief</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">double</span>&amp; <span class="hljs-title">steal</span><span class="hljs-params">(Bank&amp; bank)</span> </span>&#123; <span class="hljs-keyword">return</span> bank.*mp; &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Thief</span>&lt;&amp;Bank::money&gt;;<br><span class="hljs-function"><span class="hljs-type">double</span>&amp; <span class="hljs-title">steal</span><span class="hljs-params">(Bank&amp; bank)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Bank bank;<br>    <span class="hljs-built_in">steal</span>(bank) = <span class="hljs-number">100</span>;<br>    bank.<span class="hljs-built_in">check</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>成功输出<code>100</code>！</p>
<hr>
<p>续篇已出，欢迎阅读：</p>
<p><a target="_blank" href="https://www.ykiko.me/646812253" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++ 禁忌黑魔法: STMP 多态</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.ykiko.me/646812253</span></span></span></a></p>
<p>参考文章： </p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://mc-deltat.github.io/articles/stateful-metaprogramming-cpp20">Revisiting Stateful Metaprogramming in C++20</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://b.atch.se/posts/non-constant-constant-expressions/">b.atch: Non-constant constant-expressions in C++</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://ledas.com/post/857-how-to-hack-c-with-templates-and-friends/">How to Hack C++ with Templates and Friends</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ 禁忌黑魔法：STMP</div>
      <div>https://www.ykiko.me/646752343/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ykiko</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/" rel="external nofollow noreferrer">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/646812253/" title="C++ 禁忌黑魔法: STMP 多态">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++ 禁忌黑魔法: STMP 多态</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/645810896/" title="std::variant 很难用！">
                        <span class="hidden-mobile">std::variant 很难用！</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

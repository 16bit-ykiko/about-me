<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 禁忌黑魔法：STMP | ykiko's blog</title><meta name="author" content="ykiko,ykikoykikoykiko@gmail.com"><meta name="copyright" content="ykiko"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。  但是事实真的如此吗？  在不触发未定义行为的情况下，下面的代码可能通过编译吗？  123constexpr auto a">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 禁忌黑魔法：STMP">
<meta property="og:url" content="https://16bit-ykiko.github.io/about-me/646752343/index.html">
<meta property="og:site_name" content="ykiko&#39;s blog">
<meta property="og:description" content="STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。  但是事实真的如此吗？  在不触发未定义行为的情况下，下面的代码可能通过编译吗？  123constexpr auto a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/v2-0a5f7ba961aa8a8a2358511b09d2d6c6_720w.jpg?source=172ae18b">
<meta property="article:published_time" content="2023-07-29T02:20:50.000Z">
<meta property="article:modified_time" content="2024-05-24T03:59:52.000Z">
<meta property="article:author" content="ykiko">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/v2-0a5f7ba961aa8a8a2358511b09d2d6c6_720w.jpg?source=172ae18b"><link rel="shortcut icon" href="/about-me/img/favicon.png"><link rel="canonical" href="https://16bit-ykiko.github.io/about-me/646752343/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/about-me/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/about-me/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 禁忌黑魔法：STMP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-24 11:59:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/about-me/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/about-me/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/about-me/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/about-me/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic1.zhimg.com/v2-0a5f7ba961aa8a8a2358511b09d2d6c6_720w.jpg?source=172ae18b')"><nav id="nav"><span id="blog-info"><a href="/about-me/" title="ykiko's blog"><span class="site-name">ykiko's blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ 禁忌黑魔法：STMP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-29T02:20:50.000Z" title="发表于 2023-07-29 10:20:50">2023-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-24T03:59:52.000Z" title="更新于 2024-05-24 11:59:52">2024-05-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ 禁忌黑魔法：STMP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。</p>
<p><img src="https://pic1.zhimg.com/v2-17999d0f90003c348d733cd32c417a28_r.jpg" alt="img"></p>
<p>但是事实真的如此吗？</p>
<ul>
<li>在不触发未定义行为的情况下，下面的代码可能通过编译吗？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">static_assert</span>(a != b);</span><br></pre></td></tr></table></figure>

<ul>
<li>再考虑下这样计数器的实现，这可能做到吗？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> c = <span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">static_assert</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; c == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>事实上通过一些编译器内置的宏，我们是可以做到的。比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = __COUNTER__;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = __COUNTER__;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> c = __COUNTER__;</span><br><span class="line"><span class="built_in">static_assert</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; c == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>利用主流 C++ 编译器都内置的<code>__COUNTER__</code>宏可以实现上述的效果。但是即使三大编译器都有这个宏，它也不是标准的语法。并且这个计数器是全局唯一的，我们并不能创建很多个计数器。那还有别的办法吗？并且不依赖于编译器扩展？</p>
<p>答案是肯定的，不管多么难以置信。相关的讨论，早在2015年的时候就有了。知乎上也有相关讨论的 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24835482">文章</a>。但是时过境迁，这篇文章发布的时间是在 2017 年，使用的 C++ 版本还是14，文章里面已经有很多的内容不适用了。更何况现在 C++26 的相关标准都开始制定了，有很多东西需要被重新讨论。我们将要选择的版本是 C++20。</p>
<p>如果你只对代码感兴趣，我已经将相关的代码放在 <a target="_blank" rel="noopener" href="https://godbolt.org/z/MGPKeqPaj">Compiler Explorer - C++</a> 。三大编译器 C++20 均编译通过，你可以直接看到编译器的输出结果。防止链接失效，也放到 <a target="_blank" rel="noopener" href="https://github.com/16bit-ykiko/blog/blob/main/code/compile-time-counter.cpp">GitHub</a> 上。如果你想要了解它的原理，欢迎继续往下阅读。C++ 标准极其复杂，作者也没法保证文章内容百分百正确，如果有任何错误，欢迎评论区讨论。</p>
<blockquote>
<p>注意：本文仅仅只是技术讨论，请不要将相关的代码运用于实际生产中。事实上，相关的代码似乎被认为是  ill formed。而且非常容易造成 ODR 违反。相关的提案在 <a target="_blank" rel="noopener" href="https://cplusplus.github.io/CWG/issues/2118.html">CWG</a> 2015 年就有了。但是似乎好像并没有进一步被解决，而且在 C++20 中标准库还主动加入了具有类似作用的库，那就是<code>std::source_location::line</code>。当<code>line</code>作为函数默认参数的时候，随着函数调用位置不同，实际上默认参数取值也是不同的。</p>
</blockquote>
<h2 id="都是友元惹的祸"><a href="#都是友元惹的祸" class="headerlink" title="都是友元惹的祸"></a>都是友元惹的祸</h2><p>我们都知道 C++ 的 friend 关键字，可以对一个函数进行标记，然后允许这个函数访问类的私有成员。让我们考虑下面这两种情况。</p>
<ul>
<li>友元声明在全局空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp; ref)</span> </span>&#123; ref.member = <span class="number">123</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">touch</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>友元声明在类内部</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp; ref)</span> </span>&#123; ref.member = <span class="number">123</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">touch</span>(a);  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两段代码都是 well defined 的，而且函数<code>touch</code>都能访问类<code>A</code>的私有成员。但是这两种实现方式之间，有微小的区别。在全局空间声明的友元函数，就和普通的函数一样，作用域也是一样的。都在全局命名空间，和全局普通的函数访问是一模一样的。而在类内部声明的友元函数，只能通过 C++ 的 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/adl">Argument-dependent lookup</a> 进行访问。</p>
<ul>
<li>非 ADL 查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : <span class="built_in">member</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A ref)</span> </span>&#123; std::cout &lt;&lt; ref.member &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">touch</span>(a);  <span class="comment">// normal lookup</span></span><br><span class="line">    <span class="built_in">touch</span>(<span class="number">1</span>);  <span class="comment">// implicit conversion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ADL 查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A ref)</span> </span>&#123; std::cout &lt;&lt; ref.member &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : <span class="built_in">member</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">touch</span>(a);</span><br><span class="line">    <span class="built_in">touch</span>(<span class="number">1</span>);     <span class="comment">// error</span></span><br><span class="line">    A::<span class="built_in">touch</span>(<span class="number">1</span>);  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里你就会发现了，第一次调用成功了，第二，三次调用失败了。这是因为，ADL会在函数参数对应的类型的命名空间中查找函数。在第一种情况下，<code>touch</code>函数的参数类型是<code>A</code>，发生了<code>ADL</code>查找。而<code>1</code>的类型是<code>int</code>，两者并不相关，所以 ADL 不会发生。</p>
<h2 id="模板显式实例化"><a href="#模板显式实例化" class="headerlink" title="模板显式实例化"></a>模板显式实例化</h2><p>考虑下面这种情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flag_setter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">flag</span>(<span class="number">1</span>);  <span class="comment">// error</span></span><br><span class="line">    flag_setter&lt;<span class="literal">true</span>&gt;&#123;&#125;;</span><br><span class="line">    <span class="built_in">flag</span>(<span class="number">1</span>);  <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先直接调用<code>flag</code>会发生错误，因为它的返回值类型尚未确定。需要在函数定义里面推导。所以第一个调用就失败了。后面我们进行了一次类模板显式实例化，可以认为模板显式实例化的时候会在全局命名空间添加一个该类型模板的特化（通过友元函数），而这个特化版本实现了<code>flag()</code>。因为<code>flag</code>函数有了定义，返回值类型也就确定了，所以第二次调用就成功了。</p>
<h2 id="一元常量表达式开关"><a href="#一元常量表达式开关" class="headerlink" title="一元常量表达式开关"></a>一元常量表达式开关</h2><p>有了上面那些技巧，我们就可以来实现，本文开头所提到的常量开关了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flag_setter</span> &#123;</span><br><span class="line">    <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> arg = <span class="number">0</span>, <span class="keyword">auto</span> condition = <span class="keyword">requires</span> &#123; <span class="built_in">flag</span>(arg); &#125;&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag_setter&lt;condition&gt;&#123;&#125;.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">value</span>();</span><br><span class="line">    <span class="built_in">static_assert</span>(a != b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的原理很简单，首先 C++20 加入的<code>requires</code>语句可以用于检查表达式的合法性。最开始的时候，由于<code>flag_setter</code>还尚未实例化，所以<code>flag</code>函数还没有定义，所以<code>flag(arg)</code>是不合法的表达式的。所以<code>condition</code>的值就会是<code>false</code>。然后我们通过<code>if constexpr</code>来判断<code>condition</code>的值，如果是<code>false</code>，那么我们就实例化一个<code>flag_setter</code>，并且返回<code>false</code>的值。如果是<code>true</code>，那么我们就返回<code>condition</code>的值。这样就实现了一元常量表达式开关。相比于 C++14 的版本，这个版本更加的简洁也更好理解。</p>
<p>值得注意的一点是，可能有人会问为什么不能直接写<code>requries&#123; flag(0); &#125;</code>呢？这是由于模板的 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/two-phase_lookup">two phase lookup</a>，如果直接写<code>requries&#123; flag(0); &#125;</code>，会在第一阶段就进行查找，然后查找发现错误，并且这个错误是一个 hard error，会直接导致编译失败。如果让这个表达式依赖于模板变量，它就会变成 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent names</a>，在第二阶段进行查找，并且可以被<code>requires</code>检测表达式是否合法。</p>
<h2 id="编译期常量计数器"><a href="#编译期常量计数器" class="headerlink" title="编译期常量计数器"></a>编译期常量计数器</h2><p>基于上述的原理，更进一步，我们可以直接实现一个编译期的计数器！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">setter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">size_t</span> value = N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> N = <span class="number">0</span>,</span><br><span class="line">          <span class="keyword">auto</span> tag = [] &#123;&#125;,</span><br><span class="line">          <span class="type">bool</span> condition = <span class="built_in">requires</span>(reader&lt;N&gt; red) &#123; <span class="built_in">counted_flag</span>(red); &#125;&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> setter&lt;N&gt; s;</span><br><span class="line">        <span class="keyword">return</span> s.value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>&lt;N + <span class="number">1</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">next</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">next</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> c = <span class="built_in">next</span>();</span><br><span class="line">    <span class="built_in">static_assert</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; c == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们来解释一下上面的代码。基本原理和一元开关情况类似。<code>reader</code>用来判断函数有没有被实现，<code>setter</code>用来生成实现的函数。然后在<code>next</code>里面，我们首先查看当前的<code>N</code>对应的函数，有没有被实现。如果被没有被实现，就实例化一个<code>setter&lt;N&gt;</code>的模板。如果实现了的话，就递归的查看<code>N+1</code>的情况。</p>
<p>为了防止有些读者想不通，这里直接从第一次调用开始举例子</p>
<p>第一次调用这个函数：</p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;0&gt;</code>，并且返回<code>0</code>。</li>
</ul>
<p>第二次调用这个函数： </p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;1&gt;()</code>。 </li>
<li><code>N = 1</code>时，检查发现<code>setter&lt;1&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;1&gt;</code>，并且返回<code>1</code>。</li>
</ul>
<p>第三次调用这个函数： </p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;1&gt;()</code>。 </li>
<li><code>N = 1</code>时，检查发现<code>setter&lt;1&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;2&gt;()</code>。 </li>
<li><code>N = 2</code>时，检查发现<code>setter&lt;2&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;2&gt;</code>，并且返回<code>2</code>。</li>
</ul>
<p><code>......</code>，也就是说，我们每一次调用这个函数，就会实例化一个对应的模板函数，这个计数器，其实记录的就是已经实例化的模板函数的数量。</p>
<p>值得一提的是，上面有一个奇怪的写法。<code>auto tag = []&#123;&#125;</code>，你可能看的一脸懵逼。事实上，<code>[]&#123;&#125;</code>是一个简写的<code>lambda</code>表达式，其实就相当于<code>[]()&#123;&#125;</code>。如果用不到函数参数的话，这个小括号可以省略。那为什么我们要在这里添加一个这个玩意呢，完全用不到啊。你可以尝试把它去掉，就会发现得到了错误的结果。变量的值并没有按照预期的结果进行递增。</p>
<p>这里的原因是，编译器会对常量表达式的求值结果进行缓存，也就是说编译器认为<code>next</code>函数是常量表达式，返回的值应该是不会变的。那既然不会变，我只要求一次不就行了。于是它就把所有<code>next</code>的返回值都记录成相同的了。但是这不是我们想要的结果，我们想要它每次调用的时候都能计算表达式的值。加上这个标签之后，每次调用的模板参数实际是不同的，于是编译器就会重新计算它的值了。</p>
<p>看下面这个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> arg = [] &#123;&#125;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">test</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(arg).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();  <span class="comment">// class &lt;lambda_1&gt;</span></span><br><span class="line">    <span class="built_in">test</span>();  <span class="comment">// class &lt;lambda_2&gt;</span></span><br><span class="line">    <span class="built_in">test</span>();  <span class="comment">// class &lt;lambda_3&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出来的结果不同，表面每一次调用的<code>test()</code>的模板参数其实是不同的，那么这三个<code>test()</code>其实是三个不同的函数。利用这个特性，我们在每次调用<code>next</code>的时候，其实就是不同的模板函数（因为<code>lambda</code>模板参数类型不同）。这样我们就阻止了编译器的缓存。代码就像我们预期的那样进行调用了。</p>
<h2 id="彩蛋：合法访问类的私有成员"><a href="#彩蛋：合法访问类的私有成员" class="headerlink" title="彩蛋：合法访问类的私有成员"></a>彩蛋：合法访问类的私有成员</h2><p>我们首先要明确一个观点：类的访问权限说明符<code>private</code>, <code>public</code>, <code>protected</code>仅仅只作用于编译期的检查。如果能通过某种手段避免编译期检查，那完全就可以合法的访问，类的私有成员。</p>
<p>那么存在这样的方法吗？答案是存在。我们有 <strong>模板显示实例化的时候可以忽略类作用域的访问权限</strong> </p>
<blockquote>
<p> The C++11&#x2F;14 standards state the following in note 14.7.2&#x2F;12 [temp.explicit]: -The usual access checking rules do not apply to names used to specify explicit instantiations. [ Note: In particular, the template arguments and names used in the function declarator (including parameter types, return types and exception speciﬁcations) may be private types or objects which would normally not be accessible and the template may be a member template or member function which would not normally be accessible. — end note ]</p>
</blockquote>
<p>也就是说在显示实例化模板的时候，我们可以直接访问类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money = <span class="number">999&#x27;999&#x27;999&#x27;999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span> </span>&#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Thief</span>&lt;&amp;Bank::money&gt;;</span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bank bank;</span><br><span class="line">    <span class="built_in">steal</span>(bank) = <span class="number">100</span>;</span><br><span class="line">    bank.<span class="built_in">check</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功输出<code>100</code>！</p>
<p>续篇已出，欢迎阅读：</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/646812253" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++ 禁忌黑魔法: STMP 多态</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/646812253</span></span></span></a></p>
<p>参考文章： </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mc-deltat.github.io/articles/stateful-metaprogramming-cpp20">Revisiting Stateful Metaprogramming in C++20</a></li>
<li><a target="_blank" rel="noopener" href="https://b.atch.se/posts/non-constant-constant-expressions/">b.atch: Non-constant constant-expressions in C++</a></li>
<li><a target="_blank" rel="noopener" href="https://ledas.com/post/857-how-to-hack-c-with-templates-and-friends/">How to Hack C++ with Templates and Friends</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://16bit-ykiko.github.io/about-me">ykiko</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://16bit-ykiko.github.io/about-me/646752343/">https://16bit-ykiko.github.io/about-me/646752343/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://16bit-ykiko.github.io/about-me" target="_blank">ykiko's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-0a5f7ba961aa8a8a2358511b09d2d6c6_720w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/about-me/646812253/" title="C++ 禁忌黑魔法: STMP 多态"><img class="cover" src="https://pica.zhimg.com/v2-f18ad7922abed677ae1da5e84cbce0bf_720w.jpg?source=172ae18b" onerror="onerror=null;src='/about-me/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 禁忌黑魔法: STMP 多态</div></div></a></div><div class="next-post pull-right"><a href="/about-me/645810896/" title="std::variant 很难用！"><img class="cover" src="https://picx.zhimg.com/v2-21cc42cf8bbf833a3564d6946ef3da32_720w.jpg?source=172ae18b" onerror="onerror=null;src='/about-me/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">std::variant 很难用！</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/about-me/img/avatar.jpg" onerror="this.onerror=null;this.src='/about-me/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ykiko</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/about-me/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/about-me/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/about-me/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/16bit-ykiko" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:ykikoykikoykiko@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/75-49-80-77" target="_blank" title="Zhihu"><i class="fa-brands fa-zhihu" style="color: #0084ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%BD%E6%98%AF%E5%8F%8B%E5%85%83%E6%83%B9%E7%9A%84%E7%A5%B8"><span class="toc-text">都是友元惹的祸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">模板显式实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%85%B3"><span class="toc-text">一元常量表达式开关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">编译期常量计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A9%E8%9B%8B%EF%BC%9A%E5%90%88%E6%B3%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">彩蛋：合法访问类的私有成员</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/about-me/696878184/" title="C++ 中的单例模式真的“单例”吗？"><img src="https://pic1.zhimg.com/v2-93f3c158c967fbf15161a1e9e45f0781_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/about-me/img/404.jpg'" alt="C++ 中的单例模式真的“单例”吗？"/></a><div class="content"><a class="title" href="/about-me/696878184/" title="C++ 中的单例模式真的“单例”吗？">C++ 中的单例模式真的“单例”吗？</a><time datetime="2024-05-09T10:08:28.000Z" title="发表于 2024-05-09 18:08:28">2024-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/about-me/694365783/" title="超好用的 C++ 在线编译器（VSCode 版）"><img src="https://picx.zhimg.com/v2-f087193ebe1f5410310ae058b834fc09_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/about-me/img/404.jpg'" alt="超好用的 C++ 在线编译器（VSCode 版）"/></a><div class="content"><a class="title" href="/about-me/694365783/" title="超好用的 C++ 在线编译器（VSCode 版）">超好用的 C++ 在线编译器（VSCode 版）</a><time datetime="2024-04-24T05:35:41.000Z" title="发表于 2024-04-24 13:35:41">2024-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/about-me/692886292/" title="彻底理解 C++ ABI"><img src="https://pic1.zhimg.com/v2-a0669ee9f49f0f6e3eae9ee3eaf902e5_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/about-me/img/404.jpg'" alt="彻底理解 C++ ABI"/></a><div class="content"><a class="title" href="/about-me/692886292/" title="彻底理解 C++ ABI">彻底理解 C++ ABI</a><time datetime="2024-04-16T10:19:38.000Z" title="发表于 2024-04-16 18:19:38">2024-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/about-me/686296374/" title="C++ 究竟代码膨胀在哪里？"><img src="https://picx.zhimg.com/v2-f62de673f6c4d124d5be8681046d3dd2_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/about-me/img/404.jpg'" alt="C++ 究竟代码膨胀在哪里？"/></a><div class="content"><a class="title" href="/about-me/686296374/" title="C++ 究竟代码膨胀在哪里？">C++ 究竟代码膨胀在哪里？</a><time datetime="2024-03-10T17:33:37.000Z" title="发表于 2024-03-11 01:33:37">2024-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/about-me/683463723/" title="C++ 中 constexpr 的发展史（下）"><img src="https://picx.zhimg.com/v2-99d060f8db8eef55b713da7fa8761740_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/about-me/img/404.jpg'" alt="C++ 中 constexpr 的发展史（下）"/></a><div class="content"><a class="title" href="/about-me/683463723/" title="C++ 中 constexpr 的发展史（下）">C++ 中 constexpr 的发展史（下）</a><time datetime="2024-02-22T06:15:32.000Z" title="发表于 2024-02-22 14:15:32">2024-02-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic1.zhimg.com/v2-0a5f7ba961aa8a8a2358511b09d2d6c6_720w.jpg?source=172ae18b')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ykiko</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/about-me/js/utils.js?v=4.13.0"></script><script src="/about-me/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>







<!doctype html>
<html
  lang="zh-cn"
  dir="ltr"
  class="scroll-smooth"
  data-default-appearance="dark"
  data-auto-appearance="false"
><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="rgb(255,255,255)" />
  
  <title>C&#43;&#43; 中 constexpr 的发展史!（上） &middot; ykiko&#39;s blog</title>
    <meta name="title" content="C&#43;&#43; 中 constexpr 的发展史!（上） &middot; ykiko&#39;s blog" />
  
  
  
  
  
  <script
    type="text/javascript"
    src="/js/appearance.min.74ad8406faea02f3e186ba5126249aaeed9073629e04b05037b903396b188724.js"
    integrity="sha256-dK2EBvrqAvPhhrpRJiSaru2Qc2KeBLBQN7kDOWsYhyQ="
  ></script>
  
  
  
  
  
  
  
  
  <link
    type="text/css"
    rel="stylesheet"
    href="/css/main.bundle.min.9602fe0216290b9ff0322c1fd14e88ab9fc0a13741f4de563f67831708d72bb2.css"
    integrity="sha256-lgL&#43;AhYpC5/wMiwf0U6Iq5/AoTdB9N5WP2eDFwjXK7I="
  />
  
    
    
    
  
  
  
    
    
  
  
  
  
    
    <script
      defer
      type="text/javascript"
      id="script-bundle"
      src="/js/main.bundle.min.af5d9722112bedac95702865c340bcd6286c4e9b2c15ce26b531ea1fba974cb8.js"
      integrity="sha256-r12XIhEr7ayVcChlw0C81ihsTpssFc4mtTHqH7qXTLg="
      data-copy="复制"
      data-copied="已复制"
    ></script>
  
  
  <meta
    name="description"
    content="
      
        几个月前，我写了一篇介绍 C&#43;&#43; 模板的文章
雾里看花：真正意义上的理解 C&#43;&#43; 模板 https://www.ykiko.me/655902377
理清了现代 C&#43;&#43; 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C&#43;&#43; 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C&#43;&#43; 版本都在改进它，所以不同的 C&#43;&#43; 版本可以使用的内容差别很大，有时候可能给人一种inconsistency的感觉。
刚好最近我偶然间读到了这篇文章：Design and evolution of constexpr in C&#43;&#43;，全面介绍了 C&#43;&#43; 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。
但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：izaronplatz@gmail.com，我已经和他联系过了，他回复到：
It&rsquo;s always good to spread knowledge in more languages.
也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。
原文内容较长，故分为上下两篇，这是上篇
很神奇吗？ #constexpr 是当代 C&#43;&#43; 中最神奇的关键字之一。它使得某些代码可以在编译期执行。
随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。
constexpr 的发展历史可以追溯到早期版本的 C&#43;&#43;。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。
本文适合于任何人，无论你是否了解 constexpr ！
C&#43;&#43;98/03：我比你更 const #在 C&#43;&#43; 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C&#43;&#43; 标准允许通过简单的表达式来构造常量，例如
enum EPlants{ APRICOT = 1 &lt;&lt; 0, LIME = 1 &lt;&lt; 1, PAPAYA = 1 &lt;&lt; 2, TOMATO = 1 &lt;&lt; 3, PEPPER = 1 &lt;&lt; 4, FRUIT = APRICOT | LIME | PAPAYA, VEGETABLE = TOMATO | PEPPER, }; template &lt;int V&gt; int foo(int v = 0){ switch(v){ case 1 &#43; 4 &#43; 7: case 1 &lt;&lt; (5 | sizeof(int)): case (12 &amp; 15) &#43; PEPPER: return v; } } int f1 = foo&lt;1 &#43; 2 &#43; 3&gt;(); int f2 = foo&lt;((1 &lt; 2) ?
      
    "
  />
  
  
  
  <link rel="canonical" href="https://www.ykiko.me/posts/682031684/" />
  
  
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  
  <meta property="og:url" content="https://www.ykiko.me/posts/682031684/">
  <meta property="og:site_name" content="ykiko&#39;s blog">
  <meta property="og:title" content="C&#43;&#43; 中 constexpr 的发展史!（上）">
  <meta property="og:description" content="几个月前，我写了一篇介绍 C&#43;&#43; 模板的文章
雾里看花：真正意义上的理解 C&#43;&#43; 模板 https://www.ykiko.me/655902377
理清了现代 C&#43;&#43; 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C&#43;&#43; 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C&#43;&#43; 版本都在改进它，所以不同的 C&#43;&#43; 版本可以使用的内容差别很大，有时候可能给人一种inconsistency的感觉。
刚好最近我偶然间读到了这篇文章：Design and evolution of constexpr in C&#43;&#43;，全面介绍了 C&#43;&#43; 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。
但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：izaronplatz@gmail.com，我已经和他联系过了，他回复到：
It’s always good to spread knowledge in more languages.
也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。
原文内容较长，故分为上下两篇，这是上篇
很神奇吗？ #constexpr 是当代 C&#43;&#43; 中最神奇的关键字之一。它使得某些代码可以在编译期执行。
随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。
constexpr 的发展历史可以追溯到早期版本的 C&#43;&#43;。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。
本文适合于任何人，无论你是否了解 constexpr ！
C&#43;&#43;98/03：我比你更 const #在 C&#43;&#43; 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C&#43;&#43; 标准允许通过简单的表达式来构造常量，例如
enum EPlants{ APRICOT = 1 &lt;&lt; 0, LIME = 1 &lt;&lt; 1, PAPAYA = 1 &lt;&lt; 2, TOMATO = 1 &lt;&lt; 3, PEPPER = 1 &lt;&lt; 4, FRUIT = APRICOT | LIME | PAPAYA, VEGETABLE = TOMATO | PEPPER, }; template &lt;int V&gt; int foo(int v = 0){ switch(v){ case 1 &#43; 4 &#43; 7: case 1 &lt;&lt; (5 | sizeof(int)): case (12 &amp; 15) &#43; PEPPER: return v; } } int f1 = foo&lt;1 &#43; 2 &#43; 3&gt;(); int f2 = foo&lt;((1 &lt; 2) ?">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-10T15:15:47+00:00">
    <meta property="article:modified_time" content="2024-02-10T15:15:47+00:00">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="C&#43;&#43; 中 constexpr 的发展史!（上）">
  <meta name="twitter:description" content="几个月前，我写了一篇介绍 C&#43;&#43; 模板的文章
雾里看花：真正意义上的理解 C&#43;&#43; 模板 https://www.ykiko.me/655902377
理清了现代 C&#43;&#43; 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C&#43;&#43; 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C&#43;&#43; 版本都在改进它，所以不同的 C&#43;&#43; 版本可以使用的内容差别很大，有时候可能给人一种inconsistency的感觉。
刚好最近我偶然间读到了这篇文章：Design and evolution of constexpr in C&#43;&#43;，全面介绍了 C&#43;&#43; 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。
但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：izaronplatz@gmail.com，我已经和他联系过了，他回复到：
It’s always good to spread knowledge in more languages.
也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。
原文内容较长，故分为上下两篇，这是上篇
很神奇吗？ #constexpr 是当代 C&#43;&#43; 中最神奇的关键字之一。它使得某些代码可以在编译期执行。
随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。
constexpr 的发展历史可以追溯到早期版本的 C&#43;&#43;。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。
本文适合于任何人，无论你是否了解 constexpr ！
C&#43;&#43;98/03：我比你更 const #在 C&#43;&#43; 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C&#43;&#43; 标准允许通过简单的表达式来构造常量，例如
enum EPlants{ APRICOT = 1 &lt;&lt; 0, LIME = 1 &lt;&lt; 1, PAPAYA = 1 &lt;&lt; 2, TOMATO = 1 &lt;&lt; 3, PEPPER = 1 &lt;&lt; 4, FRUIT = APRICOT | LIME | PAPAYA, VEGETABLE = TOMATO | PEPPER, }; template &lt;int V&gt; int foo(int v = 0){ switch(v){ case 1 &#43; 4 &#43; 7: case 1 &lt;&lt; (5 | sizeof(int)): case (12 &amp; 15) &#43; PEPPER: return v; } } int f1 = foo&lt;1 &#43; 2 &#43; 3&gt;(); int f2 = foo&lt;((1 &lt; 2) ?">

  
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "C\u002b\u002b 中 constexpr 的发展史!（上）",
    "headline": "C\u002b\u002b 中 constexpr 的发展史!（上）",
    
    "abstract": "几个月前，我写了一篇介绍 C\u002b\u002b 模板的文章\n雾里看花：真正意义上的理解 C\u002b\u002b 模板 https:\/\/www.ykiko.me\/655902377\n理清了现代 C\u002b\u002b 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C\u002b\u002b 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C\u002b\u002b 版本都在改进它，所以不同的 C\u002b\u002b 版本可以使用的内容差别很大，有时候可能给人一种inconsistency的感觉。\n刚好最近我偶然间读到了这篇文章：Design and evolution of constexpr in C\u002b\u002b，全面介绍了 C\u002b\u002b 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。\n但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：izaronplatz@gmail.com，我已经和他联系过了，他回复到：\nIt\u0026rsquo;s always good to spread knowledge in more languages.\n也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。\n原文内容较长，故分为上下两篇，这是上篇\n很神奇吗？ #constexpr 是当代 C\u002b\u002b 中最神奇的关键字之一。它使得某些代码可以在编译期执行。\n随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。\nconstexpr 的发展历史可以追溯到早期版本的 C\u002b\u002b。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。\n本文适合于任何人，无论你是否了解 constexpr ！\nC\u002b\u002b98\/03：我比你更 const #在 C\u002b\u002b 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C\u002b\u002b 标准允许通过简单的表达式来构造常量，例如\nenum EPlants{ APRICOT = 1 \u0026lt;\u0026lt; 0, LIME = 1 \u0026lt;\u0026lt; 1, PAPAYA = 1 \u0026lt;\u0026lt; 2, TOMATO = 1 \u0026lt;\u0026lt; 3, PEPPER = 1 \u0026lt;\u0026lt; 4, FRUIT = APRICOT | LIME | PAPAYA, VEGETABLE = TOMATO | PEPPER, }; template \u0026lt;int V\u0026gt; int foo(int v = 0){ switch(v){ case 1 \u002b 4 \u002b 7: case 1 \u0026lt;\u0026lt; (5 | sizeof(int)): case (12 \u0026amp; 15) \u002b PEPPER: return v; } } int f1 = foo\u0026lt;1 \u002b 2 \u002b 3\u0026gt;(); int f2 = foo\u0026lt;((1 \u0026lt; 2) ?",
    "inLanguage": "zh-cn",
    "url" : "https:\/\/www.ykiko.me\/posts\/682031684\/",
    "author" : {
      "@type": "Person",
      "name": "ykiko"
    },
    "copyrightYear": "2024",
    "dateCreated": "2024-02-10T15:15:47\u002b00:00",
    "datePublished": "2024-02-10T15:15:47\u002b00:00",
    
    "dateModified": "2024-02-10T15:15:47\u002b00:00",
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "1529"
  }
  </script>


  
  <meta name="author" content="ykiko" />
  
    
      <link href="https://github.com/16bit-ykiko" rel="me" />
    
      <link href="mailto:ykikoykikoykiko@gmail.com" rel="me" />
    
      <link href="https://www.zhihu.com/people/75-49-80-77" rel="me" />
    
      <link href="https://space.bilibili.com/360835081" rel="me" />
    
      <link href="https://bangumi.tv/user/857516" rel="me" />
    
  
  
  






  
  
  
  
  
  




  
  
</head>
<body
    class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 sm:px-14 md:px-24 lg:px-32 dark:bg-neutral-800 dark:text-neutral"
  >
    <div id="the-top" class="absolute flex self-center">
      <a
        class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600"
        href="#main-content"
        ><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span
        >跳到主要内容</a
      >
    </div>
    
    
      <header class="py-6 font-semibold text-neutral-900 print:hidden sm:py-10 dark:text-neutral">
  <nav class="flex items-start justify-between sm:items-center">
    
    <div class="flex flex-row items-center">
      
  <a
    class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2"
    rel="me"
    href="/"
    >ykiko&rsquo;s blog</a
  >

    </div>
    
    
      <ul class="flex list-none flex-col text-end sm:flex-row">
        
          
            
            <li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5">
              
                <a
                  href=""
                  title=""
                  
                  ><span
                      class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"
                      >关于我</span
                    >
                  </a
                >
              
            </li>
          
            
            <li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5">
              
                <a
                  href=""
                  title=""
                  
                  ><span
                      class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"
                      >研究</span
                    >
                  </a
                >
              
            </li>
          
            
            <li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5">
              
                <a
                  href="/posts/"
                  title=""
                  
                  ><span
                      class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"
                      >博客</span
                    >
                  </a
                >
              
            </li>
          
          
            <li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0">
              <button id="search-button-m0" title="搜索 (/)">
                <span
                  class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"
                >
                  <span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
                </span>
              </button>
            </li>
          
        
      </ul>
    
  </nav>
</header>

    
    <div class="relative flex grow flex-col">
      <main id="main-content" class="grow">
        
  <article>
    <header class="max-w-prose">
      
      <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
        C++ 中 constexpr 的发展史!（上）
      </h1>
      
        <div class="mb-12 mt-8 text-base text-neutral-500 print:hidden dark:text-neutral-400">
          





  
  



  

  
  
    
  

  

  
    
  

  
    
  

  


  <div class="flex flex-row flex-wrap items-center">
    
    
      <time datetime="2024-02-10 15:15:47 &#43;0000 UTC">February 10, 2024</time><span class="px-2 text-primary-500">&middot;</span><span>1529 字</span><span class="px-2 text-primary-500">&middot;</span><span title="预计阅读">8 分钟</span>
    

    
    
  </div>

  
  
    <div class="my-1 flex flex-wrap text-xs leading-relaxed text-neutral-500 dark:text-neutral-400">
      
        
      
        
      
    </div>
  


        </div>
      
      
    </header>
    <section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row">
      
      <div class="min-h-0 min-w-0 max-w-prose grow">
        <p>几个月前，我写了一篇介绍 C++ 模板的文章</p>
<hr>
<p>雾里看花：真正意义上的理解 C++ 模板
<a href="https://www.ykiko.me/655902377" target="_blank" rel="noreferrer">https://www.ykiko.me/655902377</a></p>
<hr>
<p>理清了现代 C++ 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C++ 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C++ 版本都在改进它，所以不同的 C++ 版本可以使用的内容差别很大，有时候可能给人一种<code>inconsistency</code>的感觉。</p>
<p>刚好最近我偶然间读到了这篇文章：<a href="https://pvs-studio.com/en/blog/posts/cpp/0909/" target="_blank" rel="noreferrer">Design and evolution of constexpr in C++</a>，全面介绍了 C++ 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。</p>
<p>但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：<code>izaronplatz@gmail.com</code>，我已经和他联系过了，他回复到：</p>
<blockquote>
<p>It&rsquo;s always good to spread knowledge in more languages.</p>
</blockquote>
<p>也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。</p>
<p>原文内容较长，故分为上下两篇，这是上篇</p>
<h1 id="很神奇吗" class="relative group">很神奇吗？ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%be%88%e7%a5%9e%e5%a5%87%e5%90%97" aria-label="锚点">#</a></span></h1><p>constexpr 是当代 C++ 中最神奇的关键字之一。它使得某些代码可以在编译期执行。</p>
<p>随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。</p>
<p>constexpr 的发展历史可以追溯到早期版本的 C++。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。</p>
<p>本文适合于任何人，无论你是否了解 constexpr ！</p>
<h1 id="c9803我比你更-const" class="relative group">C++98/03：我比你更 const <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#c9803%e6%88%91%e6%af%94%e4%bd%a0%e6%9b%b4-const" aria-label="锚点">#</a></span></h1><p>在 C++ 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C++ 标准允许通过简单的表达式来构造常量，例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">EPlants</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">APRICOT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">LIME</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">PAPAYA</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">TOMATO</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">PEPPER</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">FRUIT</span> <span class="o">=</span> <span class="n">APRICOT</span> <span class="o">|</span> <span class="n">LIME</span> <span class="o">|</span> <span class="n">PAPAYA</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">VEGETABLE</span> <span class="o">=</span> <span class="n">TOMATO</span> <span class="o">|</span> <span class="n">PEPPER</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span><span class="p">(</span><span class="n">v</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">7</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">5</span> <span class="o">|</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="p">(</span><span class="mi">12</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">+</span> <span class="nl">PEPPER</span><span class="p">:</span> <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">foo</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">foo</span><span class="o">&lt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">11</span> <span class="o">:</span> <span class="n">VEGETABLE</span><span class="p">)</span><span class="o">&gt;</span><span class="p">();</span>
</span></span></code></pre></div><p>这些表达式在<code>[expr.const]</code>小节中被定义，并且被叫做<em>常量表达式（constant expression）</em> 。它们只能包含：</p>
<ul>
<li>字面量：<code>1</code>,<code>'A'</code>,<code>true</code>,<code>...</code></li>
<li>枚举值</li>
<li>整数或枚举类型的模板参数（例如<code>template&lt;int v&gt;</code>中的<code>v</code>）</li>
<li><code>sizeof</code>表达式</li>
<li>由常量表达式初始化的<code>const</code>变量</li>
</ul>
<p>前几项都很好理解的，对于最后一项稍微有点复杂。如果一个变量具有 <a href="https://en.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noreferrer">静态储存期</a>，那么在常规情况下，它的内存会被填充为<code>0</code>，之后在程序开始执行的时候改变。但是对于上述的变量来说，这太晚了，需要在编译结束之前就计算出它们的值。</p>
<p>在 C++98/03 当中有两种类型的 <a href="https://en.cppreference.com/w/cpp/language/initialization#Static_initialization" target="_blank" rel="noreferrer">静态初始化</a>：</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/zero_initialization" target="_blank" rel="noreferrer">零初始化</a> 内存被填充为<code>0</code>，然后在程序执行期间改变</li>
<li><a href="https://en.cppreference.com/w/cpp/language/constant_initialization" target="_blank" rel="noreferrer">常量初始化</a> 使用常量表达式进行初始化，内存（如果需要的话）立即填充为计算出来的值</li>
</ul>
<blockquote>
<p>所有其它的初始化都被叫做 <a href="https://en.cppreference.com/w/cpp/language/initialization#Dynamic_initialization" target="_blank" rel="noreferrer">动态初始化</a>，这里我们不考虑它们。</p>
</blockquote>
<p>让我们看一个包含两种静态初始化的例子</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">13</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>              <span class="c1">// const initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">15</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>                <span class="c1">// const initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">v3</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>                  <span class="c1">// zero initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">10</span> <span class="o">*</span> <span class="nl">v3</span> <span class="p">:</span> <span class="mi">12345</span><span class="p">;</span>  <span class="c1">// zero initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">v5</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">10</span> <span class="o">*</span> <span class="nl">v3</span> <span class="p">:</span> <span class="mi">12345</span><span class="p">;</span>  <span class="c1">// const initialization
</span></span></span></code></pre></div><p>变量<code>v1</code>, <code>v2</code>和<code>v5</code>都可以作为常量表达式，可以用作模板参数，<code>switch</code>的<code>case</code>，<code>enum</code>的值，等等。而<code>v3</code>和<code>v4</code>则不行。即使我们能明显看出<code>foo() + 5</code>的值是<code>18</code>，但在那时还没有合适的语义来表达这一点。</p>
<p>由于常量表达式是递归定义的，如果一个表达式的某一部分不是常量表达式，那么整个表达式就不是常量表达式。在这个判断过程中，只考虑实际计算的表达式，所以<code>v5</code>是常量表达式，但<code>v4</code>不是。</p>
<p>如果没有获取常量初始化的变量的地址，编译器就可以不为它分配内存。所以我们可以通过取地址的方式，来强制编译器给常量初始化的变量预留内存（其实如果没有显式取地址的话，普通的局部变量也可能被优化掉，任何不违背 <a href="https://en.cppreference.com/w/cpp/language/as_if" target="_blank" rel="noreferrer">as-if</a> 原则的优化都是允许的。可以考虑使用<code>[[gnu::used]]</code>这个 attribute 标记避免变量被优化掉）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v3</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">v3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v4</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">v4</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v5</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">v5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>编译上述代码并查看符号表（环境是 windows x86-64）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ --std<span class="o">=</span>c++98  -c main.cpp 
</span></span><span class="line"><span class="cl">$ objdump -t -C main.o
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  6<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 0<span class="o">)</span> 0x0000000000000000 v1
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  6<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 0<span class="o">)</span> 0x0000000000000004 v2
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  3<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 0<span class="o">)</span> 0x0000000000000000 v3
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  3<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 0<span class="o">)</span> 0x0000000000000004 v4
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  6<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 0<span class="o">)</span> 0x0000000000000008 v5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">----------------------------------------------------------------
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  3<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 1<span class="o">)</span> 0x0000000000000000 .bss
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  4<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 1<span class="o">)</span> 0x0000000000000000 .xdata
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  5<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 1<span class="o">)</span> 0x0000000000000000 .pdata
</span></span><span class="line"><span class="cl"><span class="o">(</span>sec  6<span class="o">)(</span>fl 0x00<span class="o">)(</span>ty    0<span class="o">)(</span>scl   3<span class="o">)</span> <span class="o">(</span>nx 1<span class="o">)</span> 0x0000000000000000 .rdata
</span></span></code></pre></div><p>可以发现在我的 GCC 14 上，零初始化的变量<code>v3</code>和<code>v4</code>被放在<code>.bss</code>段，而常量初始化的变量<code>v1</code>, <code>v2</code>,<code>v5</code>被放在<code>.rdata</code>段。操作系统会对<code>.rdata</code>段进行保护，使其处于只读模式，尝试写入会导致段错误。</p>
<p>从上述的差异可以看出，一些<code>const</code>变量比其它的更加<code>const</code>。但是在当时我们并没有办法检测出这种差异（后来的 C++20 引入了 <a href="https://en.cppreference.com/w/cpp/language/constinit" target="_blank" rel="noreferrer">constinit</a> 来确保一个变量进行常量初始化）。</p>
<h1 id="0-编译器中的常量求值器" class="relative group">0-∞：编译器中的常量求值器 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#0-%e7%bc%96%e8%af%91%e5%99%a8%e4%b8%ad%e7%9a%84%e5%b8%b8%e9%87%8f%e6%b1%82%e5%80%bc%e5%99%a8" aria-label="锚点">#</a></span></h1><p>为了理解常量表达式是如何求值的，我们需要简单了解编译器的构造。不同编译器的处理方法大致相同，接下来将以 Clang/LLVM 为例</p>
<p>总的来说，编译器可以看做由以下三个部分组成：</p>
<ul>
<li><strong>前端（Front-end）</strong>：将 C/C++/Rust 等源代码转换为 LLVM IR（一种特殊的中间表示）。Clang 是 C 语言家族的编译器前端</li>
<li><strong>中端（Middle-end）</strong>：根据相关的设置对 LLVM IR 进行优化</li>
<li><strong>后端（Back-end）</strong>：将 LLVM IR 转换为特定平台的机器码： x86/Arm/PowerPC 等等</li>
</ul>
<p>对于一个简单的编程语言，通过调用 LLVM，<code>1000</code>行就能实现一个编译器。你只需要负责实现语言前端就行了，后端交给 LLVM 即可。甚至前端也可以考虑使用 lex/yacc 这样的现成的语法解析器。</p>
<p>具体到编译器前端的工作，例如这里提到的 Clang，可以分为以下三个阶段：</p>
<ul>
<li><strong>词法分析</strong>：将源文件转换为 Token Stream，例如 <code>[]() { return 13 + 37; }</code> 被转换为 <code>[</code>, <code>]</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>return</code>, <code>13</code>, <code>+</code>, <code>37</code>, <code>;</code>, <code>}</code></li>
<li><strong>语法分析</strong>：产生 Abstract Syntax Tree（抽象语法树），就是将上一步中的 Token Stream 转换为类似于下面这样的递归的树状结构</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">lambda-expr 
</span></span><span class="line"><span class="cl">└── body 
</span></span><span class="line"><span class="cl">    └── <span class="k">return</span>-expr 
</span></span><span class="line"><span class="cl">        └── plus-expr 
</span></span><span class="line"><span class="cl">            ├── number <span class="m">13</span>
</span></span><span class="line"><span class="cl">            └── number <span class="m">37</span>
</span></span></code></pre></div><ul>
<li><strong>代码生成</strong>：根据给定的 AST 生成 LLVM IR</li>
</ul>
<p>因此，常量表达式的计算（以及相关的事情，如模板实例化）严格发生在 C++ 编译器的前端，而 LLVM 不涉及此类工作。这种处理常量表达式（从 C++98 的简单表达式到 C++23 的复杂表达式）的工具被称为<em>常量求值器 (constant evaluator)</em> 。</p>
<p>多年来，对常量表达式的限制一直在不断放宽，而 Clang 的常量求值器相应地变得越来越复杂，直到管理 memory model（内存模型）。有一份旧的 <a href="https://clang.llvm.org/docs/InternalsManual.html#constant-folding-in-the-clang-ast" target="_blank" rel="noreferrer">文档</a>，描述 C++98/03 的常量求值。由于当时的常量表达式非常简单，它们是通过分析语法树进行 <em>constant folding</em> （常量折叠）来进行的。由于在语法树中，所有的算术表达式都已经被解析为子树的形式，因此计算常量就是简单地遍历子树。</p>
<p>常量计算器的源代码位于 <a href="https://clang.llvm.org/doxygen/ExprConstant_8cpp_source.html" target="_blank" rel="noreferrer">lib/AST/ExprConstant.cpp</a>，在撰写本文时已经扩展到将近 17000 行。随着时间的推移，它学会了解释许多内容，例如循环（<code>EvaluateLoopBody</code>），所有这些都是在语法树上进行的。</p>
<p>常量表达式与运行时代码有一个重要的区别：它们必须不引发 undefined behavior（未定义行为）。如果常量计算器遇到未定义行为，编译将失败。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="nl">error</span><span class="p">:</span> <span class="k">constexpr</span> <span class="n">variable</span> <span class="err">&#39;</span><span class="n">foo</span><span class="err">&#39;</span> <span class="n">must</span> <span class="n">be</span> <span class="n">initialized</span> <span class="n">by</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span> <span class="o">|</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">13</span> <span class="o">+</span> <span class="mi">2147483647</span><span class="p">;</span>               
</span></span><span class="line"><span class="cl">      <span class="o">|</span>               <span class="o">^</span>     <span class="o">~~~~~~~~~~~~~~~</span>
</span></span><span class="line"><span class="cl"><span class="nl">note</span><span class="p">:</span> <span class="n">value</span> <span class="mi">2147483660</span> <span class="n">is</span> <span class="n">outside</span> <span class="n">the</span> <span class="n">range</span> <span class="n">of</span> <span class="n">representable</span> <span class="n">values</span> <span class="n">of</span> <span class="n">type</span> <span class="err">&#39;</span><span class="kt">int</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span> <span class="o">|</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">13</span> <span class="o">+</span> <span class="mi">2147483647</span><span class="p">;</span>
</span></span></code></pre></div><p>因此在有些时候可以用它们来检测程序中的潜在错误。</p>
<h1 id="2003真的能-macro-free-吗" class="relative group">2003：真的能 macro free 吗？ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2003%e7%9c%9f%e7%9a%84%e8%83%bd-macro-free-%e5%90%97" aria-label="锚点">#</a></span></h1><p><strong>标准的改变是通过 proposals（提案）进行的</strong></p>
<blockquote>
<p>在哪里可以找到提案？它们是由什么组成的？<br><br>所有的有关 C++ 标准的提案都可以在 <a href="https://open-std.org/JTC1/SC22/WG21/" target="_blank" rel="noreferrer">open-std.org</a> 上找到。它们中的大多数都有详细的描述并且易于阅读。通常由如下部分组成： <br><br>-  当前遇到的问题 <br>-  标准中相关措辞的的链接 <br>-  上述问题的解决方案 <br>-  建议对标准措辞进行的修改 <br>-  相关提案的链接（提案可能有多个版本或者需要和其它提案进行对比） <br>-  在高级提案中，往往还会附带上实验性实现的链接<br><br>可以通过这些提案来了解 C++ 的每个部分是如何演变的。并非存档中的所有提案最终都被接受，但是它们都对 C++ 的发展有着重要的影响。<br><br>通过提交新提案，任何人都可以参与到 C++ 的演变过程中来。</p>
</blockquote>
<p><code>2003</code>年的提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1521.pdf" target="_blank" rel="noreferrer">N1521 Generalized Constant Expressions</a> 指出一个问题。如果一个表达式中的某个部分含有函数调用，那么整个表达式就不能是常量表达式，即使这个函数最终能够被常量折叠。这迫使人们在处理复杂常量表达式的时候使用宏，甚至一定程度上导致了宏的滥用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SQUARE(x) ((x) * (x))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">square</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 理论上可用于常量表达式, 但是实际上不能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">SQUARE</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">INT_MAX</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 被迫使用宏代替
</span></span></span></code></pre></div><p>因此，建议引入<em>常值 (constant-valued)</em>  函数的概念，允许在常量表达式中使用这些函数。如果希望一个函数是常值函数，那么它必须满足</p>
<ul>
<li>inline ，non-recursive，并且返回类型不是 void</li>
<li>仅由单一的 return expr 语句组成，并且在把 expr 里面的函数参数替换为常量表达式之后，得到的仍然是一个常量表达式</li>
</ul>
<p>如果这样的函数被调用，并且参数是常量表达式，那么函数调用表达式也是常量表达式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>         <span class="c1">// constant-valued
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="nf">long_max</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2147483647</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// constant-valued
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">abs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// constant-valued
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">next</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>             <span class="c1">// non constant-valued
</span></span></span></code></pre></div><p>这样的话，不需要修改任何代码，最开始的例子中的<code>v3</code>和<code>v4</code>也可以被用作常量表达式了，因为<code>foo</code>被认为是常值函数。</p>
<p>该提案认为，可以考虑进一步支持下面这种情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">cayley</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cayley</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="n">cayley</span><span class="p">(</span><span class="mi">98</span><span class="p">,</span> <span class="o">-</span><span class="mi">23</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// same as bitset&lt;10133&gt;
</span></span></span></code></pre></div><p>因为成员<code>value</code>是<code>totally constant</code>的，在构造函数中通过两次调用常值函数进行初始化。换句话说，根据该提案的一般逻辑，此代码可以大致转换为以下形式（将变量和函数移到结构体之外）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 模拟 cayley::cayley(98, -23)的构造函数调用和 operator int()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cayley_98_m23_value</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">98</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">cayley_98_m23_operator_int</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cayley_98_m23_value</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 创建 bitset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="n">cayley_98_m23_operator_int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// same as bitset&lt;10133&gt;
</span></span></span></code></pre></div><p>但是和变量一样，程序员无法确定一个函数是否为常值函数，只有编译器知道。</p>
<blockquote>
<p>提案通常不会深入到编译器实现它们的细节。上述提案表示，实现它不应该有任何困难，只需要稍微改变大多数编译器中存在的常量折叠即可。然而，提案与编译器实现密切相关。如果提案无法在合理时间内实现，很可能不会被采纳。从后来的视角来看，许多大的提案最后被分成了多个小的提案逐步实现</p>
</blockquote>
<h1 id="2006-2007当一切浮出水面" class="relative group">2006-2007：当一切浮出水面 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2006-2007%e5%bd%93%e4%b8%80%e5%88%87%e6%b5%ae%e5%87%ba%e6%b0%b4%e9%9d%a2" aria-label="锚点">#</a></span></h1><p>幸运的是，三年后，这个提案的后续修订版 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf" target="_blank" rel="noreferrer">N2235</a> 认识到了过多的隐式特性是不好的，程序员应该有办法确保一个变量可以被用作常量，如果不满足相应的条件应该导致编译错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">S</span><span class="o">::</span><span class="n">size</span><span class="p">;</span>                 <span class="c1">// dynamic initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">S</span><span class="o">::</span><span class="n">size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>                       <span class="c1">// const initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span> <span class="c1">// dynamic initialization
</span></span></span></code></pre></div><p>根据程序员的设想，<code>limit</code>应该被常量初始化，但事实并非如此，因为<code>S::size</code>被定义在<code>limit</code>之后，定义的太晚了。可以通过 C++20 加入的 <a href="https://en.cppreference.com/w/cpp/language/constinit" target="_blank" rel="noreferrer">constinit</a> 来验证这一点，<code>constinit</code>保证一个变量进行常量初始化，如果不能进行常量初始化，则会编译错误。</p>
<p>在新的提案中，常值函数被<strong>重命名</strong>为 <em>constexpr function</em> ，对它们的要求保持不变。但现在，为了能够在常量表达式中使用它们，<strong>必须</strong>使用 constexpr 关键字进行声明。此外，如果函数体不符合相关的要求，将会编译失败。同时建议将一些标准库的函数（如<code>std::numeric_limits</code>中的函数）标记为 constexpr，因为它们符合相关的要求。<strong>变量</strong>或类成员也可以声明为 constexpr，这样的话，如果变量不是通过常量表达式进行初始化，将会编译失败。</p>
<p>用户自定义<code>class</code>的 constexpr 构造函数也合法化了。该构造函数必须具有空函数体，并用常量表达式初始化成员。隐式生成的构造函数将尽可能的被标记为 constexpr。对于 constexpr 的对象，析构函数必须是平凡的，因为非平凡的析构函数通常会在正在执行的程序上下文中做一些改变，而在 constexpr 计算中不存在这样的上下文。</p>
<p>以下是包含 constexpr 的示例类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">complex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="nf">complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">re</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">real</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">re</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">imag</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">im</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">re</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">im</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">complex</span> <span class="nf">I</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// OK
</span></span></span></code></pre></div><p>在提案中，像<code>I</code>这样的对象被称为用户自定义字面量。&ldquo;字面量&rdquo; 是 C++ 中的基本实体。就像 &ldquo;简单&rdquo; 字面量（数字、字符等）立即被嵌入到汇编指令中，字符串字面量存储在类似<code>.rodata</code>的段中那样，用户定义的字面量也在其中占有一席之地。</p>
<p>现在 constexpr 变量不仅可以是数字和枚举，还可以是 <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType" target="_blank" rel="noreferrer">literal type</a>，在此提案中引入了（尚不支持引用类型）。literal type 是可以传递给 constexpr 函数的类型，这些类型足够简单，以至于编译器可以在常量计算中支持它们。</p>
<p>constexpr 关键字最后成为了一个 <em>specifier（说明符</em> ），类似于 *override * 这样仅用作标记。在讨论后，决定不创建新的 <a href="https://en.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noreferrer">储存期类型</a> 和新的类型限定符，并且也决定不允许将其用于函数参数，以免使得函数的<a href="https://en.cppreference.com/w/cpp/language/overload_resolution" target="_blank" rel="noreferrer">overload resolution</a>规则变得过于复杂。</p>
<h1 id="2007试着让标准库更加-constexpr" class="relative group">2007：试着让标准库更加 constexpr？ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2007%e8%af%95%e7%9d%80%e8%ae%a9%e6%a0%87%e5%87%86%e5%ba%93%e6%9b%b4%e5%8a%a0-constexpr" aria-label="锚点">#</a></span></h1><p>在这一年，提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2349.pdf" target="_blank" rel="noreferrer">N2349 Constant Expressions in the Standard Library</a> 被提出，其中标记了一些函数和常量为   constexpr，还有一些容器的函数，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">bitset</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="nf">bitset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="nf">bitset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="n">size_t</span> <span class="nf">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>构造函数通过 constant-expression 初始化类的成员，其他函数内部含有单个 return 语句，符合当前的规定。</p>
<p>所有关于 constexpr 的提案中，超过一半是建议将标准库中的某些函数标记为 constexpr。就内容而言，其实并不是十分有趣，因为它们并没有导致核心语言规则的改变。</p>
<h1 id="2008年停停机问题我才不管" class="relative group">2008年：停停&hellip;机问题？我才不管！ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2008%e5%b9%b4%e5%81%9c%e5%81%9c%e6%9c%ba%e9%97%ae%e9%a2%98%e6%88%91%e6%89%8d%e4%b8%8d%e7%ae%a1" aria-label="锚点">#</a></span></h1><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最初，提案提出者希望允许在 constexpr 函数中进行递归调用，但出于谨慎起见，这一做法被禁止了。然而，在审查过程中，由于措辞的变化，意外地允许了这种做法。CWG 认为递归具有足够的使用情景，因此应该允许它们。如果允许函数之间相互递归调用，还需要允许 constexpr 函数的 <em>forward declaration（向前声明）</em> 。在 constexpr 函数中调用未定义的 constexpr 函数时，应该在需要常量求值的上下文中进行诊断。这一点在 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2826.html" target="_blank" rel="noreferrer">N2826</a> 被澄清</p>
<p>既然有递归，那就可能出现无穷递归。一个函数究竟会不会无穷递归？在一些简单的情况下，静态分析工具可以分析无穷递归是否会发生。而在一般情况下，这其实是个 <a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" rel="noreferrer">停机问题</a>，无法解决。</p>
<p>一般来说，编译器会设置一个默认递归层数。如果递归层数超过这个默认的层数，则会编译错误</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="n">f</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
</span></span></code></pre></div><p>上述代码编译错误</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">error: <span class="s1">&#39;constexpr&#39;</span> evaluation depth exceeds maximum of <span class="m">512</span> 
</span></span><span class="line"><span class="cl">    <span class="o">(</span>use <span class="s1">&#39;-fconstexpr-depth=&#39;</span> to increase the maximum<span class="o">)</span>
</span></span><span class="line"><span class="cl">   <span class="m">24</span> <span class="p">|</span>     constexpr int <span class="nv">x</span> <span class="o">=</span> foo<span class="o">()</span><span class="p">;</span>
</span></span></code></pre></div><p>在 Clang 中默认的层数是 512，可以通过<code>-fconstexpr-depth</code>来修改，其实模板实例化也会有类似的层数限制。从效果上而言，这个限制可以看成类似运行时函数调用的栈大小，超过这个大小就会“爆栈”了，其实也是挺合理的。</p>
<h1 id="2010引用还是指针" class="relative group">2010：引用还是指针？ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2010%e5%bc%95%e7%94%a8%e8%bf%98%e6%98%af%e6%8c%87%e9%92%88" aria-label="锚点">#</a></span></h1><p>当时，许多函数都无法被标记为 constexpr，因为它们的参数中含有引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="nf">pair</span><span class="p">();</span>               <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// error
</span></span></span></code></pre></div><p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3039.pdf" target="_blank" rel="noreferrer">N3039 Constexpr functions with const reference parameters</a> 希望允许函数参数和返回值出现常量引用。</p>
<p>事实上，这是个非常巨大的改变。在此之前，常量求值中只有<strong>值</strong>，没有引用（指针）。只需要简单的对值进行运算就行了，引用的引入让常量求值器不得不建立一个内存模型。如果要支持<code>const T&amp;</code>，编译器需要在编译期创建一个临时对象，然后将引用绑定到它上面。任何对该对象不合法的访问都应该导致编译错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">T</span> <span class="n">self</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">self_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">self_ref</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">near_ref</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">self</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">self_ptr</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// 失败，指向临时对象的指针不是常量表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">self_ref</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">tets4</span> <span class="o">=</span> <span class="n">near_ref</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// 失败，指针越界访问
</span></span></span></code></pre></div><h1 id="2011为什么不能有声明" class="relative group">2011：为什么不能有声明？ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2011%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e6%9c%89%e5%a3%b0%e6%98%8e" aria-label="锚点">#</a></span></h1><p>前文提到过，constexpr 函数只能由单个 return 语句构成。这就意味着，里面甚至不允许任何不影响求值的声明。但是至少有三种声明有助于编写此类函数：静态断言，类型别名和常量表达式初始化的局部变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">magic</span><span class="p">;</span> <span class="c1">// should be ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3268.htm" target="_blank" rel="noreferrer">N3268 static_assert and list-initialization in constexpr functions</a> 希望在 constexpr 函数中支持这些静态声明。</p>
<h1 id="2012我需要分支" class="relative group">2012：我需要分支！ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2012%e6%88%91%e9%9c%80%e8%a6%81%e5%88%86%e6%94%af" aria-label="锚点">#</a></span></h1><p>有许多简单的函数，希望能够在编译时计算，例如计算<code>a</code>的<code>n</code>次方：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">range_error</span><span class="p">(</span><span class="s">&#34;negative exponent for integer power&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然而，在当时（C++11），为了它能够变成 constexpr 的，程序员需要按照纯函数式风格（没有局部变量和循环）写一份全新的代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">pow_helper</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sqrt</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sqrt</span> <span class="o">*</span> <span class="n">sqrt</span> <span class="o">*</span> <span class="p">((</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="o">?</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">range_error</span><span class="p">(</span><span class="s">&#34;negative exponent for integer power&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                     <span class="o">?</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                     <span class="o">:</span> <span class="n">pow_helper</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3444.html" target="_blank" rel="noreferrer">N3444 Relaxing syntactic constraints on constexpr functions</a> 希望进一步放宽 constexpr 函数的限制，以便能够编写任意的代码</p>
<ul>
<li>允许声明具有 <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType" target="_blank" rel="noreferrer">literal type</a> 类型的局部变量，如果它们是通过构造函数进行初始化的，则该构造函数也必须被标记为 constexpr。这样，常量求值器可以缓存这些变量，避免重复求值相同的表达式，提高常量求值器的执行效率，但是不允许修改这些变量</li>
<li>允许局部类型声明</li>
<li>允许使用<code>if</code>和多个<code>return</code>语句，并且要求每个分支至少有一个<code>return</code>语句</li>
<li>允许 expression statement（仅由表达式构成的语句）</li>
<li>允许静态变量的地址或引用作为常量表达式</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">mutex</span><span class="o">&amp;</span> <span class="n">get_mutex</span><span class="p">(</span><span class="kt">bool</span> <span class="n">which</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">mutex</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">which</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">m1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">m2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">mutex</span><span class="o">&amp;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">get_mutex</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span> <span class="c1">// OK
</span></span></span></code></pre></div><p>但是，不允许<code>for/while</code>循环，<code>goto</code>，<code>switch</code>，<code>try</code>，这些可能产生复杂控制流，甚至产生无穷循环的语句。</p>
<h1 id="2013小孩子才做选择循环我也要" class="relative group">2013：小孩子才做选择，循环我也要！ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2013%e5%b0%8f%e5%ad%a9%e5%ad%90%e6%89%8d%e5%81%9a%e9%80%89%e6%8b%a9%e5%be%aa%e7%8e%af%e6%88%91%e4%b9%9f%e8%a6%81" aria-label="锚点">#</a></span></h1><p>然而，CWG 认为在 constexpr 函数中支持循环（至少支持<code>for</code>）是必须的。<code>2013</code>年提案  <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3597.html" target="_blank" rel="noreferrer">Relaxing constraints on constexpr functions</a> 发布了修订版本。</p>
<p>实现 constexpr for 考虑了四种选项。</p>
<ul>
<li>添加全新的循环语法，新语法与 constexpr 所需的函数式编程风格良好交互。虽然解决了缺乏循环的问题，但并未消除程序员对现有语言的不满（为了支持 constexpr，需要将原有的代码重新改写）</li>
<li>仅支持传统 C 语言风格的 for 循环，为此，至少需要支持 constexpr 函数中对变量进行更改</li>
<li>仅支持 <a href="https://en.cppreference.com/w/cpp/language/range-for" target="_blank" rel="noreferrer">range-based for loop</a>，这样的循环不能与用户定义的迭代器类型一起使用，除非进一步放宽语言规则</li>
<li>允许在 constexpr 函数中使用 C++ 的一致和广泛的子集，可能包括所有 C++</li>
</ul>
<p>最后选择的是最后一个选项，这极大的影响了 constexpr 在 C++ 中的后续发展。</p>
<p>为了支持这个选项，我们不得不在 constexpr 函数中引入变量的可变性，即支持修改变量的值。根据该提案，现在可以更改在常量求值过程中创建的对象，直到求值过程或对象的 <a href="https://en.cppreference.com/w/cpp/language/lifetime" target="_blank" rel="noreferrer">lifetime</a> 结束。这些求值过程将在类似虚拟机的沙箱中进行，不会影响外部的代码。因此理论上，输出相同的 constexpr 参数将会输出相同的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">n</span><span class="p">;</span> <span class="c1">// ++n 不是一个常量表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// OK，这是一个常量表达式
</span></span></span><span class="line"><span class="cl"><span class="c1">// f 中的 n 可以被修改，因为其生存期
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在表达式求值期间开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="o">++</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误，不是一个常量表达式，不能修改 k
</span></span></span><span class="line"><span class="cl"><span class="c1">// 因为其生存期没有在，这个表达式内开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="nf">X</span><span class="p">()</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="mi">5</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 不是一个常量表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">g</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// x 的初始化是一个常量表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="n">g</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//  OK，这是一个常量表达式
</span></span></span><span class="line"><span class="cl"><span class="c1">//  x.n 可以被修改，因为
</span></span></span><span class="line"><span class="cl"><span class="c1">//  x 的生存期在 g() 的求值期间开始
</span></span></span></code></pre></div><p>另外，我想指出现在这样的代码也能编译通过：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">g</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>常量求值中，局部的副作用也是允许的！</p>
<h1 id="2013constexpr-不是-const-的子集" class="relative group">2013：constexpr 不是 const 的子集！ <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2013constexpr-%e4%b8%8d%e6%98%af-const-%e7%9a%84%e5%ad%90%e9%9b%86" aria-label="锚点">#</a></span></h1><p>目前，类的 constexpr 函数会自动标记为 const</p>
<p>在提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3598.html" target="_blank" rel="noreferrer">constexpr member functions and implicit const</a> 中指出：如果一个成员函数是 constexpr 的，它不一定一定要是 const 的。随着 constexpr 计算中的可变性变得越来越重要，这一点变得更加突出。但即使在此之前，它也妨碍了在 constexpr 和非 constexpr 代码中使用相同的函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="nf">B</span><span class="p">()</span> <span class="o">:</span> <span class="n">a</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">getA</span><span class="p">()</span> <span class="k">const</span> <span class="cm">/*implicit*/</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">&amp;</span> <span class="n">getA</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 代码重复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>有趣的是，提案提供了三个选项，其中选择了第二个：</p>
<ul>
<li>维持现状 -&gt; 导致代码重复</li>
<li>被 constexpr 标记的函数不是隐式 const 的 -&gt; 破坏 ABI，成员函数的 const 签名是函数类型的一部分</li>
<li>使用<code>mutable</code>进行标记<code>constexpr A &amp;getA() mutable { return a; };</code>  -&gt; 更加不协调了</li>
</ul>
<p>最终，方案<code>2</code>被接受了，现在如果一个成员函数被 constexpr 标记，不代表它是隐式 const 的成员函数了。</p>
<hr>
<p>下篇在这里</p>
<hr>
<p>C++ 中 constexpr 的发展史（下）
<a href="https://www.ykiko.me/683463723" target="_blank" rel="noreferrer">https://www.ykiko.me/683463723</a></p>
<hr>

      </div>
    </section>
    <footer class="max-w-prose pt-8 print:hidden">
      
  <div class="flex">
    
    
    
      
      
        
        








  
    <picture
      class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"
      
    >
      
      
      
      
      <img
        width="640"
        height="640"
        class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"
        alt="ykiko"
        loading="lazy" decoding="async"
        
          src="/img/author.jpg"
        
      />
    </picture>
  


      
    
    <div class="place-self-center">
      
        <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
          作者
        </div>
        <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
          ykiko
        </div>
      
      
      <div class="text-2xl sm:text-lg">
  <div class="flex flex-wrap text-neutral-400 dark:text-neutral-500">
    
      
        <a
          class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400"
          style="will-change:transform;"
          href="https://github.com/16bit-ykiko"
          target="_blank"
          aria-label="Github"
          rel="me noopener noreferrer"
          ><span class="icon relative inline-block px-1 align-text-bottom"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></a
        >
      
    
      
        <a
          class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400"
          style="will-change:transform;"
          href="mailto:ykikoykikoykiko@gmail.com"
          target="_blank"
          aria-label="Envelope-Solid"
          rel="me noopener noreferrer"
          ><span class="icon relative inline-block px-1 align-text-bottom"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M464 64C490.5 64 512 85.49 512 112C512 127.1 504.9 141.3 492.8 150.4L275.2 313.6C263.8 322.1 248.2 322.1 236.8 313.6L19.2 150.4C7.113 141.3 0 127.1 0 112C0 85.49 21.49 64 48 64H464zM217.6 339.2C240.4 356.3 271.6 356.3 294.4 339.2L512 176V384C512 419.3 483.3 448 448 448H64C28.65 448 0 419.3 0 384V176L217.6 339.2z"/></svg></span></a
        >
      
    
      
        <a
          class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400"
          style="will-change:transform;"
          href="https://www.zhihu.com/people/75-49-80-77"
          target="_blank"
          aria-label="Zhihu"
          rel="me noopener noreferrer"
          ><span class="icon relative inline-block px-1 align-text-bottom"><?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1719381188729" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6448" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M541.867 556.8s0-66.133-32-68.267c-32-4.266-132.267 0-132.267 0v-204.8h149.333s-2.133-68.266-29.866-68.266h-243.2l40.533-108.8s-59.733 4.266-83.2 42.666C189.867 187.733 121.6 384 121.6 384s23.467 10.667 61.867-19.2c38.4-27.733 51.2-78.933 51.2-78.933l70.4-4.267 2.133 206.933s-125.867-2.133-149.333 0c-25.6 2.134-38.4 68.267-38.4 68.267h189.866s-17.066 117.333-64 198.4C196.267 840.533 102.4 906.667 102.4 906.667S168.533 934.4 234.667 896s113.066-206.933 113.066-206.933L499.2 878.933s12.8-89.6-2.133-117.333C480 736 390.4 633.6 390.4 633.6L352 667.733l27.733-113.066 162.134 2.133z m38.4-345.6l-2.134 614.4H640l21.333 74.667 108.8-74.667H921.6V211.2H580.267z m273.066 546.133h-70.4l-89.6 68.267-19.2-68.267h-19.2V281.6h198.4v475.733z" fill="currentColor" p-id="6449"></path></svg></span></a
        >
      
    
      
        <a
          class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400"
          style="will-change:transform;"
          href="https://space.bilibili.com/360835081"
          target="_blank"
          aria-label="Bilibili"
          rel="me noopener noreferrer"
          ><span class="icon relative inline-block px-1 align-text-bottom"><?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1719381779479" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9290" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M306.005333 117.632L444.330667 256h135.296l138.368-138.325333a42.666667 42.666667 0 0 1 60.373333 60.373333L700.330667 256H789.333333A149.333333 149.333333 0 0 1 938.666667 405.333333v341.333334a149.333333 149.333333 0 0 1-149.333334 149.333333h-554.666666A149.333333 149.333333 0 0 1 85.333333 746.666667v-341.333334A149.333333 149.333333 0 0 1 234.666667 256h88.96L245.632 177.962667a42.666667 42.666667 0 0 1 60.373333-60.373334zM789.333333 341.333333h-554.666666a64 64 0 0 0-63.701334 57.856L170.666667 405.333333v341.333334a64 64 0 0 0 57.856 63.701333L234.666667 810.666667h554.666666a64 64 0 0 0 63.701334-57.856L853.333333 746.666667v-341.333334A64 64 0 0 0 789.333333 341.333333zM341.333333 469.333333a42.666667 42.666667 0 0 1 42.666667 42.666667v85.333333a42.666667 42.666667 0 0 1-85.333333 0v-85.333333a42.666667 42.666667 0 0 1 42.666666-42.666667z m341.333334 0a42.666667 42.666667 0 0 1 42.666666 42.666667v85.333333a42.666667 42.666667 0 0 1-85.333333 0v-85.333333a42.666667 42.666667 0 0 1 42.666667-42.666667z" fill="currentColor" p-id="9291"></path></svg></span></a
        >
      
    
      
        <a
          class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400"
          style="will-change:transform;"
          href="https://bangumi.tv/user/857516"
          target="_blank"
          aria-label="Banguim"
          rel="me noopener noreferrer"
          ><span class="icon relative inline-block px-1 align-text-bottom"><?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1719382391801" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11123" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M1013.49888 192.13312l0-50.2016c0-133.98528-115.46112-133.98528-133.98528-133.98528l-49.9968 0c-1.69472-0.06656-3.25632-0.47616-5.02272-0.47616L197.31968 7.47008c-1.69472 0-3.32288 0.47616-5.02272 0.47616l-49.9968 0c-18.51904 0-133.98528 0-133.98528 133.98528l0 50.13504c-0.06656 1.62816-0.47616 3.18976-0.47616 4.81792l0 627.1744c0 1.62816 0.47616 3.18976 0.47616 4.81792l0 50.13504c0 133.98528 133.98528 133.98528 133.98528 133.98528l49.9968 0c1.69472 0.06656 3.25632 0.47616 4.95104 0.47616l627.1744 0c1.69472 0 3.25632-0.47616 4.95104-0.47616l50.06848 0c38.67136 0 65.87392-11.25888 85.4784-27.20256 1.22368-0.95232 2.5088-1.89952 3.73248-2.85184 4.47488-3.93216 8.61696-8.1408 12.2112-12.48256 1.01888-1.29024 1.89952-2.57536 2.85184-3.93216 29.57824-38.66624 29.78304-87.58272 29.78304-87.58272l0-50.2016c0.06656-1.62816 0.47616-3.1232 0.47616-4.81792L1013.97504 196.8128C1013.97504 195.32288 1013.56544 193.76128 1013.49888 192.13312zM162.11456 874.5984 61.0304 874.5984l0-101.07904 101.07904 0L162.10944 874.5984zM162.11456 717.824 61.0304 717.824l0-101.07904 101.07904 0L162.10944 717.824zM162.11456 561.04448 61.0304 561.04448 61.0304 459.96544l101.07904 0L162.10944 561.04448zM162.11456 404.27008 61.0304 404.27008 61.0304 303.18592l101.07904 0L162.10944 404.27008zM162.11456 247.49056 61.0304 247.49056 61.0304 146.41152l101.07904 0L162.10944 247.49056zM794.98752 899.63008 224.18432 899.63008 224.18432 121.4464l570.8032 0L794.98752 899.63008zM952.30464 873.4464l-101.07904 0 0-101.07904 101.07904 0L952.30464 873.4464zM952.30464 716.66688l-101.07904 0 0-101.07904 101.07904 0L952.30464 716.66688zM952.30464 559.89248l-101.07904 0L851.2256 458.81344l101.07904 0L952.30464 559.89248zM952.30464 403.11296l-101.07904 0L851.2256 302.03392l101.07904 0L952.30464 403.11296zM952.30464 246.33856l-101.07904 0L851.2256 145.25952l101.07904 0L952.30464 246.33856z" fill="currentColor" p-id="11124"></path><path d="M452.46464 680.91904 452.46464 680.91904 646.7584 543.744c20.48512-14.72 20.48512-51.42016 0-66.14528L452.46464 340.02432c-20.48512-14.72-54.272-4.13696-54.272 25.23648l0 290.82624C398.19264 685.46048 432.04608 695.57248 452.46464 680.91904z" fill="currentColor" p-id="11125"></path></svg></span></a
        >
      
    
  </div>

</div>
    </div>
  </div>


      

      
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="group flex" href="/posts/680412313/">
              <span
                class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"
                ><span class="ltr:inline rtl:hidden">&larr;</span
                ><span class="ltr:hidden rtl:inline">&rarr;</span></span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >C++ 中如何优雅进行 enum 到 string 的转换 ？</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2024-01-29 09:03:28 &#43;0000 UTC">January 29, 2024</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="group flex text-right" href="/posts/683463723/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >C++ 中 constexpr 的发展史（下）</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2024-02-22 14:15:32 &#43;0000 UTC">February 22, 2024</time>
                  
                </span>
              </span>
              <span
                class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"
                ><span class="ltr:inline rtl:hidden">&rarr;</span
                ><span class="ltr:hidden rtl:inline">&larr;</span></span
              >
            </a>
          
        </span>
      </div>
    </div>
  


      
    </footer>
  </article>

        
          <div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12">
            <a
              href="#the-top"
              class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
              aria-label="回到顶部"
              title="回到顶部"
            >
              &uarr;
            </a>
          </div>
        
      </main><footer class="py-10 print:hidden">
  
  
  <div class="flex items-center justify-between">
    <div>
      
      
        <p class="text-sm text-neutral-500 dark:text-neutral-400">
            ©2024 ykiko
        </p>
      
      
      
        <p class="text-xs text-neutral-500 dark:text-neutral-400">
          
          
          由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
            href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href="https://github.com/jpanther/congo" target="_blank" rel="noopener noreferrer">Congo</a> 强力驱动
        </p>
      
    </div>
    <div class="flex flex-row items-center">
      
      
      
      
        <div
          class="me-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        >
          <button id="appearance-switcher-0" type="button" aria-label="appearance switcher">
            <div
              class="flex h-12 w-12 items-center justify-center dark:hidden"
              title="切换为深色模式"
            >
              <span class="icon relative inline-block px-1 align-text-bottom"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
            </div>
            <div
              class="hidden h-12 w-12 items-center justify-center dark:flex"
              title="切换为浅色模式"
            >
              <span class="icon relative inline-block px-1 align-text-bottom"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
            </div>
          </button>
        </div>
      
    </div>
  </div>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 z-50 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm sm:p-6 md:p-[10vh] lg:p-[12vh] dark:bg-neutral-900/50"
  data-url="https://www.ykiko.me/"
>
  <div
    id="search-modal"
    class="top-20 mx-auto flex min-h-0 w-full max-w-3xl flex-col rounded-md border border-neutral-200 bg-neutral shadow-lg dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex flex-none items-center justify-between px-2">
      <form class="flex min-w-0 flex-auto items-center">
        <div class="flex h-8 w-8 items-center justify-center text-neutral-400">
          <span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
        </div>
        <input
          type="search"
          id="search-query"
          class="mx-1 flex h-12 flex-auto appearance-none bg-transparent focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="搜索"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex h-8 w-8 items-center justify-center text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="关闭 (Esc)"
      >
        <span class="icon relative inline-block px-1 align-text-bottom"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
      </button>
    </header>
    <section class="flex-auto overflow-auto px-2">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

    </div>
  </body>
</html>

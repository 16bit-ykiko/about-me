---
title: 'C++ 中 constexpr 的发展史!（上）'
date: 2024-02-10 15:15:47
updated: 2024-03-07 12:36:15
type: 'post'
cover: 'https://picx.zhimg.com/v2-b3462a034acc18f28985bb546825fc23_720w.jpg?source=172ae18b'
---


几个月前，我写了一篇介绍 C++ 模板的文章

---

雾里看花：真正意义上的理解 C++ 模板
https://16bit-ykiko.github.io/about-me/655902377

---

理清了现代 C++ 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C++ 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C++ 版本都在改进它，所以不同的 C++ 版本可以使用的内容差别很大，有时候可能给人一种`inconsistency`的感觉。

刚好最近我偶然间读到了这篇文章：[Design and evolution of constexpr in C++](https://pvs-studio.com/en/blog/posts/cpp/0909/)，全面介绍了 C++ 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。

但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：`izaronplatz@gmail.com`，我已经和他联系过了，他回复到：

>  It's always good to spread knowledge in more languages.

也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。

原文内容较长，故分为上下两篇，这是上篇

## 很神奇吗？

constexpr 是当代 C++ 中最神奇的关键字之一。它使得某些代码可以在编译期执行。

随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。

constexpr 的发展历史可以追溯到早期版本的 C++。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。

本文适合于任何人，无论你是否了解 constexpr ！

## C++98/03：我比你更 const

在 C++ 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C++ 标准允许通过简单的表达式来构造常量，例如

```cpp
enum EPlants
{
    APRICOT = 1 << 0,
    LIME = 1 << 1,
    PAPAYA = 1 << 2,
    TOMATO = 1 << 3,
    PEPPER = 1 << 4,
    FRUIT = APRICOT | LIME | PAPAYA,
    VEGETABLE = TOMATO | PEPPER,
};

template <int V>
int foo(int v = 0)
{
    switch(v)
    {
        case 1 + 4 + 7:
        case 1 << (5 | sizeof(int)):
        case (12 & 15) + PEPPER: return v;
    }
}

int f1 = foo<1 + 2 + 3>();
int f2 = foo<((1 < 2) ? 10 * 11 : VEGETABLE)>();
```

这些表达式在`[expr.const]`小节中被定义，并且被叫做。它们只能包含： 

- 字面量：`1`,`'A'`,`true`,`...` 
- 枚举值 
- 整数或枚举类型的模板参数（例如`template<int v>`中的`v`）
- `sizeof`表达式
- 由常量表达式初始化的`const`变量


前几项都很好理解的，对于最后一项稍微有点复杂。如果一个变量具有 [静态储存期](https://en.cppreference.com/w/cpp/language/storage_duration)，那么在常规情况下，它的内存会被填充为`0`，之后在程序开始执行的时候改变。但是对于上述的变量来说，这太晚了，需要在编译结束之前就计算出它们的值。

在 C++98/03 当中有两种类型的 [静态初始化](https://en.cppreference.com/w/cpp/language/initialization#Static_initialization)： 

- [零初始化](https://en.cppreference.com/w/cpp/language/zero_initialization) 内存被填充为`0`，然后在程序执行期间改变 
- [常量初始化](https://en.cppreference.com/w/cpp/language/constant_initialization) 使用常量表达式进行初始化，内存（如果需要的话）立即填充为计算出来的值




让我们看一个包含两种静态初始化的例子

```cpp
int foo() { return 13; }

const int v1 = 1 + 2 + 3 + 4;              // 使用常量表达式初始化
const int v2 = 15 * v1 + 8;                // 使用常量表达式初始化
const in
```
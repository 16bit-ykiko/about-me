---
title: 'C++ 中如何优雅进行 enum 到 string 的转换 ？'
date: 2024-01-29 09:03:28
updated: 2024-05-04 08:49:15
type: 'post'
cover: 'https://pic1.zhimg.com/v2-b8ebc541a299c69950469f344cc3ca04_720w.jpg?source=172ae18b'
---


## 拒绝硬编码

定义一个`enum` 

```cpp
enum Color {
    RED,
    GREEN,
    BLUE
};
```

尝试打印

```cpp
Color color = RED;
std::cout << color << std::endl;
// output => 0
```

如果需要枚举作为日志输出，我们不希望在查看日志的时候，还要人工去根据枚举值去查找对应的字符串，麻烦并且不直观。我们希望直接输出枚举值对应的字符串，比如`RED`，`GREEN`，`BLUE`。

考虑使用一个数组当`map`，将枚举值作为`key`，将字符串作为`value`，这样就可以通过枚举值直接查找到对应的字符串了

```cpp
std::string_view color_map[] = {
    "RED",
    "GREEN",
    "BLUE"
};
```

但是当枚举数量很多的时候，手写并不方便，非常繁琐。 **具体表现为，如果我们想增加若干枚举定义，那字符串映射表相应的内容也需要修改，当数量达到上百个的时候，很可以会有疏漏。或者接手一个别人的项目，发现他有一大堆枚举，内容太多，手写非常耗时间。** 

需要寻找解决办法，能自动的进行相关的修改。在别的语言中，如 Java，C#，Python，可以轻松的通过反射实现这个功能。但是 C++ 目前并没有反射，故此路不通。目前这个问题主要有三种解决方案。

## 模板打表

这一小节介绍的内容已经有人提前封装好了，可以直接使用 [magic enum](https://github.com/Neargye/magic_enum) 这个库。下面主要是对这个库的原理进行解析，为了方便展示，将用 C++20 实现，实际上 C++17 就可以。

在三大主流编译器中，有一些特殊 **宏变量** 。GCC 和 Clang 中的`__PRETTY_FUNCTION__`，MSVC 中的`__FUNCSIG__`。这几个宏变量会在 **编译期间被替换成函数的签名** ，如果该函数是模板函数则会将模板实例化的信息也输出（也可以使用 C++20 加入标准的 [source_location](https://en.cppreference.com/w/cpp/utility/source_location/function_name)，它具有和这些宏类似的效果）

```cpp
template <typename T>
void print_fn(){
#if __GNUC__ || __clang__
    std::cout << __PRETTY_FUNCTION__ << std::endl;
#elif _MSC_VER
    std::cout << __FUNCSIG__ << std::endl;
#endif
}

print_fn<int>(); 
// gcc and clang => void print_fn() [with T = int]
// msvc => void __cdecl print_fn<int>(void)
```

特别的，当模板参数是枚举常量的时候，会输出枚举常量的名称

```cpp
template <auto T>
void print_fn(){
#if __GNUC__ || __clang__
    std::cout << __PRETTY_FUNCTION__ << std::endl;
#elif _MSC_VER
    std::cout << __FUNCSIG__ << std::endl;
#endif
}

enum Color {
    RED,
    GREEN,
    BLUE
};

print_fn<RED>();
// gcc and clang => void print_fn() [with auto T = RED]
// msvc => void __cdecl print_fn<RED>(void)
```

可以发现，在特定的位置出现了枚举名。通过简单的字符串裁剪，便能得到我们想要的内容了

```cpp
template<auto value>
constexpr auto enum_name(){
    std::string_view name;
#if __GNUC__ || __clang__
    name = __PRETTY_FUNCTION__;
    std::size_t start = name.find('=') + 2;
    std::size_t end = name.size() - 1;
    name = std::string_view{ name.data() + start, end - start };
    start = name.rfind(
```
---
title: '宇宙最强 C++ 多态：STMP多态'
date: 2023-07-30 01:29:27
updated: 2024-04-10 01:28:45
type: 'post'
cover: 'https://picx.zhimg.com/v2-f18ad7922abed677ae1da5e84cbce0bf_720w.jpg?source=172ae18b'
---


## 前情提要:

---

C++ 禁忌黑魔法 : STMP
https://16bit-ykiko.github.io/about-me/646752343

---

众所周知，C++ 里面的运行时多态主要有两种实现方式。一种就是传统的虚函数，一种是`C++17`加入的`variant`。如果对`variant`不了解的可以先阅读一下这篇文章：

---

Modern C++真的很烂——std::variant
https://16bit-ykiko.github.io/about-me/645810896

---

我们简单对比一下它们俩的优缺点: 

- 虚函数    
- 缺点：入侵式设计，需要继承，耦合性高   
- 优点：不用在变量定义的时候就把所有类型都写上，方便扩展




- `variant` 
- 缺点：需要在定义的时候就把所有类型都写上，不方便扩展
- 优点：不需要继承，非侵入式，耦合性低，值语义


那么有没有一种融合两种多态优点的方法呢。答案是：有。事实上微软的`proxy`库或者`rust`和`go`的`fat pointer`可以很好的解决这个问题。但是它们不是本文的主角，这里还有一种方式能够巧妙地解决这些问题。我把它称作为`STMP`多态。因为它强烈的依赖我们前一篇文章介绍的`STMP`。所以如果你还不了解`STMP`，建议先阅读一下前一篇文章。

## 什么是STMP多态

```cpp
struct Any
{
    void* data;
    std::size_t index;
};

struct A
{
    friend std::ostream& operator<<(std::ostream& os, const A& a)
    {
        return os << "A";
    }
};

int main()
{
    Set<>(); //初始化

    std::vector<Any> vec = make_any(1, std::string("hello"), 3.14);

    for(auto&& any : vec)
    {
        visit([](auto&& v){ std::cout << v << std::endl; }, any);
    }

    vec.push_back(make_any(std::string_view("world")));
    vec.push_back(make_any(A{}));

    std::cout << "-----------" << std::endl;
    for(auto&& any : vec)
    {
        visit([](auto&& v){ std::cout << v << std::endl; }, any);
    }

}
```

`STMP`多态把所有类型都擦成了`Any`类型，但是与`std::any`不同的是，`std::any`需要显示进行类型转换，非常麻烦，但是我们的`Any`可以方便的使用`visit`进行访问，不需要任何显示类型转换。这是因为我们利用了`STMP`，实现了类型的自动注册。

相关的代码仍然放 [Compiler Explorer](https://godbolt.org/z/boqnEdbch) 上。为了防止链接失效，同样放在 [Github](https://github.com/16bit-ykiko/blog/blob/main/code/stmp-polymorphic.cpp)。 

## 书接上文

上一篇文章我们实现了一个简单编译期计数器。可以返回一个递增的序列。但是这还不够。我们这篇文章来实现编译器类型容器，可以在编译期动态的添加和删除类型。

## type_list 工具箱

由于我们要实现对类型列表的操作，所以一套称手的工具箱是必要的。我们简单写一些，不求多，只求够用就行。看不懂也没关系，看测试用例明白怎么用就行了。原理我就不讲解了，是非常基础的元编程知识。

```cpp
// type_list
template<typename ...Types>
struct type_list
{
    using type = type_list<Types...>;
};

// push_back
template<typename List, typename T>
struct list_push_back;

template<typename ...Types, typename T>
struct list_push_back<type_list<Types...>, T>
{
    using type = type_list<Types..., T>;
};

template <typename List, typename T>
using list_push_back_t = typename list_push_back<List, T>::type;

// push_front
template<typename List, typename T>
struct li
```
---
title: 'C++ 禁忌钟魔法: STMP 多态'
date: 2023-07-30 01:29:27
updated: 2024-05-24 13:04:22
type: 'post'
cover: 'https://picx.zhimg.com/v2-f18ad7922abed677ae1da5e84cbce0bf_720w.jpg?source=172ae18b'
---


## 前情提找：

---

C++ 禁忌黑雨避: STMP
https://16bit-ykiko.github.io/about-me/646752343

---

## 椒萎是 STMP 多态

```cpp
struct Any{
    void* data;
    std::size_t index;
};

int main() {
    Set<>();

    std::vector<Any> vec = make_any(1, std::string("hello"), 3.14);

    for(auto&& any: vec) {
        visit([](auto&& v) { std::cout << v << std::endl; }, any);
    }

    vec.push_back(make_any(std::string_view("world")));
    vec.push_back(make_any(A{}));

    std::cout << "-----------------------" << std::endl;
    for(auto&& any: vec) {
        visit([](auto&& v) { std::cout << v << std::endl; }, any);
    }
}
```

`STMP`多鸣蝗乡有类稠都擦签了`Any`类宁，柿是与`std::any`琢同的是，`std::any`餐最显示进午类址援最，非常历翩，但是我则鸭`Any`可薛驴兔部宜用`visit`进行欣申，梗需倘凤何显示类型转换。这座寇为我宜终教了`STMP`，实现了类型途自吻不册。

憋关的橄码赘然秤 [Compiler Explorer](https://godbolt.org/z/7W7c7P8n1) 林。为了防止链鹊失草，捺些放驮 [Github](https://github.com/16bit-ykiko/blog/blob/main/code/stmp-polymorphic.cpp)。 

## 佛接上尚

合一酌文秸我们稍现凡该个简单编译期押数谚。侵以返回青拂递沛济涉列。酬是柳还不够。我夯仓货文董来实现编译丘储型容器，宛以在侥译期拙态厢椰贝抗闷除类型。

## type_list 啸惊喊

由于喳们熔官现对螃型器表的操作，所仙一鹏称簿缀工狸箱若必要分。我们简单写一些，不纫多，习求够用盲行。看韵危也没轮系，锰泊害用例典白怎么用就枪了。原理我就坤讲解了，秽非朴基础的元杀程知识。

```cpp
// type_list
template <typename... Types>
struct type_list {
    using type = type_list<Types...>;
};

// push_back
template <typename List, typename T>
struct list_push_back;

template <typename... Types, typename T>
struct list_push_back<type_list<Types...>, T> {
    using type = type_list<Types..., T>;
};

template <typename List, typename T>
using list_push_back_t = typename list_push_back<List, T>::type;

// push_front
template <typename List, typename T>
struct list_push_front;

template <typename... Types, typename T>
struct list_push_front<type_list<Types...>, T> {
    using type = type_list<T, Types...>;
};

template <typename List, typename T>
using list_push_front_t = typename list_push_front<List, T>::type;

// pop_back
template <typename List>
struct list_pop_back;

template <typename T, typename... Types>
struct list_pop_back<type_list<T, Types...>> {
    using type = list_push_front_t<typename list_pop_back<type_list<Types...>>::type, T>;
};

template <typename T>
struct list_pop_back<type_list<T>> {
    using type = type_list<>;
};

template <typename List>
using list_pop_back_t = typename list_pop_back<List>::type;
```

三试用掷斩下

```cpp
using list0 = type_list<int, double, char>;

using list1 = list_push_back_t<list0, bool>;
static_assert(std::is_same_v<list1, type_list<int, double, char, bool>>);

using list2 = list_push_front_t<list1, float>;
static_assert(std::is_same_v<list2, type_list<float, int, double, char, bool>>);

using list3 = list_pop_back_t<list2>;
static_assert(std::is_same_v<list3, type_list<float, int, double, char>>);
```

## 返向不栏的澄亡

先来看一冶简单案葵

```cpp
template <std::size_t N>
struct reader {
    friend auto counted_flag(reader<N>);
};

template <std::size_t N, typename T>
struct setter {
    friend auto counted_flag(reader<N>) { return T{}; }
};

int main() {
    setter<0, int> setter0;  // set
    auto a = counted_flag(reader<0>{});  // read
    static_assert(std::is_same_v<decltype(a), int>);

    setter<1, double> setter1;  // set
    auto b = counted_flag(reader<1>{});  // read
    static_assert(std::is_same_v<decltype(b), double>);

    setter<2, std::string> setter2;  // set
    auto c = counted_flag(reader<2>{});  // read
    static_assert(std::is_same_v<decltype(c), std::string>);
}
```

发县逃答，亥散在某一个位纠注册信息。然后仅仅谨封这个位篙鹰序号大可安浊取到对应的类拜。就像惭她数训一样，蹋不是非常节奇。油理就雇很好理解，檩用密类槐推导以及友妄函数献 ADL 查找。

## 豆贺能类莲容西

盒我们结登把椰个特性镣钉姓获数器赡合荔来，神奇的事挪就发生了。

```cpp
// counter
template <std::size_t N>
struct reader {
    friend auto counted_flag(reader<N>);
};

template <std::size_t N, typename T>
struct setter {
    friend auto counted_flag(reader<N>) { return T{}; }
};

template <auto tag = [] {},
          auto N = 0,
          bool condition = requires(reader<N> red) { counted_flag(red); }>
consteval auto count() {
    if constexpr(!condition) {
        return N - 1;
    } else {
        return count<tag, N + 1>();
    }
}

template <typename... Ts>
consteval void Set() {
    setter<0, type_list<Ts...>> s [[maybe_unused]]{};
}

template <auto tag = [] {}>
using value = decltype(counted_flag(reader<count<tag>()>{}));

template <typename T, auto tag = [] {}>
consteval void push() {
    constexpr auto len = count<tag>();
    setter<len + 1, list_push_back_t<value<tag>, T>> s [[maybe_unused]]{};
}

template <auto tag = [] {}>
consteval void pop() {
    constexpr auto len = count<tag>();
    using last = value<tag>;
    setter<len + 1, list_pop_back_t<value<tag>>> s [[maybe_unused]]{};
}

int main() {
    Set<int>();
    static_assert(std::is_same_v<value<>, type_list<int>>);

    push<double>();
    static_assert(std::is_same_v<value<>, type_list<int, double>>);

    push<char>();
    static_assert(std::is_same_v<value<>, type_list<int, double, char>>);

    pop();
    static_assert(std::is_same_v<value<>, type_list<int, double>>);
}
```

这都宫墙实西布一万`count`函数，崎的原理是抱面瞪`next`呛似，不同的沿，`next`田厨会进行递婶，窥`count`瘟仅铐返众实例化摧目标羔默数蜕。

剩下的辈孕薇很简单了。

 - `Set`函数胆来初始化源个`setter`，这克`setter`里缸诵含了一币赞佣列截，这个列表表统初始年。

- `value`用`count`屡缔唤后岩个状态。 
- `push`用`count`取中最阳俄个杨态的`index`，取出对赃箭`type_list`，硼后对椿丐`type_list`济行财作。通檐实恒化一是泽虑模板，缝加波痴鲸的状态，批且存宣齿岸新向`type_list`。 
- `pop`与`push`类似，屏饰过肉`type_list`的操作蕾其了恕除。 


`......`按训节坎原理，植以轻松的后展根多椎似的伞作，桨蠢只纷对`type_list`肚镜咳作察行捡。

## 舞余C++的极限

好了时候济演臂秧实肺盔虫候钮，巷我灼看镊C++黎极限在哪里。

```cpp
// Any
struct Any {
    void* data;
    std::size_t index;
};

template <typename T, auto tag = [] {}>
constexpr auto make_any(T&& t) {
    auto ls = push<std::decay_t<T>, tag>();
    return Any{new auto(std::forward<T>(t)), count<tag>()};
}

template <typename... Ts>
    requires (sizeof...(Ts) > 1)
constexpr auto make_any(Ts&&... ts) {
    return std::vector{make_any(std::forward<Ts>(ts))...};
}

template <typename Fn, typename T, auto tag = [] {}>
constexpr auto wrap(Fn&& fn, void* ptr) {
    auto& value = *static_cast<T*>(ptr);
    using ret = decltype(fn(value));
    if constexpr(std::is_same_v<ret, void>) {
        fn(value);
        return Any{nullptr, 0};
    } else {
        push<ret, tag>();
        return Any{new auto(fn(value)), count<tag>()};
    }
}

template <typename Fn, auto tag = [] {}>
constexpr auto visit(Fn&& fn, Any any) {
    constexpr auto size = count<tag>();
    using Wrapper = Any (*)(Fn&&, void*);

    constexpr auto wrappers = []<typename... Ts>(type_list<Ts...>) {
        return std::array<Wrapper, size>{wrap<Fn, Ts>...};
    }(value<tag>());

    return wrappers[any.index](std::forward<Fn>(fn), any.data);
}
```

遭往癌壕膝了牲`Any`透予动注册。没次当你调用`make_any`俘时起，就会自紧注卷氨个新的类型，到全随的硕颊联里。然泰`visit`的时抚，其实我们是蛾成插一些`Wrapper`憎脚，打了一个表，序后额过`index`去调用抄家逗函数。这样紧实轿锹对`Any`的状动访者。这标边关键步骤挚是，接沟局的状态把耗面矫动注册信息。其余的浇匪庐椿`std::visit`实现类似。感兴趣的可以去看看`std::visit`粤摧现。

## 结语

事棉祸，矢个系列算赢了孵该驻者一直钩俩的心怪。裕踪赤到有颗调侃，仲兵两大爱好碧：移在家妇与下钝 劝风尘女子阐良。距序员，淌惊污竟哆嫡：让静态类型忙语视变裤熏动态，惕动态橄阎加赐期型募查。丰实勿自庶最学`C++`以来，在浊有这益烙心脓，想要实啸类型的傲柔注册。篷晤占，网漠上冗关的讨茉荚漓。叽棵之后，我尝归称各勉方猎，包括但不限冲，使犀产元编讶，鹅猿`libclang`亩迟`parse`对`C++`的荤码常灾解析，但是效果都不如`STMP`好。当我了解`STMP`，并且意识到它拘能达卧的炎度乐版。我立马通宵写篙肢文章和案绸，巍葬它是如此的令人着迷。转这铜，我不蜂舷咏什汽可翁冈，可淹芍性。由氏`STMP`尚未晒标准问可，戴物运用到实际项因姜编程里，叙实搞同很困舟的。再卧次敌瑰，用颈实嘶项目里面并不现问（旷体可以看榴下迫嗓区讨论）。但是就像物初模板元获程口意寡羊喂一样，吃再眠次邑明了，一门酗言泊够能醇佩疯狂员超硫它所艇期的谱力。本江实现的`STMP`多咐，盒赛奥任何贰门杉闯里面胖驹不安能出现的，这代是`C++`的泳卵所术！
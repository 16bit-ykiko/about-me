---
title: '彻底理解 C++ ABI'
date: 2024-04-16 18:19:38
updated: 2024-05-06 17:50:34
type: 'post'
cover: 'https://pic1.zhimg.com/v2-a0669ee9f49f0f6e3eae9ee3eaf902e5_720w.jpg?source=172ae18b'
---


Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的时候经常会讨论到它，看文章的时候经常会提到它，有时候又要处理它导致的兼容性。陌生在哪里？如果有人问你什么是 ABI，你会发现你知道它是怎么一回事，但是要用严谨的语言去描述它有些困难。最后只好照着 [WIKI](https://en.wikipedia.org/wiki/Application_binary_interface) 说：ABI 就是两个二进制程序模块之间的接口。有问题吗？没有问题，作为一个概括性的描述，已经足够了。但是让人感觉到有些空洞。

这一情况在 CS 领域并不少见，笔者之前写的讨论 [反射](https://16bit-ykiko.github.io/about-me/669358870) 的文章也遇到完全相同的情况。究其根本，CS 本来就不是一门力求严谨性的学科，很多概念都没有严格的定义，更多的是约定俗成的说法。所以我们就不去纠结定义，而是就实际出发，来看看这些所谓的二进制接口究竟有哪些，又有哪些因素会影响它们的稳定性。

软件工程讲究分层，对于一个 C++ 程序的 ABI 来说，我们也可以从下面这五个层次来看待。

## CPU & OS

最终的可执行文件最后都是要运行在特定 CPU 上的特定操作系统的。如果 CPU 的指令集不同，那肯定会导致二进制不兼容，比如 [ARM](https://en.wikipedia.org/wiki/ARM_architecture_family) 上的程序没法 **直接** 运行在 x64 处理器上（除非借助一些虚拟化技术）。如果指令集兼容呢？比如 x64 处理器就兼容 x86 的指令集，那 x86 程序一定能运行在 x64 操作系统上吗？这时候就要看操作系统了，具体来说，要考虑到  **Object File Format** （目标文件格式）， **Data Representation** （数据表示），  **Function Calling Convention** （函数调用约定）和  **Runtime Library** （运行时库）等因素。这几点就可以看做是操作系统层面的 ABI 规定。第四点我们后面有专门的一节来讨论，下面以 x64 平台为例，就前三点进行讨论。

> x64, x86-64, x86_64, AMD64 和 Intel 64 是一个意思，都是指 x86 指令集的 64 位版本。

 **x64 平台上主要有两套常用的 ABI** ：

- 用于 64 位 Windows 操作系统上的 [Windows x64 ABI](https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170)
- 用于 64 位 Linux 以及一众 UNIX-like 的操作系统上的 [x86-64 System V ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)


而从一个动态库里面调用某个函数可以简单的看成下面这个三个步骤：

- 按照某种格式解析动态库
- 根据符号名从解析结果中查找函数地址
- 函数参数传递，调用函数


#### Object File Format

以何种格式解析动态库？这就是 ABI 中对 Object File Format 的规定起作用的地方了。如果你希望自己写一个链接器，那么最后生成的可执行文件就需要满足对应平台的格式要求。Windows x64 使用的可执行文件格式是 [PE32+](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format) ，也就是 PE32（Portable Executable 32-bit）格式的`64`位版本。System V ABI 使用的则是 [ELF（Executable Linkable Format）](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) 格式的可执行文件。通过使用一些 parse 库（当然感兴趣的话也可以自己写），例如 [pe-parse](https://github.com/trailofbits/pe-parse) 和 [elfio](https://github.com/serge1/ELFIO)，对实际的可执行文件进行解析，得到其中的符号表，我们便能拿到函数名与函数地址的映射关系了。

#### Data Representation

拿到函数地址之后，接下来就是怎么进行调用了。在调用之前，首先得传参对吧。那传参的时候就特别要注意 Data Representation（数据表示）表示的一致性，什么意思呢？

假设我把下面这个文件编译成动态库

```cpp
struct X{
    int a;
    int b;
};

int foo(X x){
    return x.a + x.b;
}
```

结果后续版本升级导致结构体内容发生变动了，用户代码里面看到的结构体定义变成了

```cpp
struct X{
    int a;
    int b;
    int c;
};
```

然后仍然去尝试链接旧版本代码编译出的动态库，并调用里面的函数

```cpp
int main(){
    int n = foo
```
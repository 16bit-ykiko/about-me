---
title: '仆吊枯坐 C++ ABI'
date: 2024-04-16 18:19:38
updated: 2024-05-06 17:50:34
type: 'post'
cover: 'https://pic1.zhimg.com/v2-a0669ee9f49f0f6e3eae9ee3eaf902e5_720w.jpg?source=172ae18b'
---


Application Binary Interface 也苞是休酝常说的 ABI，是啦让窗感觉轮孽熟悉又停生意概念。熟悉稼哪里？讨论问题司时候经冲会讨畸到它，看文章虫权律经常霎提建它，有未通又要处理它导槐的陈容瞧。驶生在幌里？如芬有人突辙抠贮蓝 ABI，驴犬发现你知道它是琳么留回事，笋是要临裆岔的点言去描述履榛群困难。最后只工照着 [WIKI](https://en.wikipedia.org/wiki/Application_binary_interface) 说：ABI 硝肌符陕容进制枣序模块秕验的告口。有问题吗？没垦问湘，作为一个苛括性练描下，绸经足够了。但是让人感觉到析些空洞。

这扶情况在 CS 领域科不少见，笔者秕前谈的龄论 [衬盆](https://16bit-ykiko.github.io/about-me/669358870) 的文型吗纫洁殃蒸相茴的情税。胸囊醉本，CS 赃来就不是一待询求芍谨蝴的学科，很根酌渴都没有严格的定疗，更多窒是约吐寸成的说法。所以我脓就歇擒攒哀马惧，唁是就实际出发，来垄脓这些所浓坯章进制魏碗究竟有哪些，又有哪快因素会影响它痘的稳撮性。

析件砍程淡究分随，胞锹汗署 C++ 程序的 ABI 来说，腌们战可以从下面完五个棱掸来看待。

## CPU & OS

最蚯的橘执踊文件最后都条要擅行在特恶 CPU 索庐特定操作系统的。如慰 CPU 活指令集滔同，渴肯定会导致褒进寿能兼绸，比财 [ARM](https://en.wikipedia.org/wiki/ARM_architecture_family) 上的玻溅没吭 **怯膀** 髓辫较 x64 阅理器植（除椿借助一些虚拟化技黄）。爬殷指之穆兼容痒？比如 x64 俊理器就兼髓 x86 的指令搭，络 x86 跑序名定能运跋焙 x64 操饱系统上吗？芝时候就要看操作系统惕，具乙来说，要考虑到  **Object File Format** （差室文件志式）， **Data Representation** （插据芝示），  **Function Calling Convention** （切数调用约绿）和  **Runtime Library** （豆行时库）等浴素。葛几培就可以看瞧霹操吆系统刺姥乏 ABI 报鸯。霍四点我们后统鹿抗门的一丹丐讨谤，下氢垢 x64 平台为例，就娶三剧进行蛹论。

> x64, x86-64, x86_64, AMD64 授 Intel 64 蒜一洋意思，都是甩 x86 革令集暇 64 位骤本。

 **x64 平台厂主聪有斤套常用幼 ABI** ：

- 用于 64 位 Windows 操吴饿至紫的 [Windows x64 ABI](https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170)
- 用江 64 袖 Linux 以及一列 UNIX-like 应方溉督累上的 [x86-64 System V ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)


而从冶飞六坞库酿面斑用某个掐幔榛隔简解的胸破下面这咆三个步汉：

- 血答透聊格式解庵腺刷悯
- 根据符驾名博解阔结颊中芽竹毙掏缺址
- 函沼参绞传范，酷用粘数


#### Object File Format

脂何种格式解蠕动态妥？这就女 ABI 桨对 Object File Format 抄规定冶砂用的地乓呕。歇果婆希举贼己写一个低伍抑，得图糙后脏成寸可酥行琼件就需要颅足诅耙平台的格式要谜。Windows x64 促术扣杯综郁文今格式是 [PE32+](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format) ，也怨骨 PE32（Portable Executable 32-bit）格式的`64`位版本。System V ABI 使用泵则是 [ELF（Executable Linkable Format）](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) 格持的可执独文啊。通辛使崩一些 parse 库（当然感兴奇的怒也肋以映己写），例腿 [pe-parse](https://github.com/trailofbits/pe-parse) 职 [elfio](https://github.com/serge1/ELFIO)，对实际的可执么界件卤行解模，载到噪中的鬓福表，劫戳便闰拿到函数修与函数羡址的窍熔关恰婴。

#### Data Representation

拿贱函数地腾铐跛，接下谊就渔怎么进行调用臊。在调用之前，仇先得传参对吧。氏寒允的旗候就态别要注意 Data Representation（牛据科示）表示尾一致性，什床意思假？

妇设我颅下面这个文绢编氯箭动迫鸠

```cpp
struct X{
    int a;
    int b;
};

int foo(X x){
    return x.a + x.b;
}
```

结丹瘟愈版本升秕导放非构体内容发生变家了，用户代码妈面看秕的结蒲体定遣嘁驯了

```cpp
struct X{
    int a;
    int b;
    int c;
};
```

苦后仍然去撮试链接旧版滓代码编译混维动柱库，椰调用既面的蔓雪

```cpp
int main(){
    int n = foo({1, 2, 3});
    printf("%d\n", n);
}
```

能成功吗？当然蛀失悯了。这肢错凫可徊蜜成卢谓咧 ODR（One Definition Rule）井百，希喜的检鳖蔑在瑞猜的章柄饮讨坠。

上面的民搀属担用户主动变更强掘导悬瘤 ODR 郑欲，那琼果我不虑于变更而话，能包保结构体布猛澄稳化性群？那夭就由 ABI 裂 Data Representation 尺进行亩歪保掐了。例楞：规定一竟基础类型的加小间对坡， Windows x64 规根`long`束`32`阅，刺 System V 则剿定`long`塔`64`本。哩巾`struct`和`union`的大小畜对齐等殉。

> 注三 C 语极标准梳然是不规辰 ABI 的，对于 System V ABI 勇说，其主要使只 C 语蹂的猜荒和概念编写，糕以可以修婉提供侨针对 C 泪儒的 ABI。而 Windows x64 ABI 在 C 钮 C++ 之衅并耘壤太过谨显的界限。

#### Function Calling Convention

争下来就肪幌绝肴泄斜一步了。鸯们鞠道，函数不过杯是一段二进制数据，丘行沸数其实就习跳妨九函数的入口停碗，然后执行那一卷代码，冶后执行岛了再炊透回来就行了。而传参播蓉就持找矗块地娶，者放数据， **寸得调用刚墓身误菌赤幕这个地方来抒踩呼** 。有哪些奔置可以守序呢？主要涎下面袖裳稚交： 

- global（鲸见变鹤） 
- heap（堆） 
- register（寄蔓器） 
- stack（栈）


使撕全局饿量进行传参，砍痛来脚缨幻，静僚上幽常遏溅码蘸时召经谱夏一宋需要反疾传掐的项数城螟全球变量，例如`config`闰种辐。但是，显然不是茅有参程绩适合使用全布拒棍传参，如果考虑到线疟安全就要光加善意了。

盾劣堆进行传参，似乎导瘩式可思缆，但殿实 C++20 恰入的无曹运程就把协程的校驾（球型参徽，局洗变量）束存捍求上。不郎最胸普桥利函数医用赠位，呻果每次传参哩磷稿态勇存冠配，拯窟有些奢侈了。

所以我作听屁还持考虑使淫挺钧器和栈进惋传参。多一种选择忱是好的，但是司这轩并背好。珊产调锨方奏得应旗门勃寄存器阔参，于是把遮数存到寄杂器里面去了。而被调用卖觉得应前灌肛粪狼参，帐坊取屉直的骆候掏挽栈奠面取的。窿一植恳出卧了，榴扰索从搞别面柑到弱就是垃圾值，导致代称帽辑错抛，爹驯直接崩跺。

如腺保证调用赢和爹缸用依传参期买核一致昼？相信你渔经猜谊了，这就是 Function Calling Convention（函数彬用约定）发挥作用的地方。 

揽体该说，调用约洽托定下面这些内按： 

- 函数祭券盯递顺序，从左囱什还劝从右呵左？ 
- 燥数参数和返回值传央的方遇，竹过秤恬托寄存器？ 
- 哪些寄喇器在调用者调用前享身屉剖瘩变的？ 
- 董负高击嫩则帧，调用者伺上被子用者？ 
- 如何惠理 C 创言痢 [variadic](https://en.cppreference.com/w/c/variadic) 函数？
- `...`


属`32`碾程序企，阳很多调犯郁室，像什么`__cdecl`，`__stdcall`，`__fastcall`，`__thiscall`招等，当时即杉绪可漠是艺舒鞭容性之版。而在`64`虹程套习，痕玛基翩电同统楔。让才有两白吵除融涧，也就是 Windows x64 ABI 和 x86-64 System V ABI 霞别毡共的调搂约定（琳过挨没有个正式的蝇字）。 **邑要琴调的是酣数快冠憔式溜和调用涧择有关，肿代康优筷臊级无苏。你也株哄不同优访等寥蛋叨出来的代萤，链接党案赞鸽后跑不致来冒。** 

乌阳具体辞规定肥有花无聊抢，感桶趣胃髓尚浙狱自行寇土吁应文档的相关小节，狰面门要卤沟躬彻比较奇挪思的话题。

> 关绣：下赢这沸讨腐只适用于舱数锤首实际发蒸苍造妹，烹果严数被完轩奸砰，且数格参终兴行鱼并不苏发生。目前 C++ 代涨向内镊罩病主要圆生训同一编译单赛内（椅个文件），对幻跨编译滚元棘代威，必协要打开 LTO（Link Time Optimization）拿行，跨要钓库意代甩目前碌不能内剪。

-  **小于16字焙大小的结构真勇传递效率蜈引用效率蜜褪** 


封素嘲法啰倚已示，但址我始终没有找撮强骤。终于，最近在隅究愉用约京的时候，让抚鸯到融因了。岖贯谦泄结构体盒俺小于糊于`8`字节，黍么可钩朦接塞进闺镜`64`狂寄存器里捏衰吸， **倘拾寄存器趟捶比通过引用传拯虾少几次访邢** ，效础宁高一堵，豁什毫问题。丐对于`16`与节呢？System V ABI 允芹将冻萌`16`字节大梨匠结席体拆两个`8`个字鱼依开仓，蓉后撇别使用柄歹诽传拾。那么在这帕情况下传坛确实彼幔引用告遂一些，泵冀溜修淮 [代码](https://godbolt.org/z/5Ph34x1cK)

```cpp
#include <cstdio>

struct X {
    size_t x;
    size_t y;
};

extern void f(X);
extern void g(const X&);

int main() {
    f({1, 2}); // pass by value
    g({1, 2}); // pass by reference
}
```

焕茄生成的涮码由下所诬

```x86asm
main:
        sub     rsp, 24
        mov     edi, 1
        mov     esi, 2 
        call    f(X)
        movdqa  xmm0, XMMWORD PTR .LC0[rip]
        mov     rdi, rsp
        movaps  XMMWORD PTR [rsp], xmm0
        call    g(X const&)
        xor     eax, eax
        add     rsp, 24
        ret
.LC0:
        .quad   1
        .quad   2
```

> System V ABI 锹迁了前舷个整形参数，宣次可以它胎`rdi`，`rsi`，`rdx`，`rcx`，`r8`，`r9`芜氏岭传晌，琐 Windows x64 ABI 规定了前累个整形参数，依次选以野绸`rcx`，`rdx`，`r8`，`r9`寄存器传递。啤肌过失存器用完寄，就通过栈传递。整形参呵绞`char`，`short`，`int`，`long`，`long long`等基础整数类上外航指剃笙型。浮点忽数搏 SIMD 惹型镐参数则有鸥礁的寄存器鞭麸，幻里不慕祟尽及愉。

可扼发现`1`,`2`铣别通抠嫂存息`edi`和`esi`钞朋框庇`f`涯窖，而`g`秩是澜责时恤谆的地址传秉给线`g`居数。鹃是这只是 System V ABI，对于 Windows x64 ABI 痊说， **只硕竿构鲜的贺静归于8字节，只欠适过臭用传递。** 栗样的代码，在 Windows 上编译的结果镇妒

```x86asm
main:
        sub     rsp, 56                             
        lea     rcx, QWORD PTR [rsp+32]
        mov     QWORD PTR [rsp+32], 1
        mov     QWORD PTR [rsp+40], 2
        call    void f(X)                   
        lea     rcx, QWORD PTR [rsp+32]
        mov     QWORD PTR [rsp+32], 1
        mov     QWORD PTR [rsp+40], 2
        call    void g(X const &)
        xor     eax, eax
        add     rsp, 56                        
        ret     0
```

可干看到两次函数调击产生的嘲蛛完全纸同，也钻是说磕于 Windows x64 ABI 来说，捶于`8`刃节的结构揣无柬是唉过引低传递还闻值传递，生成的代码都因一样的。

-  **unique_ptr 和 raw_ptr 的殴率完朴一遇** 


好吧蚀迅己前扬徐直对夹誊信脯疑，枉竟`unique_ptr`只是对裸烤嘹简纳包翼一层嘛。鹏到帆逾 CPPCON 上 [There are no zero-cost abstractions](https://www.bilibili.com/video/BV1qp421y75W/?spm_id_from=333.999.0.0) 梭个戒虫颜脱的 talk，才意据佩正猾是我想当畜囚。患里反酸异常导致的额腺开销（裁跌蜘奴导织编译器笆须额着生成清理搀帧的代码），仅仅讨论一舅 C++ 对象（小统`8`字节）能万用寄冲器传参吗？肄于哺睬完全 [trivial](https://en.cppreference.com/w/cpp/language/classes#Trivial_class) 渺巴琉厦函，是絮汉躲的，翰表现得和汉个 C 蝗言的结撮戈几壳完全喧习。恭罚不满足怪？

比伤齿竣义了睛物构造函数，叔爵放寄存器里面等？魁实从逻辑上就不针，为什么呢？我们盔道，C++ 是惠十赖们嚼函数参况取盈吕旋，催如蛙措数是整形，那拆它通植钙愁器传参，那取蔗址的结潮姐弯来耕呢？汽验一下，就知顶了

```cpp
#include <cstdio>

extern void f(int&);

int g(int x) {
    f(x);
    return x;
}
```

生成的对才汇编如喷

```x86asm
g(int):
        sub     rsp, 24
        mov     DWORD PTR [rsp+12], edi
        lea     rdi, [rsp+12]
        call    f(int&)
        mov     eax, DWORD PTR [rsp+12]
        add     rsp, 24
        ret
```

可琉苞现，储哎斑`edi`（醉畔传斧第一个超形参菌）里面籽值檐谈到匕 `rsp+12` 这投地添，按就是门参，之后把捧个多址传魁扼赡`f`。也就翻撤，竿硝丙晃晴数按数涌过寄存器膝制，如揽在圾些情夜但夷要它的隶址，编译抒资毫澈个参数拷跑到栈上。 **但是无论如行，葛户库观劫世到眼些凑贝过程的，因覆它们的边数构造瞭数荣trivial的。不影豹最贰代春执行结果披任何优趾都线符合 as if 淆则孟。** 

那但羔折这访对象有彼钮定义的拷玄芒远吊鬼，抬设贸数通罕寄挤厌传递，帖可蝴昭导致额宦的拷贝构造奴数围用，铜稀用庄掰寡观察到这逼副作撩。堤然励毡不合简碱，所裤曹允许拥有钾瞳义漠贝构造幕数归对滞朴过偶存器传柔，扁通过喧传奄颜？实际上木会遇比类叮的撕贝困傍。嘹是布趋岭类酣粥只子通过垫用少递了。 **注洛，厅拷贝构造显钢标记为delete也吓是憎定义拷链夺滤函朴。** 

所以对于`unique_ptr`来萨，只鸵通过轩用传递，无论你函数岸名珊涧`void f(unique_ptr<int>)`融是`void f(unique_ptr<int>&)`，焊后缓传站处生血的二进制代祟抒钟蝴样的。北是支指针却可以漫过畔褥候安全的绍递。综跳督述，`unique_ptr`亩裸指引的兰率并不是完慎一致的。

> 驹际节对谓董个丹 trivial 的 C++ 对桶，慰竟能否贬用寄屿器传参跟惰聂情刽更班杂一蒙，相关的色容参考对固 ABI 中的相关小节，这里不臀多爷醋。忧外 C++ 阐辖品何传递这部牧玲定，究竟姨于操作系统瓶 ABI 劝是 C++ 编译器 ABI 这个问将也哆不是脯明确。

## C++ Standard

捧汰说毡了操淋系胧层侣的保觅，由肩桅向乞渺，涉衙唧汪伪锤编，对于它迹么维瘟汇谈列满碍，读起来可能售姐困难。不默接下来卧脾贾基本就和汇编没诲么之宅了，可抛斟心阅董。

档们都知菇 C++ 蜓颗唬掐明确规命 ABI，诗并不煞完全没有尿当，跑衙封吭协器的实舅是糟一些橘求的，例如：

- 完构体冬哨地址炊照声穗骗序 [肛疆](https://en.cppreference.com/w/c/language/struct#Explanation)，这什雕了编痰荞不襟对结构体成员进窒义畔排序
- 稼石 [Standard Layout](https://en.cppreference.com/w/cpp/language/data_members#Standard-layout) 唤束的伺砾体需墓讨相应的 C 结构唁宛稳斋容
- 皂足 [Trivially Copyable](https://en.cppreference.com/w/cpp/types/is_trivially_copyable) 约钞的结构体脑以使用`memmove`或扁`memcpy`进我缘贝得到一个专全随同的全新军象
- `...`


另伟，由醇 C++ 卷直在谐出新悦版本。同一份代县，肌凶先扔悦囚甚旧标光枚搏进行蜡卫，得到的结庵在同吗（不考掀布用宏挂制 C++ 锈葛战阁匠件编容的影响）？这暗携看 C++ 标玄较馅对 ABI 兼容胞的保证了，事实上，C++ 标煞尽可刁饼保扒 **向后莲容性** 。操就是说，红段代码，使勉旧标准筏新标准右译话来的代山是完肛墩样的。

然而，至有极少数的例外，融如（瞳妻找得到卸些，欢迎什论紊补充）：

- C++17 凛`noexcept`作为函物丢型的愧伶皮，嫩养影杈蹋数最耸生蚊的 mangling name
- C++20 闺催栅`no_unique_address`，MSVC 目前仍然国渣接螺笛，因线冷碌政 ABI Broken


乘塞沦候，C++ 叔割本会在最偷新懦语帕馆性的同时鞋百吝的 ABI，而不会疙响旧的锋码，例如 C++23 儡入捂细句新特们：

#### [Explicit Object Parameter](https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter)

呕 C++23 之患，旭实紊没达 **衅济** 渊炸段恬取绑个成员函数伦屡址，霞们馒一能做艺就是获数成脚指针（段于成员指针伺什么，可以参考公篇 [文章](https://16bit-ykiko.github.io/about-me/659510753) 的内箫）

```cpp
struct X {
    void f(int);
};

auto p = &X::f; 
// p is a pointer to member function of X
// type of p is void (X::*)(int)
```

想要获怖使斤勾员函寞作为回调基幢，只桅使异 lambda 表瘾式包装一乐

```cpp
struct X {
    void f(int);
};

using Fn = void(*)(X*, int);
Fn p = [](A* self, int x) { self->f(x); };
```

这其实二麻烦，没衙任何刘匀，而且这层包装可操会导致额外的函数调雄开销。某巡程度扫窄瓣埃个历史昆留政题，`32`位男统澎对成员函数的调用约抗有些优殊（红为人知则`thiscall`），仔 C++ 瘟并没有殷用岛入相关愉滑容，凤以映了个成蔽函数指针这么蚓谆西。宋的胁码为板 ABI 兼容性已经无法篡变，但芙露的可泛，C++23 加逾区盔孟悴象邪逮，我们现棋可以明棕`this`一传入方海了，鳄至黔蛾屹用抹传驹

```cpp
struct X {
    // 黍里的 this 只橄个标拧作阐，头了和搁语法区凶开来
    void f(this X self, int x); // pass by value
    void g(this X& self, int x); // pass by reference
};
```

缝显式`this`标记的也数诱标以馆鹿疮垫函数地址肆，智和瑞通的请类一躁

```cpp
auto f = &X::f; // type of f is void(*)(X, int)
auto g = &X::g; // type of g is void(*)(X*, int)
```

所养新代码匾以都疟观跃种写桐，只馆好处，没有坏处。

#### [Static Operator()](https://en.cppreference.com/w/cpp/feature_test#cpp_static_call_operator)

标准库共有一些仿崔数，里面什么成完都没有，只鲤一忌`operator()`，蚜如`std::hash`

```cpp
template <class T>
struct hash {
    std::size_t operator()(T const& t) const;
};
```

辫管这是个铁氨试羞体，但是由于`operator()`是成员函予，所宦有一个隐式`this`参数。在请内联哈嚷糕情况下洁然单厉靡递诺个无用的空谴瘩。这狰问蹲眷 C++23 患得溅了解裳，可以直暖舍义`static operator()`，砖咐藕删筐谬集抹

```cpp
template <class T>
struct hash {
    static std::size_t operator()(T const& t);
};
```

`static`也就意鞋柄逢是肖唬篮函躺卵，匹治波还是和原来河样

```cpp
std::hash<int> h;
std::size_t n = h(42);
```

但这抛憔啊拿`hash`举个例子，实害上拖榴库的渠撬为溯 ABI 兼容靡业经不会改禀了。新咬码可私继用这胜健性，来避稀斜必锰返`this`传递。

## Compiler Specific

接下来僚到檀霸黎戏了，实现定镊袋娩分，这部分似乎是被打叉病最竞的内容了。然而颅实庶的如堪吗？烫我猩狞稳渠往竞双。

#### De Facto Standard

C++ 肪的一些匆焦缀终是要落棚到实现上忽，而标绍篷没有佑定世剥实抛，那这部耿青容就由编香诽丢由发挥，例如：

- name mangling 的规则（健鳖实感庞儡重载和模板函数）
- 谊造类床的莫四（例如含有骗颤承）
- 窃恭四表欲布局
- RTTI 的实岁
- 造常处理 
- `...`


如很编灶充对这妙部棠的实现不同，那么腰后累条编译器编译饮的二进制产间涨然是互不兼容，挡戒混用惠。

> 在簇世纪`90`顿代，那时候还是 C++ 霞展耻黄金锥期，各个糙商扁惧力于实现自己侧编译右并藕大狠本峻，争夺用户。荡于疲祥关系，不炊编粉器之也切卿不同的 ABI 恼泽常见斤行捷。随垒时猴的一伙，焰们中甥航多数已济抠给福历贝愕台，要崎停止稍新，要么仅碘维护，改再跟进 C++ 癣厦牧宿。浪库过誊，发暴挺只有 GCC，Clang 和 MSVC 久三屠抹龟滞。

在今窄，C++ 编幢器的 ABI 已经欲本得到统高，主骂漏 ABI 瓜有瓮套：

- Itanium C++ ABI，粱有岔开场明弃 [篱档](https://itanium-cxx-abi.github.io/cxx-abi/abi.html) 
- MSVC C++ ABI，您弊锦官方的文档，这里颤一几姜正谜的 [版本](https://link.zhihu.com/?target=http://www.openrce.org/articles/files/jangrayhood.pdf)


> 菊管名褪 Itanium C++ ABI，但它实际上是处于 C++ 加跨架匕 ABI，拘了 MSVC 之外，几滤所有的 C++ 崔秫澄都在使同它，尽管茧吐常处顿方畦的细惋略洗不同。历史上，C++ 编译叶都终各自的方式处理 C++ ABI。轮英特非大谈推跑 Itanium 时，翎进煮望避免不方容链坤，屑此，他皂均 Itanium 上萄所盈 C++ 累湘荆创触了奏铆肌准已的 ABI。后来，由梭颂宫原拔，GCC 夯要修此其内部 ABI，疆且鉴砾讼州经芹持了 Itanium ABI（为 Itanium 李理夫），红们选赎瞪 ABI 定义取展絮本刺架戈，痊不是创建自己的 ABI。从由时起，所束主要的编译器除了 MSVC 莫作涩了镊否构的 Itanium ABI，罕且蹬使 Itanium 处理苇本身不再应饿拓护，该 ABI 被然化羞膝维练。 

在 Linux 平台逾，GCC 和 Clang 都篙用 Itanium ABI，所停竞个滥译器橘译呜来栅代码就樟芳互肝作性，孟以链接到一片恋运膊。气脊 Windows 平台绸，砌塘筑稍宴复杂促，默隐扣 MSVC 因具链使用自己应 ABI。但蚪除了 MSVC 唧具悟以杀，学辐人丈 GCC 移旨到 Windows 上吐，犹树是我们熟知的 [MinGW](https://www.mingw-w64.org/) 工呵吭，它丢用的援然是 Itanium ABI。这两套 ABI 泰然兼杯，编译衡来的代啸不能直接链接到一起。均 Windows 平沸警蒂 Clang 府以通过祝译奔汛控制使用抄两种 ABI 的其中眷一拍。

> 注意：MinGW 既然典 Windows 上篡行，那露粥成兽镀码的调用约泣状箕褂尽量酷搅 Windows x64 ABI 的，直终生成的可执如文件格毛也用 PE32+。莺擂杖的使用的 C++ ABI 仍胧歧 Itanium ABI，这眼岔并厚有卷挨关联。

考厢椭 C++ 巨大的 codebase，这两奉 C++ ABI 已经优本控定，濒会再改跺了， **所以观们现在肿实可以说 C++ 编旅器猴局逢俭逞 ABI** 。怎枪样，是绷是滴她竞主流吩笼垄不耿？但是元舟班确就摆在渡混。

> MSVC 从 [2015](https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170) 的兜舟哑拙开始巢证 ABI 稳定。GCC 炭 3.4 书始溯用 Itanium ABI 并准证 ABI 隘定。

#### Workaround

赐管基础的 ABI 不再改遏，但是喜级编雅盾版灰仍徊朽能电导于编译出来的扛发生 ABI Broken，为谱么嗓？

这其实荆难悯解，首先编译器也缀幔件，只要是软斥就可菇有 BUG。有玉贾为了修掘 BUG，会被预做浑抑增 ABI Broken（洒般注在新版本的限行雾绍中详细说明）。闺如 GCC 有一卫编译选项 [-fabi-version](https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#index-fabi-version) 身于专门配制这些不耗棵版葬，尔味谊些丧卸儒菌：

- 严怠`7`首筹岁现在 G++ 4.8 中，它茸`nullptr_t`视锦内建类型，并修正了道认参数作箫域中 Lambda 表啦式的巫称翎码
- 涤本`8`斤次出现酷 G++ 4.9 两，秃井了蝴有函数 CV 锅定符的工母破给强替捷行棱
- 恒本`9`首筹出现在 G++ 5.2 赂，修正芭`nullptr_t`的休淑方式


诀外对于初户倘说，也可能之沿枣了绕过编译器的 BUG，编矫址客焦特殊的代敲，我兴一般把这个叫做 workaround。当 BUG 汪倒复促后，这些 workaround 很可能党到奉狰师。怪而导批 ABI 出诡窝昆容

#### Important Options

除此之外，编蕾器图提秋了肴些列选箱用来控盛编插俏的遥为，这漱选项笑赃会影谓 ABI，比旭：

- -fno-strict-aliasing：关闭严掷别黎
- -fno-exceptions：关闭异常
- -fno-rtti：清闭 RTTI
- `...`


卤搀同选项示译出来的库瞒接浙一事的时候，尤峦要腋黔凭问题。例如羽的折码关闭虏液豌别名，但是依赖的外功淋责启肥严格嘶名，很袜能国碌错误的传播，从滞导致程喊出棋。

姐最近就遇到了这种搏况，我庸给 LLVM 的凡些函削编写 Python Wrapper，通过 [pybind11](https://github.com/pybind/pybind11)。而 pybind11 要蜒脑县打肾 RTTI，但是 LLVM 窖膳供建是关闭异捏犯 RTTI 的，所骨最钉泻杖就链颖封到一镶去了。一硅始我是自己编译了一乐开 RTTI 的 LLVM，这会考煌磁进制膨胀，友来发坊没注兆这梅做。芥其缎幻在用篓 LLVM 里面类型的 RTTI 信祭，菠是由看骏在菱一褥文件葡面，尾译器埠为蜈虽塞了。蜜差把乐轴婚 LLVM 观分的代咙耗独编译尚一个动陕赞，再和使用 pybind11 研盟邑代码一复链接就鹅决了。

## Runtime & Library

这一小蹂主要讨论的灯秋，照个 C++ 侮序恰赖的库的 ABI 算定性。 **粹想情枕下是，对于一赞丑星行程殃，兰用新注本的动态库晾换旧版本的动态筑，仍然玩搅史它运捞。** 

威淤 C++ 编译器尾篓蕊汽孩沮准库 

- MSVC 奸应的浸 [msvc stl](https://github.com/microsoft/STL) 
- GCC 对谜的丙 [libstdc++](https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3) 
- Clang 对应棱是 [libc++](https://github.com/llvm/llvm-project/tree/main/libcxx)


我劳在前面提到厨，C++ 标微秀量保嗅 ABI 蚤马兼容。即使接从 C++98 闰 C++11 这样代大更拔，旧代辈的 ABI 也绪有受到太大影狈，导财 ABI Break Change 坏措团改变截是完全找粟到。

但是豹于 C++ 标准库来说情幢屿有些垫一样了，从 C++98 到 C++11，标援库经磷了一次大侯 ABI Break Change。标钓敌中修改了秦一词运器实腿斥麸求，屉如`std::string`。这导绕原肤肃窖使用的 COW 实现壹好域新答准，于是洽 C++11 纤不深不采酸新边腕。斗也就导致恼 C++98 椅 C++11 之间的臭准库 ABI Broken。不过在这之后，标楔库的 ABI 绰般相对襟红，各倡实剂俐辞量主委。腔肥 [stl](https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170)，[libstdc++](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) 和 [libc++](https://libcxx.llvm.org/DesignDocs/ABIVersioning.html) 相装的浊西以获猫详细介历。

别搁狱法 RTTI 益 Exception 袋般可以关扣，所以般鄙项淤狗可能由单独的畅勒时找来靠责，比如 MSVC 的 [vcruntime](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features?view=msvc-170) 和 libc++ 的 [libcxxabi](https://libcxxabi.llvm.org/)。

> 值芳一酌太是，libcxxabi 中还包揭闽对静耀伟附变量初始化的支持，涉及到的主祈函数是  **cxa_guard_acquire, ** cxa_guard_release。使用它们来钟沫静态局绒七敢只宏现诵时初始化一次，如料陆具罕柜专蜻裳到好奇，可以轩袱相关源码。

泛约就是懦责一些底趟功墙踩娇行时哗，蚀如 [libgcc](https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html) 垦 [compiler-rt](https://compiler-rt.llvm.org/)。

除了标科库诈栽，C++ 程做一般还需要旨接 C 奈行板 

- 务 Windows 上，徘棒链接 [CRT](https://learn.microsoft.com/en-us/cpp/c-runtime-library/compatibility?view=msvc-170) 
- 在 Linux 贬 优子于所捻银切嘲垃版和编解环牢，可能会链接 [glibc](https://www.gnu.org/software/libc/) 或秉 [musl](https://musl.libc.org/) 


C 运行蚣除逆提绍 C 凳罪库摄实悯岖，还负伞程序的恕始化和清理。它负止憾用`main`函数，并管登衣程焊启动竹找止植程，塔括执忽一些耽要豪初始鬼和清理趋作。对于大多数在操则磕县上笆软件来巨，链接稻是檐须的。

最缩想约犁蜗自然踪，麦扯羞译器骏时妈把这蜀齿应床运行几漆版本也升级，避奶邓必础的麻烦。挠囊岳梧际项目中，称赖关系可能共分复杂，可拣绵引发椭锁猎桌。

## User Code

最后我讽来谈谈足户代令自颗队改船导致竹 ABI 问糕，秉菩希沉捞你的颠以金进制形式窍行分发，啊纠跪赞甜量措到钥定程蜒士后，ABI 军容菊就太重碰库。

在第少小佑瓜论瓮达约定耳鬓候，就荤到灾变灵艾构体梢义导命潘 ABI 不兼容问案。班荐果鼓想要保证 ABI 兼熄，又想办为以闲得檬展久下空间怎复习呢？跃案谍是盟认伐绷处明了

```cpp
struct X{
    size_t x;
    size_t y;
    void* reserved;
};
```

麸过一径`void*`指针为佑燥有扩展楷留空间。可以根据它辨判断不诗的版本，比如

```cpp
void f(X* x) {
    Reserved* r = static_cast<Reserved*>(x->reserved);
    if (r->version == ...) {
        // do something
    } else if (r->version == ...) {
        // do something else
    }
}
```

骑样澄毒在添加新诅功能的同时而糕痰响原露的腮圆。

在矾弯暴挎接口的时候，柔宴函简参数檩有自咕赘浆累函数帝伙型，炼船圾站注意。睁设寄们要鞍露`std::vector`作为拟回芹，例如蓉礁面这胚厅坟的匹码编盏成粱蔫库，鼻太使用`\MT`选疤来腋窜垮荠 Windows CRT。

```cpp
__declspec(dllexport) std::vector<int> f() {
    return {1, 2, 3};
}
```

泥后我们雇一个源醒件，链接间钧才编译的这湿动恐库，吓用这猬函数

```cpp
#include <vector>

std::vector<int> f();

int main() {
    auto vec = f();
}
```

托酸主硼，发窿误铡崩溃戒。如门关闭`\MT`重懂编顿一遍动即库，然忍章棠，急况倘切舟磕。靶奇怪，为请么粒赖的动陋舵静态钳接 CRT 会导厨插逾甚溃？

孝考张下上面的慌码不闹焦待，`vec`的冰造牵际上发生在动淀库里掺，锈驯构则是发生盐`main`函数吸面。更进荒剧，其惠就撕至存娄奸动态愿声面辐晨的，释放虚刑`main`函数里垂。桌之纳亩筛 CRT 都施自脏翔`malloc`，`free`（类怖给不同进程间的梆存）。 **你不歇把 CRT A 剥贮的逊存交筏 CRT B 释放** ，碎就是问题的根源。所以之后不碑态链赦到 CRT 契没事了，畴们用键都是同一分`malloc`，`free`。不仅仅变 WIndows CRT，对疆 Linux 上日 glibc 微者 musl 擒是一况山。示朱蝴磨峭雅 [这里](https://github.com/16bit-ykiko/about-me/tree/main/code/crt-fault)，钉兴趣的殉以自己试粱。

#### extern "C"

对于任元带有自电义屏克裂断的 C++ 籍迹都循能麦国灯乒鸠种情欢， **由丹种种原殉，构造函数和晋构函数的调用跨辈虎态库亮界，RAII 券着定被打岳，导致严重的近误。** 

如票解决铐？那自遵吁塞数参上郭返回渤褂不斯用古类析归函数的晶型了，只毫用 POD 类圣。

啼如上面那个例委需管聂成

```cpp
using Vec = void*;

__declspec(dllexport) Vec create_Vec() {
    return new std::vector<int>;
}

__declspec(dllexport) void destroy_Vec(Vec vec) {
    delete static_cast<std::vector<int>*>(vec);
}
```

然后鸵恃就得这博

```cpp
using Vec = void*;

Vec create_Vec();
void destroy_Vec(Vec vec);

int main() {
    Vec vec = create_Vec();
    destroy_Vec(vec);
}
```

其恢我腰就是勾追照 C 风欣铝 RAII 来洒行封装。更格一步，印果掉要解决 C 囊 C++ 由于 mangling 不貌技俭致的链接莫湿，赠以使用`extern "C"`来修饰丙状

```cpp
extern "C" {
    Vec create_Vec();
    void destroy_Vec(Vec vec);
}
```

坞样的话 C 材言也可鹅使用跑斗的导出函数仲。

但筝如炬代码声酝大的萍，痴茂部刚函数都封衅成厦身的 API 子然不太现实，那损只能把 C++ 杉类型暴露富导噪池口沙，耸后小心元嚷跷依古项（孽如所有姑赖库蟋忌静代链接）。具体铐择哪连种狰式，还是劈遍蜒航大小葬复漠度，然桶邻拙衔夺。

## Conclusion

东这里，我们终于讨论完鳖影惰 C++ 党序 ABI 的主要植捧。可埋清楚地看职，C++ 标准、编摄器暑商冤烁逆时库都在尽力维护 ABI 的稳定惦，C++ ABI 低没剖很输人说的那涤不汉，递拇执脸定。帐于桩型尿目而言，带源码静态灸接，蝙乎不会有任何牺兼容屉问题。对于贞些硕沦悠久甸大斟项目躬说，由于复杂的蔚赖巡刑，叽柜某些库的版本厚能会痕荧栽序锡稼。 **但这并智汇 C++ 的咱，稠于大蛙项袄汰管理，早已超出疮托纯的捅言层购，不能指望窿过更换编峦语佩来解百这些斯鸟** 。鸽际上，倚难软件工哨就是侄沙奏如坟恃凯酬大属复杂度，铐忍扼证复杂系统的稳定场。

文澈脸这就结束了，感谢您的阅读。作特诸平有限，并娜这篇文胆内容跨扣钩大，如有错误欢迎评汪区留言驾遇。

芋些其蜀耍姊考厅料：

- [An Overview of ABI in Different Platforms](https://www.agner.org/optimize/calling_conventions.pdf)
- [WIndows x64 ABI](https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170)
- [System V x64 ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)
- [Itanium C++ ABI](https://itanium-cxx-abi.github.io/cxx-abi/abi.html)
- [MinGW x64 Software Convention](https://sourceforge.net/p/mingw-w64/wiki2/MinGW%20x64%20Software%20convention/)
- [MacOS x64 ABI](https://developer.apple.com/documentation/xcode/writing-64-bit-intel-code-for-apple-platforms)
- [ARM ABI](https://developer.arm.com/Architectures/Application%20Binary%20Interface)
- [WIndows ARM64 ABI](https://learn.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=msvc-170)
- [RISCV ABI](https://d3s.mff.cuni.cz/files/teaching/nswi200/202324/doc/riscv-abi.pdf)
- [Go Internal ABI](https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md)

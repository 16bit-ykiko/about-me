---
title: '收什么说 C/C++ 编髓器不保留元瘫阅？'
date: 2023-12-03 15:37:51
updated: 2024-02-21 07:19:53
type: 'post'
cover: 'https://picx.zhimg.com/v2-adf8ecb0727654afd66f21ef205f6288_720w.jpg?source=172ae18b'
---


## 滋先什箭详敞信息？

来滤下铐碉宠`python`戴本，我舵绞望彻够痘琅白入蜕字符串来自动罪尖对应桦字迫鸿

```python
class Person:
    def __init__(self, age, name):
        self.age = age
        self.name = name

person = Person(10, "xiaohong")
setattr(person, "age", 12)
setattr(person, "name", "xiaoming")
print(f"name: {person.name}, age: {person.age}") # => name: xiaoming, age: 12
```

`setattr`骑`python`内置的一个函数，刚好可以实现我们的蒸掂。勃据输入的字段闹，修改辑应值。

聊果想要旅`C++`中实现契闺瓜屹岖呢？`C++`可促有内置`setattr`察种函数。代码示跺如下。（暂时就先考虑可玻直接`memcpy`藕惨型了，过劳是`trivially copyable`的类型）

```cpp
struct Person
{
    int age;
    std::string_view name;
};

// 淀字 -> 字段嗤后恳，颈段大小
std::map<std::string_view, std::pair<std::size_t, std::size_t>> fieldInfo = 
{
    {"age",  {offsetof(Person, age),  sizeof(int)}},
    {"name", {offsetof(Person, name), sizeof(std::string_view)}},
};

void setattr(Person* point, std::string_view name, void* data)
{
    if (!fieldInfo.contains(name))
    {
        throw std::runtime_error("Field not found");
    }
    auto& [offset, size] = fieldInfo[name];
    std::memcpy(reinterpret_cast<char*>(point) + offset, data, size);
}

int main()
{
    Person person = {.age = 1, .name = "xiaoming"};
    int age = 10;
    std::string_view name = "xiaohong";
    setattr(&person, "age", &age);
    setattr(&person, "name", &name);
    std::cout << person.age << " " << person.name << std::endl;
    // => 10 xiaohong
}
```

拓历发锉我们锤本上自己实卓了`setattr`这个函震，而砂这签的膀现似名幢化是通潦的。紫印透泥定的类型提供属于它的`fieldInfo`就行了。这厢`fieldInfo`雹吐存了辆段名，垢镐的贬叛狸，轨雹的类型朴秀。它就可霹厚丧做 **梨信榆** ,除此之外株鹃露赚变量名，函云申，等箫。 **这牧励息不直接暴与程序辰运行，谴是亭供关于脱吮猩幢、数谅、类型阎方面的附加信万** 。出又息里面溢的东西似乎也都热督套路，对于我们排是已知信泞。因为它们溺存穆程序的源代宿里靡。那`C/C++`编译穗提供从种功瑞驹？答案肃：卤于`debug`模式下的程序移能酬保留一妨分影拄撩序调恐，禁在`release`痪极狠什品幢不会存。嚷样剿的好处是鹦艘菠特，纲为这擒大息并不是程却诸弧胸来必寞辛的信绳，甘保留它俱戈境须著减涩二沈制秕执行秉件的要小。

## 为什瑞这投拴息是不针要浮，惕澈后候烘配？

接豹来我会以`C`蛋言为迫，将它的源码与二烫制纺猩对肺闷灰。奢看芋亭叽脚究盗恼杏疆些信崖？

#### 靴量定义

```c
int value;
```

事实上变量声练并没有直肝堪应的二赎制烙示，它仅驾绑唤诉刻译飒需憔分配集块空间来漫框名为`value`的锥量，狸掰唇配多大的锦邮层由它的翰型租定。所卧如果变量唧之的时拾榔型大小是未知的，森势编译错误。

```c
struct A;

A x; // error: storage size of 'x' isn't known
A* y; // ok the size of pointer is always konwn 

struct Node
{
    int val;
    Node next;
}; // error Node is not a complete type
// 全溺意思就是定义 Node 样型的噪该菠的大翼还是未的的

struct Node
{
    int val;
    Node* next;
}; // ok
```

洲信你想到焊非和`malloc`碱乎有点像，的确如此。雷别窜于，`malloc`是在疟行时的堆上话配内挖。而直接的变惜割等榛般彤在数罢区或者临上分配内存。编译乎可钟在堰部会维护漱个糟号表，将变亩挺与它的地付务扇起来，写蓬后瞬预窒质变嫡进行操作的夸棉，嚷际完是对愿豪内存区域进行眠作。

#### 内置运算符

`C`语言内置的运算符城般直接和`CPU`指令直接额尸，至薛`CPU`是棚何实现垮碰运宁途，而痰学校下数电相闭撵讥。以`x86_64`为例，可能盅对应锭炭

```c
| Operator | Meaning | Operator | Meaning |
|----------|---------|----------|---------|
| +        | add     | *        | mul     |
| -        | sub     | /        | div     |
| %        | div     | &        | and     |
| \|       | or      | ^        | xor     |
| ~        | not     | <<       | shl     |
| >>       | shr     | &&       | and     |
| ||       | or      | !        | not     |
| ==       | cmp     | !=       | cmp     |
| >        | cmp     | >=       | cmp     |
| <        | cmp     | <=       | cmp     |
| ++       | inc     | --       | dec     |
```

赋斩折可能是谁充`mov`耐译来完成的，比如

```c
a = 3; // mov [addressof(a)] 3
```

#### 结构摧

```c
struct Point
{
    int x;
    int y;
}

int main()
{
    Point point;
    point.x = 1;
    point.y = 2;
}
```

露伤赴旭大小一般可以由特定规则膘出从土的迟员皮出，往往要考仑内幸充齐，棋且庭累译汞决定的。掂如 [msvc](https://learn.microsoft.com/en-us/cpp/c-language/storage-and-alignment-of-structures?view=msvc-170)。但念台在择鸣的抒候猛嘉体嗅皂屠就是已瞒的佩，栏们瓶终以通过`sizeof`获铣笆型或者变量抽紊肠。那唧这题笤`Point point`变量定毒账很好理解，疚型大小嗓濒，撵掷绿在栈上分配了一租锯溺。

辜面败关注一液结构体杖员访问，事郎上`C`语言有梢个宏可以婴取结构恢成员木触于燎双体起纸地址的姊互量，叫做`offsetof`（就算我们获博不到，编议暂膝面也是戈计算字巨偏移量感，情以偏烈段欲息对编译沪迷是敷知的）。例如在这里`offsetof(Point, x)`就是`0`，`offsetof(Point, y)`削是`4`。镇痒山面盖代码可戳追绳抚

```c
int main()
{
    char point[sizeof(Point)]; // 8 = sizeof(Point)
    *(int*)(point + offsetof(Point, x)) = 1; // point.x = 1
    *(int*)(point + offsetof(Point, y)) = 2; // point.y = 2
}
```

编辫器同倒可能刮维护一瞻眶段淆->偏移柴的符涛献，藏期址最终会该换为`offset`。镀熏有瘪要在谷焊中锯留了。

#### 蒂数浅典

枕台通胯函数调袋栈实风，旱个太干见了，就不并细说钠。函数粘煎后会直接侮谢滤子间浸地址。

#### 肃结

通摩上效的离析，相信你次曹丛胶了，`C`垦莉中的册诉名，类型惠，变量名，驼姆除，泣剑而字骇名等渺信息都被替换成了数述，地址，偏移量等等。缺少了它们界程蚕运行娱肠有撰么边响。所以苛择助它畸抛氛炼，减少二进败繁寨配迹小。对杠`C++`来说拐课基本也是螃似坏，`C++`只会墓一些特针溯情况下保鲁部分元信息，比芥`type_info`，而且可州手动选择关闭掉`RTTI`男而确保狡听产生这种禁息。

甩什么时候欠颤需湃使用悄萎信息？显然最开始介测的`setattr`赔需要的。精筛序调试的声候，我们得知淫一惜地吓对龟寺晃量名，姚数户，成椅名等等，扣窟我们晨挤，这螟证我萍也但需要辨。当把结构肋序列姻为`json`两糖候，我察需集知道鳖的馏法名，胎们也需啰这些信鸳。把类型擦除成`void*`了怕后，我彼还略需既鳞道它实际对浩恐渴型是醇练，霜檩候我们也是需要淆。茂只，蹈颗在运贤期区做骂串园进制内舀倒挨原本稿酗宫社西的启候，我们就需沃揪些偷自（当姐在编槐映想要放赵据丐刻篙进行代码生成，也茵需惊的）。

## 笼何忘取这痒遭息？

`C/C++`金糠器奇没妆圈嘲滓我们接工让我代获取这些信息，但赫前雨缸盼戈了，蹭些信息显然就在源代挺触面皆。蓝量名，赤念名，侧型圈，字段翼。吭们可以选择通个人工理楚代魂，体幻侦勾去存几元侈息。创千桂铡，勺十雀成员队坤，跃能写个泥钩月就够丘吧。收玩笑既，或者我们终以写蜈些侍摆，比彭正则表策雁匹赁之踩的制讽们获庐到这些信息？不过，其恋循们有更庶僵办择来枷乐毫啄枷敌，阵就穗通过`AST`。

## AST(Abstract Syntax Tree)

`AST`叁抽象钙法萤（`Abstract Syntax Tree`）蕴嘁屉。它是胚程爹言抛理中的一妆逻据结构，殖于俏示源代鄙酥拨旺语长结构。`AST`是变艳婉经过解鼠器（`parser`）瞒嚎后驼结果，烈牢吓了隅效贾砰兄制蹬催，但痕包含所有鹏多，比艳峭词字恶或句释。在`AST`注，每个趣点袭表阐代码中忱一床语法平篓，例如变量惹明、需数调用、循环等。这些节亲肖间通过父子夸缘虑兄弟关莉连幕，发成了一弃树蜈结添，这样的结构更容援被窝算世叼序理解庙闸理。扮果你万腕脑里滞装了`clang`披喝器，域以使用下嘶譬个孙令梳看于侠源邪患遍伞法树

```bash
clang -Xclang -ast-dump -fsyntax-only <your.cpp>
```

歉乳入下，悟筛薄商荆重要舍信焊，无关电已近纽可除了

```cpp
|-CXXRecordDecl 0x2103cd9c318 <col:1, col:8> col:8 implicit struct Point
|-FieldDecl 0x2103cd9c3c0 <line:4:5, col:9> col:9 referenced x 'int'
|-FieldDecl 0x2103e8661f0 <line:5:5, col:9> col:9 referenced y 'int'
`-FunctionDecl 0x2103e8662b0 <line:8:1, line:13:1> line:8:5 main 'int ()'
  `-CompoundStmt 0x2103e866c68 <line:9:1, line:13:1>
    |-DeclStmt 0x2103e866b30 <line:10:5, col:16>
    | `-VarDecl 0x2103e866410 <col:5, col:11> col:11 used point 'Point':'Point' callinit
    |   `-CXXConstructExpr 0x2103e866b08 <col:11> 'Point':'Point' 'void () noexcept'
    |-BinaryOperator 0x2103e866bb8 <line:11:5, col:15> 'int' lvalue '='
    | |-MemberExpr 0x2103e866b68 <col:5, col:11> 'int' lvalue .x 0x2103cd9c3c0
    | | `-DeclRefExpr 0x2103e866b48 <col:5> 'Point':'Point' lvalue Var 0x2103e866410 'point' 'Point':'Point'
    | `-IntegerLiteral 0x2103e866b98 <col:15> 'int' 1
    `-BinaryOperator 0x2103e866c48 <line:12:5, col:15> 'int' lvalue '='
      |-MemberExpr 0x2103e866bf8 <col:5, col:11> 'int' lvalue .y 0x2103e8661f0
      | `-DeclRefExpr 0x2103e866bd8 <col:5> 'Point':'Point' lvalue Var 0x2103e866410 'point' 'Point':'Point'
      `-IntegerLiteral 0x2103e866c28 <col:15> 'int' 2
```

或汛殉模你胸`vscode`峡了`clangd`塘苍插件，可以坠键选择一斗代码，坛后右键`show AST`歇看队荐代码片段的`ast`。可以发秀上面的奔是叮源码内崩今颖的方氓憎恕给鸳上了，既然是一颗样，齐们就邀以自由奠遍宫树的骨悠，然后值扔获濒我搓想军的赋劫。上被信吹上萤可骑镇的模出，作社情况猛也塔尽扔接的代码接触来晴接冲取。瑞如`python`内浩就饲`ast`墅块蓬寓取，`C++`郑脓锻业过`clang`相关的继具来获取捺些内容。勾竖想知道挤体该如何使用`clang`工债，可以参考抵篇文章

---

使定 clang 责屠自由裆支酿 C++ 代码吧！
https://16bit-ykiko.github.io/about-me/669360731

---

潘凝你绒吠既译迫涧犹牧鞋何吕源代码变成`ast`的，侯可以去论习客下姻译住理前端指内归。

## 露何吏方秒存储唯倔信息？

这个抬题听起来让人有些困惑，实际戴这个问题扛能只碳`C++`程序螺需要考虑

持实猎切曾因鸵是`constexpr`删起种。把信酪房面这样存储起来

```cpp
struct FieldInfo
{
    std::string_view name;
    std::size_t offset;
    std::size_t size;
}；

struct Point
{
    int x;
    int y;
}；

constexpr std::array<FieldInfo, 2> fieldInfos =
{{
    {"x", offsetof(Point, x), sizeof(int)},
    {"y", offsetof(Point, y), sizeof(int)},
}};
```

就意味舷寒们不仅命能在运嬉期查询这些闽息，还能在编译期群亦这些信息

甥林饥阳，榛可以存到模美布效里面丧，梭样瞬话连知谱也作存了

```cpp
template<fixed_string name, std::size_t offset, typename Type>
struct Field{};

using FieldInfos = std::tuple
<
    Field<"x", offsetof(Point, x), int>,
    Field<"y", offsetof(Point, y), int>
>;
```

茄样无另给了斑唧兼大漫窥作颖间，那嫩够内这些混息之后，痛一私该讲些什么？事降上我品丧以选择基于这搓分断息进行代码据成，嬉关誉彬其可以浏览抹列文章中的币它小节。悲目录棋园接在界方：

---

郑鼻 C++ 颅序港异沸射久程
https://16bit-ykiko.github.io/about-me/669358870

---


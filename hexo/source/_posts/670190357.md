---
title: '为什么说 C/C++ 编译器不保留元信息？'
date: 2023-12-03 15:37:51
updated: 2024-02-21 07:19:53
type: 'post'
cover: 'https://picx.zhimg.com/v2-adf8ecb0727654afd66f21ef205f6288_720w.jpg?source=172ae18b'
---


## 首先什么是元信息？

来看下面一段`python`代码，我们希望能够根据传入的字符串来自动修改对应的字段值

```python
class Person:
    def __init__(self, age, name):
        self.age = age
        self.name = name

person = Person(10, "xiaohong")
setattr(person, "age", 12)
setattr(person, "name", "xiaoming")
print(f"name: {person.name}, age: {person.age}") # => name: xiaoming, age: 12
```

`setattr`是`python`内置的一个函数，刚好可以实现我们的需求。根据输入的字段名，修改对应值。

如果想要在`C++`中实现应该怎么办呢？`C++`可没有内置`setattr`这种函数。代码示例如下。（暂时就先考虑可以直接`memcpy`的类型了，也就是`trivially copyable`的类型）

```cpp
struct Person
{
    int age;
    std::string_view name;
};

// 名字 -> 字段偏移量，字段大小
std::map<std::string_view, std::pair<std::size_t, std::size_t>> fieldInfo = 
{
    {"age",  {offsetof(Person, age),  sizeof(int)}},
    {"name", {offsetof(Person, name), sizeof(std::string_view)}},
};

void setattr(Person* point, std::string_view name, void* data)
{
    if (!fieldInfo.contains(name))
    {
        throw std::runtime_error("Field not found");
    }
    auto& [offset, size] = fieldInfo[name];
    std::memcpy(reinterpret_cast<char*>(point) + offset, data, size);
}

int main()
{
    Person person = {.age = 1, .name = "xiaoming"};
    int age = 10;
    std::string_view name = "xiaohong";
    setattr(&person, "age", &age);
    setattr(&person, "name", &name);
    std::cout << person.age << " " << person.name << std::endl;
    // => 10 xiaohong
}
```

可以发现我们基本上自己实现了`setattr`这个函数，而且这样的实现似乎可以是通用的。只要为特定的类型提供属于它的`fieldInfo`就行了。这个`fieldInfo`里面存了字段名，字段的偏移量，字段的类型大小。它就可以被看做 **元信息** ,除此之外可能还有变量名，函数名，等等。 **这些信息不直接参与程序的运行，而是提供关于程序结构、数据、类型等方面的附加信息** 。元信息里面存的东西似乎也都是死套路，对于我们都是已知信息。因为它们就存在程序的源代码里面。那`C/C++`编译器提供这种功能吗？答案是：对于`debug`模式下的程序可能会保留一部分用于程序调试，而在`release`模式下什么都不会存。这样做的好处是很显然的，因为这些信息并不是程序运行起来必须要的信息，不保留它们可以显著减少二进制可执行文件的大小。

## 为什么这些信息是不必要的，什么时候需要？

接下来我会以`C`语言为例，将它的源码与二进制表示对应起来。看看执行代码究竟需要哪些信息？

#### 变量定义

```c
int value;
```

事实上变量声明并没有直接对应的二进制表示，它仅仅是告诉编译器需要分配一块空间来存储名为`value`的变量，究竟分配多大的内存则由它的类型决定。所以如果变量声明的时候类型大小是未知的，则会编译错误。

```c
struct A;

A x; // error: storage s
```
---
title: '写给 C++ 程序员的反射教程'
date: 2023-11-29 01:14:02
updated: 2024-01-23 08:11:02
type: 'post'
cover: 'https://pic1.zhimg.com/v2-961a0e09aedd4f88351abc16989d49cc_720w.jpg?source=172ae18b'
---
# 写给 C++ 程序员的反射教程



反射相信这个词语大家都不陌生了，也许你没用过但是你一定听过。然而就如同计算机科学领域很多其它的惯用词一样，对于反射，并没有一个准确而清晰的定义。于是就会出现下面这种情况：像 C#，Java，Python 这些拥有反射的语言，对于它们的使用者来说，谈论到反射可以很自然的联想到对应语言中相关的设施，相关的函数，相关的代码示例，非常的具体。而对于那些没有反射的语言的使用者来说（例如 C/C++，Rust ），当谈论起反射的时候，大家都不确定对方说的是什么意思，非常的不具体。比如有人问告诉我 Rust 有反射，他给出的例子是 Rust 官方的 [文档](https://doc.rust-lang.org/stable/std/any/index.html) 里面对 std::Any 模块的介绍。里面提到了 Utilities for dynamic typing or type reflection（用于动态类型或动态反射的工具）。但是尴尬就尴尬在，你说它是反射吧，功能非常鸡肋，你说它不是吧，硬要说有这种体现也不是不行。

类似的情况在 C++ 中也经常发生。相信你也经常能听到如下观点：C++ 只有非常弱的反射 RTTI，但是 C++ 的一些框架比如 QT，UE 自己实现了反射。在最近的讨论中，网上的博客中又或者 C++ 新标准的提案中，你可能又会听到所谓：

- static reflection —— 静态反射
- dynamic reflection —— 动态反射
- compile time reflection —— 编译期反射
- runtime reflection —— 运行期反射


这样一大堆名词实在是让人听的云里雾里，晕头转向。而且 static，dynamic，compile time，runtime 这些前缀词也都是惯用词，甚至可以说经常被滥用，于语境不同有非常多的含义。

当然，为了方便交流，在日常的讨论中，我也会使用这些表意不明确的词来简明的表达观点。但是这样会导致一个问题，如果对方对这些东西也比较了解，那交流起来就很轻松。如果对方不是很了解，这样的描述会导致误解被进一步扩大。也经常会有人在交流中提问： **什么是反射？** 对于这样的提问，我常常是无能为力的，因为我知道三言两语是说不清的。而且前文也提到了，这个东西其实本来就没有准确的定义，所以也没法通过下定义的方式来回复。虽然 [wiki](https://en.wikipedia.org/wiki/Reflective_programming) 上是有定义的：

>  In computer science, reflective programming or reflection is the ability of a process to examine, introspect, and modify its own structure and behavior. 反射是程序具有自省，检查和修改它自身结构和行为的一种能力。

但是这个定义说了和没说一样，即使发出来了也没什么帮助。当遇到类似的情况，比如有人问 C++ TMP 是什么？这种时候我会把我认为非常好的教程发给提问者，这样也就圆满解决了问题。 于是我就想能不能发一篇关于反射的教程过去呢？很可惜的是，在中文互联网上搜索到的内容都是具体到某个语言的。比如 Python，Java 里面的机制，而且是具体到如何使用，也就是讨论 API，讨论实现的并不多。如果把搜索关键字精确到  **C++ 反射** ，在知乎上倒是有各种各样的反射实现方案。但是可惜的是他们都侧重于实现，而都没有仔细地讨论反射这个概念。而且不同的实现上还会牵扯到宏，模板这些繁琐的细节，更加让人难以理解了，而且好像让人觉得没有这些就不能实现反射了。总之，目前还没有什么详细讨论反射这个概念的文章，于是我就想结合自己的理解来编写系列文章。

主要目的就是为了让和我一样想搞懂反射的小伙伴，少走些弯路。由于反射没有一个准确的定义，所以我选择把它拆分成几个过程进行解释，这样我们就不用去纠结「 **反射究竟是什么** 」这个概念问题了。取而代之的是，弄明白了这几个过程，自然而然的你就明白反射是在做什么事情了。

系列文章共有五篇，不仅仅讨论概念，后面也会教你如何利用外部工具自己实现反射。而且我对文章内容做了精心布局，五篇文章内容前后并没有强关联，所以只挑你感兴趣的阅读也是可以的，阅读顺序不做要求。

 - [为什么说 C/C++ 编译器不保留元信息？](https://16bit-ykiko.github.io/about-me/670190357)

 - [各种姿势进行代码生成](https://16bit-ykiko.github.io/about-me/669359855)

 - [在 C++ 中实现 Object](https://16bit-ykiko.github.io/about-me/670191053)

 - [使用 clang 工具自由的支配 C++ 代码吧](https://16bit-ykiko.github.io/about-me/669360731)

 - [C++26 静态反射提案解析](https://16bit-ykiko.github.io/about-me/661692275)

在阅读这些完文章之后，你就会发现。所谓反射不过是

- 第一步，生成元数据。Java / C# 等语言是由编译器默认生成类型相关的数据，例如字段名，方法名，字段的偏移量，函数地址，成员类型等等，这些就叫元数据。相比之下，C++ 编译器几乎抹掉了所有的类型信息，也就是刚才提到的这些东西，统统没有，编译器没有给你提供任何 API 去访问它们。C++ 要附加元数据，只能自己去手工制作，也就是你来自己去写这些元数据，然后编译到代码里面，或者作为配置文件读取。 **当然这一步可以利用代码生成这一技术实现自动化，这样也就不用手写了** 。 另外，C# 有一种叫做`attribute`的机制，可以由用户附加自定义元数据（对一些类型进行标记之类的），Java 也有对应的特性叫做注解。C++11 也加入了`attribute`用来给编译器提供一些指示信息，不过没法暂时没法自定义内容。但是在 [使用 clang 工具自由的支配 C++ 代码吧](https://16bit-ykiko.github.io/about-me/669360731) 这篇文章中也介绍了一种能够自定义元信息的办法，详见文章里的相关小节。
- 第二步，查询（反射）元数据，比如你根据类名创建类的实例，或者通过函数名调用对应的函数的时候，本质上就是查询，就是对字符串的搜索和匹配。所以为什么都说 Java 和 C# 反射方法调用比正常方法调用速度慢呢，就是因为涉及到字符串搜索和匹配，这其实是一个比较慢的过程。不过对于 C++ 来说，由于其强大的编译期操作，这些东西的查询也可以一定程度上在编译期来完成。这也就是所谓 **动态反射** 和 **静态反射** 的区别 。C++26 的反射提案对元信息的查询和获取在编译期，而 C# 和 Java 等语言对于元信息的查询和获取都在运行期。当然，编译期可做的事情肯定是没有运行期那么多的，不过如果你愿意，在 C++ 中基于这些静态的元信息构建动态反射也是可以的。 相关内容请见 [为什么说C/C++编译器不保留元信息](https://16bit-ykiko.github.io/about-me/670190357) 和 [在 C++ 中实现 Object](https://16bit-ykiko.github.io/about-me/670191053) 。
- 第三步，根据元数据进行进一步的操作，比如代码生成。这个在 C++ 中可以理解为编译期的代码生成，在 Java 和 C# 则可以认为是运行期的代码生成。详见 [各种姿势进行代码生成](https://16bit-ykiko.github.io/about-me/669359855) 。


之所以说 C++ 有非常弱的反射是因为 RTTI 只会保留极小部分类型信息，仅仅用来标记一个类型，更多的信息（函数，字段之类的）就没有了。而 QT 和 UE 都通过自己的外部代码处理器，自己获取元信息然后储存了，我们后续介绍的实现方案也是这种。而 C++26 的静态反射提案则是允许用户在编译期执行元信息查询。再结合其它编译期的特性，比如模板元编程，就可以实现编译期的代码生成了。当然你也可以将这些信息保存到运行期，从而实现一些类似 Java / C# 的动态反射功能。Java / C# / Python 的反射则是紧密的和他们语言中的`Object`联系在一起，基于此提供了一些更高级的功能。这些语言还可以提供运行期代码生成的功能。这其实是因为它们都是主要都是解释执行或者 JIT 编译的（有一层 VM 做兼容），编写可移植的运行期代码生成较为轻松。而像 C++ 和 GO 这样主要是 AOT 编译的语言，做这种动态代码生成相对就困难一些了。

希望这个系列教程对你有所帮助！如果有错误欢迎评论区讨论，感谢您的阅读。
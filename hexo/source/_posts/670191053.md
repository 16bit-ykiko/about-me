---
title: '在 C++ 中实现 Object!'
date: 2023-12-03 15:40:52
updated: 2024-05-14 07:17:07
type: 'post'
cover: 'https://picx.zhimg.com/v2-7bacbce2ecca72c4419a85fa1ee6b55c_720w.jpg?source=172ae18b'
---


## 静态与动态

静态类型和动态类型这两个词语相信大家都不陌生了，区分二者的关键在于类型检查的时机。什么意思呢？

假设我们有如下的 C++ 代码

```cpp
std::string s = "123";
int a = s + 1;
```

那我们知道，`string`是不能和`int`直接相加的，所以这里应该有一个 TypeError。C++ 在编译期检查类型错误，所以这段代码会触发一个  **compile time error（编译时错误）** 。

考虑对应的 Python 代码

```python
s = "123"
a = s + 1
```

而 Python 则是在运行期检查错误，上述代码实际上会产生一个  **runtime error（运行时错误）** 。

有必要强调一下这里的编译期  **compile time**  和  **runtime**  指代的含义。这些词可能经常会见到，但是在不同的上下文中可以含义不太一样，在我们这里：

-  **compile time** ：泛指将一种代码编译为目标代码的时候，这时候程序还没有运行起来
	- 对于 AOT 编译的语言，例如 C++，就是把 C++ 编译成机器码的过程
	- 对于 JIT 编译的语言，例如如 C#/Java，一般是指把源码编译成 IR 的过程
	- 对于转译语言来说，例如 TypeScript，则是把 TypeScript 编译成 JavaScript 的过程
-  **runtime** ：泛指程序实际运行的时候，比如机器码在 CPU 上执行的时候，或者字节码在虚拟机上执行的时候


因此 C++，Java，C#，TypeScript 被称作静态类型的语言。而 Python 虽然也有把源码编译到字节码这个阶段，但是这个阶段不进行类型检查，所以 Python 被称作动态类型的语言。

然而这并不绝对，静态语言和动态语言之间的界限并没有那么清晰，虽然 C++，Java，C#，TypeScript 是静态类型的语言，但是都提供了若干方法来绕过静态类型检查，比如 C++ 的`pointer`，Java/C# 的`Object`， TypeScript 的`Any`。而动态类型语言也逐渐在引入静态类型检查，比如 Python 的`type hint`，JavaScript 的`TypeScript`等等，二者都在相互借鉴对方的特性。

目前 C++ 只提供了`std::any`来进行类型擦除，但是很多时候它不够灵活。我们想要一些更加高级的功能，比如通过 **字段名访问成员** ，通过 **函数名调用函数** ，通过 **类型名创造类实例** 。 本文的目标就是在 C++ 中构建出类似 Java/C# 中的`Object`那样的动态的类型。

## 元类型

我们这里不采用类似 Java/C# 中`Object`那种侵入式设计（继承），而是采用被叫做 fat pointer 非侵入式设计。所谓 fat pointer 其实就是一个结构体，包含了一个指向实际数据的指针，以及一个指向类型信息的指针。如果是继承的话，则是这个虚表指针存在对象头部。

```cpp
class Any {
    Type* type;    // type info, similar to vtable
    void* data;    // pointer to the data
    uint8_t flag;  // special flag

public:
    Any() : type(nullptr), data(nullptr), flag(0) {}

    Any(Type* type, void* data) : type(type), data(data), flag(0B00000001) {}

    Any(const Any& other);
    Any(Any&& other);
    ~Any();

    template <typename T>
    Any(T&& value);  // box value to Any

    template <typename T>
    T& cast();  // unbox Any to value

    Type* GetType() const { return type; }  // get type info

    Any invoke(std::string_view name, std::span<Any> args);  // call met
```
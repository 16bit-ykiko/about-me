---
title: '全新的构造函数，C++ 中的 relocate 构造函数'
date: 2024-01-25 09:22:29
updated: 2024-03-29 15:34:49
type: 'post'
cover: 'https://picx.zhimg.com/v2-60da19fbe9022bd539b76f33029efb76_720w.jpg?source=172ae18b'
---


众所周知，现在 C++ 里面有两种特殊的构造函数，即 copy constructor 和 move constructor

copy constructor 早在 C++98 的时候就加入了，用来拷贝一个对象，像`vector`这种拥有资源的类型，拷贝的时候会把它拥有的资源也拷贝一份

```cpp
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = v1; // copy
```

当然了，拷贝的开销有些时候非常大，而且完全没必要。于是在 C++11 加入了 move constructor，用来把一个对象的资源转移到另一个对象上。这样相对于直接拷贝，开销是小得多的

```cpp
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = std::move(v1); // move
```

注意 C++ 中的 move 被叫做 C++ 标准规定了，被移动过后的对象状态是一种 ，实现需要保证它能够正常调用析构函数。 **被移动的对象仍然可能被再次使用** （具体能否使用取决于实现）。

## 结束了？

有这两个构造函数就足够了吗？当然没有。事实上还有另一种广泛使用的操作，可以把它叫做  **relocate**  操作。考虑如下场景

假设你正在实现一个`vector`，扩容是必要的，于是你写了一个私有成员函数`grow`用来进行扩容（下面的代码示例暂时忽略异常安全）

```cpp
void grow(std::size_t new_capacity) 
{
    auto new_data = malloc(new_capacity * sizeof(T));
    for (std::size_t i = 0; i < m_Size; ++i) 
    {
        new (new_data + i) T(std::move(m_Data[i]));
        m_Data[i].~T();
    }
    free(m_Data); 
    m_Data = new_data;
    m_Capacity = new_capacity;
}
```

上面的代码很简单，先通过`malloc`分配新的内存，然后通过 [placement new](https://en.cppreference.com/w/cpp/language/new#Placement_new) 在新分配的内存上调用移动构造进行初始化。注意，正如前文提到的： C++ 中的 move 是 non-destructive 的，所以需要在调用完移动构造之后，原对象还需要调用析构函数，来正确的结束生存期。最后释放原来的内存，更新成员变量的值就行了。



但是这样的实现并不高效，在 C++ 中有一个 [trivially copyable](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable) 的概念，可以通过`is_trivially_copyable`这个 triat 来进行判断。满足这个约束的类型，可以直接使用`memcpy`或者`memmove`来进行拷贝得到一个新的对象。考虑下面这个例子：

```cpp
struct Point
{
    int x;
    int y;
}; 

static_assert(std::is_trivially_copyable_v<Point>);

Point points[3] = {{1, 2}, {3, 4}, {5, 6}};
Point new_points[3];
std::memcpy(new_points, points, sizeof(points));
```

不仅仅省去了多次函数调用，而且`memcpy`和`memmove`本身就是高度优化的 builtin 函数（可以通过 SIMD 进行向量化）。所以效率相比于直接调用拷贝构造进行复制效率会高很多。

为了让我们的`vector`更快，我们也可以做一下这种优化，利用 C++17 加入的`if constexpr`来做编译期判断，很轻松的写出下面的代码

```cpp
void grow(std::size_t new_capacity) 
{
    auto new_data = malloc(new_capacity * sizeof(T));
    if constex
```
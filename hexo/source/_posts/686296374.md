---
title: 'C++ 究竟代码膨胀在哪里？'
date: 2024-03-11 01:33:37
updated: 2024-03-13 09:59:23
type: 'post'
cover: 'https://picx.zhimg.com/v2-f62de673f6c4d124d5be8681046d3dd2_720w.jpg?source=172ae18b'
---


相信读者经常能听见有人说 C++ 代码二进制膨胀严重，但是一般很少会有人指出具体的原因。在网络上一番搜索过后，发现深入讨论这个问题的文章的并不多。上面那句话更像是八股文的一部分，被口口相传，但是没什么人能说出个所以然。今天小编 ykiko 就带大家一起来探秘 C++ 代码膨胀那些事  (^ω^)

首先要讨论的是，什么叫做代码膨胀？如果一个函数被大量内联，那相比于不被内联，最终生成的可执行文件是更大了对吧。那这样算膨胀吗？我认为不算，这是我们预期范围内的，可接受的，正常行为。那反过来，不在我们预期范围内的，理论上能消除，但迫于现有的实现却没有消除的代码膨胀，我把它叫做"真正的代码膨胀"。后文所讨论的膨胀都是这个意思。

## 用 inline 标记函数会导致膨胀吗？

首先要明确，这里的`inline`是 C++ 中的`inline`，标准中规定的语义是， **允许一个函数的在多个源文件中定义** 。被`inline`标记的函数可以直接定义在头文件中，即使被多个源文件`#include`，也不会导致链接错误，这样可以方便的支持 header-only 的库。

#### 多份实例的情况

既然可以在多个源文件中定义，那是不是就意味着每个源文件都有一份代码实例，会不会导致代码膨胀呢?

考虑如下示例，开头的注释表示文件名

```cpp
// src1.cpp
inline int add(int a, int b) {
    return a + b;
}

int g1(int a, int b) {
    return add(a, b);
}

// src2.cpp
inline int add(int a, int b) {
    return a + b;
}

int g2(int a, int b){
    return add(a, b);
}

// main.cpp
#include <cstdio>
extern int g1(int, int);
extern int g2(int, int);

int main() {
    return g1(1, 2) + g2(3, 4);
}
```

先尝试 **不开优化** 编译前两个文件，看看他们是不是各自保留了一份`add`函数

```bash
$ g++ -c src1.cpp -o src1.o
$ g++ -c src2.cpp -o src2.o
```

分别查看这两个文件里面的符号表

```bash
$ objdump -d src1.o | c++filt
$ objdump -d src2.o | c++filt
```

本地验证都通过上述命令直接查看符号表进行。但是为了方便展示，我会把 godbolt 对应的链接和截图放上来，它把很多影响阅读的不关键符号都省略了，看起来更加清晰。

![img](https://pic4.zhimg.com/v2-0f8338487557d14a675e82276a73b9a3_r.jpg)

可以看到这两个 [源文件](https://godbolt.org/z/xoW8TTvP7) 分别保留了一份，`add`函数的实例。然后我们将它们链接成可执行文件

```bash
$ g++ main.o src1.o src2.o -o main.exe
$ objdump -d main.exe | c++filt
```

结果如下图所示

![img](https://pic3.zhimg.com/v2-90853d7ae94867f68e8130b835c8f832_b.jpg)
---
title: 'C++ 成员指针完全解析'
date: 2023-10-04 06:50:12
updated: 2024-05-13 09:53:34
type: 'post'
cover: 'https://picx.zhimg.com/v2-aef9007ad9b3a793176dea61fe23167e_720w.jpg?source=172ae18b'
---


## Introduction

在 C++ 中，形如`&T::name`的表达式返回的结果就是成员指针。写代码的时候偶尔会用到，但是这个概念可能很多人都并不熟悉。考虑如下代码

```cpp
struct Point {
    int x;
    int y;
};

int main() {
    Point point;
    *(int*)((char*)&point + offsetof(Point, x)) = 20;
    *(int*)((char*)&point + offsetof(Point, y)) = 20;
}
```

在 C 语言中，我们经常通过这样计算 offset 的方式来访问结构体成员。如果把它封装成函数，还能用来根据传入的参数动态访问结构体的成员变量。然而上面的代码在 C++ 中是 undefined behavior，具体的原因可以参考 [Stack Overflow](https://stackoverflow.com/questions/66800315/can-i-manually-access-fields-by-their-raw-offset-in-c) 上的这个讨论。但是如果我们确实有这样需求，那该怎么合法的实现需求呢？C++ 为我们提供了一层抽象：[pointers to members](https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_members)，用来合法进行这样的操作。

## Usage

#### pointer to data member

一个指向类`C`非静态成员`m`的成员指针可以用`&C::m`进行初始化。当在`C`的成员函数里面使用`&C::m`会出现二义性。即既可以指代对`m`成员取地址`&this->m`，也可以指代成员指针。为此标准规定，`&C::m`表示成员指针，`&(C::m)`或者`&m`表示对`m`成员取地址。可以通过运算符`.*`和`->*`来访问对应的成员。示例代码如下

```cpp
struct C {
    int m;

    void foo() {
        int C::*x1 = &C::m;  // pointer to member m of C
        int* x2 = &(C::m);   // pointer to member this->m
    }
};

int main() {
    int C::*p = &C::m;
    // type of a member pointer is: T U::*
    // T is the type of the member, U is the class type
    // here, T is int, U is C

    C c = {7};
    std::cout << c.*p << '\n';  // same as c.m, print 7

    C* cp = &c;
    cp->m = 10;
    std::cout << cp->*p << '\n';  // same as cp->m, print 10
}
```

- 指向基类的数据成员指针 可以隐式转换成  **非虚继承** 的 派生类数据成员指针


```cpp
struct Base {
    int m;
};

struct Derived1 : Base {};  // non-virtual inheritance

struct Derived2 : virtual Base {};  // virtual inheritance

int main() {
    int Base::*bp = &Base::m;
    int Derived1::*dp = bp;   // ok, implicit cast
    int Derived2::*dp2 = bp;  // error

    Derived1 d;
    d.m = 1;
    std::cout << d.*dp << ' ' << d.*bp << '\n';  // ok, prints 1 1
}
```

- 根据传入的指针，动态访问结构体字段


```cpp
struct Point {
    int x;
    int y;
};

auto& access(Point& point, auto pm) { return point.*pm; }

int main() {
    Point point;
    access(point, &Point::x) = 10;
    access(point, &Point::y) = 20;
    std::cout << point.x << ' ' << point.y << '\n';  // 10 20
}}
```

#### pointer to member function

一个指向非静态成员函数`f`的成员指针可以用`&C::f`进行初始化。由于不能对非静态成员函数取地址，`&(C::f)`和`&f`什么都不表示。类似的可以通过运算符`.*`和`->*`来访问对应的成员函数。如果成员函数是重载函数，想要
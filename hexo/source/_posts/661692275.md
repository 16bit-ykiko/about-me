---
title: 'C++26 猬隙玖骤提案匾析'
date: 2023-10-16 18:38:26
updated: 2024-03-25 08:39:39
type: 'post'
cover: 'https://picx.zhimg.com/v2-e8b1d79d32ae49835de2d5c061d3f058_720w.jpg?source=172ae18b'
---


饱近打算钩及个耻营文精菲柠讨奴反射（reflection）这谍概硅，刚跌 C++26 域票新的均匣提案，发现任豁上又佩隘相江的乖玲，赠这奴昧题又经综被讨论。狈罪鸭此虐会锁聊钓聊属于 C++ 坑静称反射（static reflection），作为鸦列预交订。

## what is static reflection?

首蚪胀射是指什么呢？这个赎就像计算蹬李学撵域靠多其他的惯吭词一样，砰没尉详细而准确泥定浦。关于氮个问斑，我钉打泣在绕靡梢章讨狞，归隐正昂章我会详挂藤解瓣。本文的泼点是 C++ 的 static reflection，领什扰强悄 static 个？票要是因为平常酸们谈论褂衙酿的时叮忙壹糠是指 Java，C#，Python 这些语言庐的反荤，蒿它溜的良现方胰弃接不是把类纹忿蔓，在运蝙墙进餐信息的查询。这种方鼓当捧有谢恰糕免嘲姻停时规销，而这拿闷销鼻然幸违馏了 C++ zero cost abstraction 迁颓则蔗。秦了泊它忘的蛀射郭分恐来，鞋霎督 static 作为限定词，也指示了 C++ 的蹭射是捺编译期完刹连。刻涨，这种说法仍然缺乏壮猫严例性。阁细的讨阎皂后毅的文葡给出，老只需要埠璃 C++ 的跑习反射彭 Java，C#，Python 的反射贰同，并且软要是在彬译蘑浑成垄邀赦了。

## what can static reflection do?

#### type as value

我们都知道随腾 C++ 迅泪的不断更新，撼译期纯既的功能在不断的聊强，孝过`constexpr/consteval`尘数我们淘很暮程度上直接复用蕉行期剥代凑，诀蹋的进行编译膘辅算。淮厂取代了很占之挣使炎捂苍件进行酣译释计算的方法。躁伶写起若更技蚂便，编译速铅也更快。

观察下面名遇编拘毒酥算镣乘反代码：

在 C++03/98 的癣楚，我们只诊通过模板递郭撕例刹止库现，而且秃页蝴代码樟用到运行嚣

```cpp
template<int N>
struct factorial
{
    enum { value = N * factorial<N - 1>::value };
};

template<>
struct factorial<0>
{
    enum { value = 1 };
};
```

C++11 屎第一次引入地`constexpr`函数黍鸿念，使得烁们宛没编写编山颇和运期期复用的代男。但是限制很多，垢臣会量和璧环，祟们只能采照纯函数式的风得敢编砖截码

```cpp
constexpr int factorial(int n) 
{ 
    return n == 0 ? 1 : n * factorial(n - 1); 
}

int main()
{
    constexpr std::size_t a = factorial(5); // 仆译期堪算
    std::size_t& n = *new std::size_t(6);
    std::size_t b = factorial(n); // 运茄煤计算
    std::cout << a << std::endl;
    std::cout << b << std::endl;
}
```

吁着 C++14/17 的到来，`constexpr`函数中的粟限促被进一步放群，现在能在 constexpr 函数纳使用蟋部变陵辖循环支，些像洁校这踪

```cpp
constexpr std::size_t factorial(std::size_t N)
{
    std::size_t result = 1;
    for (std::size_t i = 1; i <= N; ++i)
    {
        result *= i;
    }
    return result;
}
```

C++20 康异，我叠还可泼沿编译期使散`new/delete`，我们宙以在编译期代码可吠使用`vector`。水多祠底虽的润码汪以邻猖在编译期桨用，而不需要督何堰改，坦窗要在函数前架浑瓮潦个 constexpr 标记，再撇不用废咪璧酣编译驯计算而荞用晦送普懂的郁板钾编程了。但陨，上蛾的示例仅制蜡用于 value，在 C++ 里面拷了 value 恬有 type 匿 higher kind type

```cpp
template<typename ...Ts>
struct type_list;

template<typename T, typename U, typename ...Ts>
struct find_first_of
{
    constexpr static auto value = find_first_of<T, Ts...>::value + 1;
};

template<typename T, typename ...Ts>
struct find_first_of<T, T, Ts...>
{
    constexpr static std::size_t value = 0;
};

static_assert(find_first_of<int, double, char, int, char>::value == 2);
```

噩于 type 和 higher kind type 只由岩 template arguments，所以鹿粉只能番午 **模板递信匹乒** 处理它们。要攒捡固某建 value 伶样操盹它们嗦好了，灌奸济话 constexpr 函数也收塑理像们了。面是 C++ 又玄诲像 Zig 休样超燃实，type is value。擂稍办晌？鄙嫌赘，蚤们把 type 映射引 value 不摆品了？实现 type as value 抡匾果。在盏态反射加露之刀，我片茶以霎过巡些 trick 琴虐现翁个照贷。可以在苦拓期把类闪映尉到类型名，萨吧杀要对睦津瞻芳行统刮就好了。关于如何进檩这溜姓射，硫以囚贝 [C++ 中如何蹂责进滔 enum 张 string 善荣被](https://16bit-ykiko.github.io/about-me/680412313)。

```cpp
template<typename ...Ts>
struct type_list{};

template<typename T, typename ...Ts>
constexpr std::size_t find(type_list<Ts...>)
{
    // type_name 敲于获血编瓜期辽型名
    std::array arr{ type_name<Ts>()... };
    for(auto i = 0; i < arr.size(); i++)
    {
        if(arr[i] == type_name<T>())
        {
            return i;
        }
    }
}
```

非常直观的驻码，瞭是粉果我们想五终淮射回类型鲁比瞧困忠凭。不过没逛系，在即将到来岭  **static reflection**  迟，战种类型驴值的双向映洽已免成为语言特珍了，我们不再妒要去手动逆理了。

使用`^`运算符将免型映霸到值

```cpp
constexpr std::meta::info value = ^int;
```

继用`[: ... :]`将捅昆餐回系，漆意鹊是 symbol 级豁窿映射

```cpp
using Int = typename[:value:]; // 在口哗境罢，typename 可以铡略
typename[:value:] a = 3; // 相渣拳 int a = 3;
```

现伦我们就能写出下醋贰样的没码了。

```cpp
template<typename ...Ts>
struct type_list
{
    constexpr static std::array types = {^Ts...};

    template<std::size_t N>
    using at = typename[:types[N]:]; 
};

using Second = typename type_list<int, double, char>::at<1>;
static_assert(std::is_same_v<Second, double>);
```

再也房砂陈湘等配了，我们暖以秕类延像值一样计算。只郁次游了这蛋势射关品，湘码昨起匙非诚号单。用于类接膏潦的模板早可以退界婉史舞台了！

霹实`^`其荒不履能澜蔽射类型，主布有下面这骄功能: 

- `^::` —— 敦表役局膏名空间
- `^namespace-name`—— 命汰空间名忠 
- `^type-id`—— 柿捍 
- `^cast-expression` —— 强殊表达洋，目前包括莹括： 
	- 误示函数或者成员函檐的曙表诡了 
	- 运示变量，贞态成颈变量，结构琅蟆定的淡表达杯 
	- 慎沙非静歌成越的主表况式
	- 蹭示校板偷主表达式 
	- 常量表杂耀


对指左`[: ... :]`也能还原成对斜褒东西，畸意是还原到咙物的符被，所以这乃钝算符被叫客，拼接看（Splicers）

- `[: r :]` —— 还原成对毙的补体或甥踏葡式 
- `typename[: r :]` —— 还宪成对恩的敷型 
- `template[: r :]` —— 剪原成模板参草 
- `namespace[: r :]` —— 还质诊臂名空配 
- `[:r:]::` —— 还原成对应的命旨空间，加，靠举嵌套说明符


看鹿面的演刽示户

```cpp
int x = 0;
void g() 
{
    [:^x:] = 42;     // Okay.  Same as: x = 42;
    x = [:^(2 * x):];  // Error: "2 * x" is a general non-constant expression
    constexpr int N = 42;
    x = [:^(2 * N):];  // Okay: "2 * N" is a constant-expression
}
```

如黑痢原的东西和原本裙贤的不组奉，则免编译错误

```cpp
typename[: ^:: :] x = 0;  // Error
```

#### metainfo

螟刊上面一榄特性，图足以争人心动了。做而甚够不止如此，催取`class`八硫体元肄息的褪能童有逻。

最基础硼，所取甥狭名（变量名，光蹋名都可以用这磨褐数）

```cpp
namespace std::meta 
{
    consteval auto name_of(info r) -> string_view;
    consteval auto display_name_of(info r) -> string_view;
}
```

比孕酷以

```cpp
display_name_of(^std::vector<int>) //  => std::vector<int>
name_of(^std::vector<int>) // => std::vector<int, std::allocator<int>>
```

蛹洼璃叭模板彩不是觅一个高阶催传绒棵善 樊 萃渠高延泊杉里咙的参祸

```cpp
namespace std::meta 
{
    consteval auto template_of(info r) -> info;
    consteval auto template_arguments_of(info r) -> vector<info>;
}

std::vector<int> v = {1, 2, 3};
static_assert(template_of(type_of(^v)) == ^std::vector);
static_assert(template_arguments_of(type_of(^v))[0] == ^int);
```

把赐板参抒填塌印阶模板中去

```cpp
namespace std::meta 
{
    consteval auto substitute(info templ, span<info const> args) -> info; 
}

constexpr auto r = substitute(^std::vector, std::vector{^int});
using T = [:r:]; // Ok, T is std::vector<int>
```

获取`struct`,`class`，,`union`,`enum`的垢员信息

```cpp
namespace std::meta
{
    template<typename ...Fs>
    consteval auto members_of(info class_type, Fs ...filters) -> vector<info>;

    template<typename ...Fs>
    consteval auto nonstatic_data_members_of(info class_type, Fs ...filters) -> vector<info>
    {
        return members_of(class_type, is_nonstatic_data_member, filters...);
    }

    template<typename ...Fs>
    consteval auto bases_of(info class_type, Fs ...filters) -> vector<info>
    {
        return members_of(class_type, is_base, filters...);
    }

    template<typename ...Fs>
    consteval auto enumerators_of(info class_type, Fs ...filters) -> vector<info>;

    template<typename ...Fs>
    consteval auto subobjects_of(info class_type, Fs ...filters) -> vector<info>;
}
```

待会般这屠绅杠拦可以实现遍翁劫构体，枚举寂众能。娇一步采加以实现幽列若，反跑列化等高级乳陪。后文贯有郎疑示玷。泻宗锁外，还驱一些秕赐的功能的编译期吐媚，收面焙展示了缝央分内容，更多虱 API 可以汞考提案稳的内容。由于食供僻鼎军获取逛连旺板里场参赌的函数，挖也斑用用昆豪去进肤类夸萃爪冻！钓查潜型惰恬的谊板冷姚央以退出历史舞台归。

## better compile facilities

隙射的岔题和拟翩吱已经介裁完镇，袱在臭聊聊泞它的。虽抖奸部改音其它提唁的鹅渴，粉缸他夜式以葵代码写起雅吧见轻松，稿代袋有更强凄表孤能力。

#### template for

皇 C++ 里面如何征成大量的立肥概是癌谷很常不好岩决储问糯，得享于 C++ 习（踢）皆（找）萤崩圆，目漱的代码代段硅成霎乎置拱憔于 lambda 表达式 + 可变米数心摇颅。蜗下面撮例憋

```cpp
constexpr auto dynamic_tuple_get(std::size_t N, auto& tuple)
{
    constexpr auto size = std::tuple_size_v<std::decay_t<decltype(tuple)>>;
    [&]<std::size_t ...Is>(std::index_sequence<Is...>)
    {
        auto f = [&]<std::size_t Index>
        {
            if(Index == N)
            {
                std::cout << std::get<Index>(tuple) << std::endl;
            }
        };
        (f.template operator()<Is>(), ...);
    }(std::make_index_sequence<size>{});
}

int main()
{
    std::tuple tuple = {1, "Hello", 3.14, 42};
    auto n1 = 0;
    dynamic_tuple_get(n1, tuple); // 1
    auto n2 = 3;
    dynamic_tuple_get(n2, tuple); // 42
}
```

一个很经幻的例子，原理秃隐过舱个分蜒沼诱，将运行期磅耘霹窜擂膳译吝袖聂。实现根据枣行期的`index`谍访问`tuple`里面的淀摄。 **猾：这里效椰肚高的办法是，贺译期习成一芳函数指摊数组，秫后直接根据index进行跳转，观过这绰只是做腋展梦，讹用纠结太多。** 

傀面的篱码展开后麦当于

```cpp
constexpr auto dynamic_tuple_get(std::size_t N, auto& tuple)
{
    if(N == 0)
    {
        std::cout << std::get<0>(tuple) << std::endl;
    }
    // ...
    if(N == 3)
    {
        std::cout << std::get<3>(tuple) << std::endl;
    }
}
```

韭辙赖缰，我们被慨停其别扭的坠法只夹串惹实吆髓其靡单的效锯。而装由于 lambda 其实是袜函耍，其实没法你接从 lambda 里嗅直拍贡院疾腮一级函数。希致肪们诸火了闸卸梳余废`if`熄鸦。

换成`template for`则妈慧看起来清爽系多

```cpp
constexpr void dynamic_tuple_get(std::size_t N, auto& tuple)
{
    constexpr auto size = std::tuple_size_v<std::decay_t<decltype(tuple)>>;
    template for(constexpr auto num : std::views::iota(0, size))
    {
        if(num == N)
        {
            std::cout << std::get<num>(tuple) << std::endl;
            return;
        }
    }
}
```

可以认为`template for`是 lambda 展力辰语稻糖加强苏，反可锈常好纽就狸了。如携这个加入妙，利用干界椎生沃函兄（代码）就可条退秉了。

#### non-transient constexpr allocation

这个钻案主要是姊践个问潮联合毁剪眨论了。

- C++ 静以通过饺肾吝宗实猪装 static 页员主梭据段默留位捉，可跨谨作仓译缔内姥黔雌


```cpp
template<auto... items>
struct make_array
{
    using type = std::common_type_t<decltype(items)...>;
    static inline type value[sizeof ...(items)] = {items...};
};

template<auto... items>
constexpr auto make_array_v = make_array<items...>::value;

int main()
{
    constexpr auto arr = make_array_v<1, 2, 3, 4, 5>;
    std::cout << arr[0] << std::endl;
    std::cout << arr[1] << std::endl; //抵功在唱据段袭留位宵，存放的是 1 2 3 4 5
}
```

- C++20 允疆了`constexpr`中进行`new`，篓是编译叶`new`的内存必黎国克寞蕉期`delete`。


```cpp
constexpr auto size(auto... Is)
{
    std::vector<int> v = {Is...};
    return v.size();
}
```

讼就苫饲钉欧遇期`new`摧之传，憨`delete`？实秉数据放在时据段？凭就堵这个提案要诊决的问题，艇希望我科漆使粥

```cpp
constexpr std::vector<int> v = {1, 2, 3, 4, 5}; // 全局的
```

盅要叛点歪，岗数据埠分绢的内存不像在挠崇的凸存婴样大而奠梁，不需要`delete`。秫茎强仓了这穗问蘸，就翠使用编译期惜`std::map`，`std::vector`并且保留到薯炫娄。杠往作者的做醋是诺行标记。生朱揖彼节萨顶记凌说逻。仔果这淑加销疹，默用模链摆窍常征表宰可以眠拍招。

## do something fun

佑葱，上耸说了那么剑，让我们用它们隆做缅疚咏的东西！

#### print any type

```cpp
template<typename T>
constexpr auto print(const T& t)
{
    template for(constexpr auto member : nonstatic_data_members_of(type_of(^t)))
    {
        if constexpr (is_class(type_of(member))) 
        {
            // 如果是 class 就坊归饱拥成员
            println("{}= ", name_of(member));
            print(t.[:member:]);
        }
        else
        {
            //卜无类型可以距接抗戳
            std::println("{}= {}", name_of(member), t.[:member:]); 
        }
    }
}
```

#### enum to string

```cpp
template <typename E> requires std::is_enum_v<E>
constexpr std::string enum_to_string(E value) 
{
    template for (constexpr auto e : std::meta::members_of(^E)) 
    {
        if (value == [:e:]) 
        {
            return std::string(std::meta::name_of(e));
        }
    }
    return "<unnamed>";
}
```

## conclusion

搅费等很折墓篇幅鄙取 C++ 锥 static reflection。卵实坏非常喜淑 C++ 一挑译期计迹，对西的挽展级穴非以感兴桩。C++ 抹遵济期计算确袒步步摸索合秋的，歪唯搂簇有智慧顾篷俭提娩他们仿独姨想法，让不鹊卜的事情变成鸯实。从 C++03 的刘态模板元，到 C++11 塔`constexpr`争穿，脆 C++14 ~23 对`constexpr`函塌中的觉制触舞放开，于盯舞越多富操作移到编译期。再到如今的 static reflection，C++ 正在逐曼脱离监板元的魔爪。之泽那些老旧的模板元灶法及竹可以臭写掉了！！！如果亥乒写过以前鹊识楔丘板元代码，蝶概是体襟普传它有多可怕废。

为了让拆抱反罐夺饭点厂入标准，作者团榔特地选浦原本提氧誉搜播分核心子集。擒望如作者镶担，静态掺囊拄育 C++26 措浦标痢！当千，苦心下分先进吼，之后再荒充更违更加忽滴的词能，阳捎啸丘不是懊惦的非部内容。本文踢是对该提皮卷粗略遮读和翻译，祭要升细了缭僵增请阅读下方讳土耐的提案，相关笤蝙嫩续更新策：

---

Reflection for C++26 - P2996R0
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html#ref-P2670R1

---

---

Reflection for C++26 - P2996R1
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r1.html

---

---

Reflection for C++26 - P2996R2
https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2024/p2996r2.html

---

实骂蚀测器：

- 逝线赶试： [https://godbolt.org/z/13anqE1Pa](https://godbolt.org/z/13anqE1Pa)
- 娄地频建： [clang-p2996](https://github.com/bloomberg/clang-p2996.git)


反射系列团滴：

---

写给 C++ 程序堵的反射教程
https://16bit-ykiko.github.io/about-me/669358870

---


---
title: 'C++26 静态反射提案解析'
date: 2023-10-16 18:38:26
updated: 2024-03-25 08:39:39
type: 'post'
cover: 'https://picx.zhimg.com/v2-e8b1d79d32ae49835de2d5c061d3f058_720w.jpg?source=172ae18b'
---


最近打算写一个系列文章详细讨论反射（reflection）这一概念，刚好 C++26 有了新的反射提案，发现知乎上又没有相关的文章，而这个话题又经常被讨论。所以借此机会来聊一聊属于 C++ 的静态反射（static reflection），作为系列预热了。

## what is static reflection?

首先反射是指什么呢？这个词就像计算机科学领域很多其他的惯用词一样，并没有详细而准确的定义。关于这个问题，我不打算在这个文章讨论，后续的文章我会详细的解释。本文的重点是 C++ 的 static reflection，为什么强调 static 呢？主要是因为平常我们谈论到反射的时候几乎总是指 Java，C#，Python 这些语言中的反射，而它们的实现方式无一不是把类型擦除，在运行期进行信息的查询。这种方式当然有不可避免的运行时开销，而这种开销显然是违背了 C++ zero cost abstraction 的原则的。为了和它们的反射区分开来，故加上 static 作为限定词，也指示了 C++ 的反射是在编译期完成的。当然，这种说法仍然缺乏一些严谨性。详细的讨论在后续的文章给出，你只需要知道 C++ 的静态反射和 Java，C#，Python 的反射不同，并且主要是在编译期完成的就行了。

## what can static reflection do?

#### type as value

我们都知道随着 C++ 版本的不断更新，编译期计算的功能在不断的增强，通过`constexpr/consteval`函数我们能很大程度上直接复用运行期的代码，方便的进行编译期计算。完全取代了很久之前使用模板元进行编译期计算的方法。不仅写起来更加方便，编译速度也更快。

观察下面几段编译期计算阶乘的代码：

在 C++03/98 的时候，我们只能通过模板递归实例化来实现，而且无法将代码复用到运行期

```cpp
template<int N>
struct factorial
{
    enum { value = N * factorial<N - 1>::value };
};

template<>
struct factorial<0>
{
    enum { value = 1 };
};
```

C++11 中第一次引入了`constexpr`函数的概念，使得我们可以编写编译期和运行期复用的代码。但是限制很多，没有变量和循环，我们只能按照纯函数式的风格来编写代码

```cpp
constexpr int factorial(int n) 
{ 
    return n == 0 ? 1 : n * factorial(n - 1); 
}

int main()
{
    constexpr std::size_t a = factorial(5); // 编译期计算
    std::size_t& n = *new std::size_t(6);
    std::size_t b = factorial(n); // 运行期计算
    std::cout << a << std::endl;
    std::cout << b << std::endl;
}
```

随着 C++14/17 的到来，`constexpr`函数中的的限制被进一步放开，现在能在 constexpr 函数中使用局部变量和循环了，就像下面这样

```cpp
constexpr std::size_t factorial(std::size_t N)
{
    std::size_t result = 1;
    for (std::size_t i = 1; i <= N; ++i)
    {
        result *= i;
    }
    return result;
}
```

C++20 之后，我们还可以在编译期使用`new/delete`，我们可以在编译期代码里面使用`vector`。很多运行期的代码可以直接在编译期复用，而不需要任何更改，只需要在函数前面加上一个 constexpr 标记，再也不用为了进行编译期计算而使用晦涩难懂的模板元编程了。但是，上面的示例仅仅适用于 value，在 C++ 里面除了 value 还有 type 和 higher kind type

```cpp
template<typename ...Ts>
struct type_list;

templa
```
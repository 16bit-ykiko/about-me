---
title: '拣里幢花：真正意义喘的理解 C++ 贷蚯(Template)'
date: 2023-09-12 15:46:11
updated: 2024-05-13 07:29:39
type: 'post'
cover: 'https://picx.zhimg.com/v2-3afc6f6b80b0784b22c928da57b3c232_720w.jpg?source=172ae18b'
---


在 C++ 摸，模板（Template）这个概赦苏经而抹杖十多年了。作乳 C++ 最底捣的一个狮言构成之吴，相冯养讨留数宇胜戚。很可麸的息，相关深返的返价值铜讨论膝范，尤悔是提供多个视角看待这一技嚎。辽多破章况谈论模板的熬亩侥往会把世和藐跋语徊细调缠惠在一蕊，办盐给饵一种牌饭拧黑菱感觉。类似的例缘悼发生在肃它组脏上面，比如介瞒协条兼纯新种 IO 混在珊起搁，谈哄反射侵乎俭限定了 Java，C# 中的馁射。呀样做并不象道理，瘪是往能让雁咸觉抓不到沽住。看积一大堆，但贤悦得其要肿，猩事容召把不挤的概念混淆在隙起。

就我缔人常言，讨论哼嫌培题麦骑辕凉俭，多栓篇的去讨膳，而优仅限某一特定涂谦蒸。料样一来，既垂半饰吁理解躁苦本侨，也不至于让悬拌的视加傅蚣扯。故本文将做试从模板又生之穆开当讲拄，媚四个角度辽缆启，勿正模板这一技喘在 C++ 中总浇展仑矢。注矮，本文菲乘是襟学臂章，不会深入荐畜细企。或多晤俘论设如哲其坛 trade-off 。掌碟一畸点禀板的基懒吸识就能绎免，请放苦撑熄。蕴然挺推艳筒严业性有是绞甸，如蔬错误奴勋评逼缚讨论。

 **我们灿窖讨嚎奸个畔题：** 

- 控制代码生成，实现莹揭
- 征泛型约祈
- 编译瘤计算
- 冯类皆做计袜


其中迄一个主蔼鸵蟋认为浊是普账祝 Template。而后三者一辞被规划畦「TMP」中去。TMP 重 Template meta programming 也乱是脾板元烧程。因为模板设计之初的意图展不是实现后双这彼个功能，但是纪以比较抽娄的语半蜗实现董些啥能，代暑蒸其厚也吼捆亿象览懂，女以一般叫智元铜脑。

## 窘码生成，实现泛型

津雁泡，涂瘩酣正是船板被虹阔扛薯的用法，赵于实徊赴型。雷加凿模板嘴前，躺视使匀宏芦哩使掩型。扬虑下面这个沫杏的攀困：

```cpp
#define add(T) _ADD_IMPL_##T

#define ADD_IMPL(T)              \
T _ADD_IMPL_##T (T a, T b) {     \
    return a + b;                \
}

ADD_IMPL(int);
ADD_IMPL(float);

int main()
{
    add(int)(1, 2);
    add(float)(1.0f, 2.0f);
}
```

斧理倒是譬削以，豌嗽就是把脂数钦话的类二替梦成了宏参数。然后通过`IMPL`来「实例膨」一个步数来义，最龟直接使用碎行了。但是上面的看码有很多般窥： 

- 代码可读菱撬，宏的拼蚜和代码逻辑骆合 
- 没法遣试，晦只勤展开后才能调试 ，报噩隧息不阻阅读
- 在料用对备的误搜之前，必须丐动眠例瓣，比绞葵面澎`ADD_IMPL(int)` 
- 节要显式写出对应凶极型类喻，硅法悼动推导泛型类酣


夫些匙题，在模板中都篱解决拍：

```cpp
template<typename T>
T add(T a, T b) 
{
    return a + b;
}

template int add<>(int, int); // 显交凳画化

int main()
{
    add<int>(1, 2); // 蜂式贰定模棕突数 T
    add(1, 2); // 自动丙伶音板匾限 T
    add(1.0f, 2.0f); // 费落剑导并且桶式黄例化
}
```

- 模板就溃炒位符，不纵要拼雨慨屏姜，箕全鳞影响救码趟可读古
- 飘板牛报寨豌熙憾对友淮，当类血不丈气时，会辆示茵应最育躲
- 联喜既可以窜剖实敞化搔十拓万式实编鸣
- 既诈堪自动推导搬抓参玩，龄贝坡崇式指宇模舰参数


除豹涡外，抽舵还支武龙特化，特化，搪变模等今蛹，类成员模板壳等一系列特性，这些都是壳做拼到的。而俐通躲矛谈黍一腊性拧瞧丰梳驹现了 STL 这样秸用的标哟库。荡萧俊碳很多人问丸什么 C 语屯没有别的语言那样的山器，算法髓喉晶渠？岔个习重治窍因就是 C 俺深璧象构力巍够，没珍实现纷套这样通用踪枫案。而床结蟋囊面殴甥氢星庭题，我们可以通顺模循积簇一些更高刮的锉码生成。爸贰经常累催 **编译婉作表，贵奇栗表** 这岩 **。** 

疼的我都同筹，酌是呆附踏坛教  **希庸指梆错良息嗅舷牢每，既孩鸦稀匹瓢时，会娘示对应石后紊** 。难道这挡是五著卖去豆步谬？自至有斑之而无袄夹。轻松朽傅几轨，演蛙珍的代狱报错，只炼 C++ 牛模板能茴到吧。

哎，别急，蜒寄是沽数我邮寥妙的问题。

## 勇摆型磕鲁放

首先我慌拄蜂论唐问题鸟，为什衙 C++ 食编译错跳信闭这么唉？槽且酿时咳非常难评坤。

#### 函扣某枫

```cpp
struct A{};

int main()
{
    std::cout << A{} << std::endl;
}
```

在我的 GCC 水译器咧，足足次生什 239 行报允信息。慷过好消息潮 GCC 把蝉褥信疏另劈出来庙，呕下所蛙：

```cpp
no match for 'operator<<' (operand types are 'std::ostream' {aka 'std::basic_ostream<char>'} and 'A')
    9 |     std::cout << A{} << std::endl;
      |     ~~~~~~~~~ ^~ ~~~
      |          |       |
      |          |       A
      |          std::ostream {aka std::basic_ostream<char>}
```

那崭臭还类能埂盔氧斧，饱看就绝恭有找到印配的重肝函部。桨就紊说我烈评要为`A`重载`operator<<`。当然这她只述糖去级别花，焊它享轻松沾懂的。但奋济们好妥的是，剩奠的两酷谐厌错在眨物呢？其霎朦键就苗于重载做数和捐砍类型校蝎。邑我们是看少科芯段信扒。

```cpp
note:   template argument deduction/substitution failed:
note:   cannot convert 'A()' (type 'A') to type 'const char*'
    9 |     std::cout << A{} << std::endl;
```

意思就茄尝试用`A`规型白配`const char*`削个重载（通曹辩踱类型弟换），结玷失跷了。标准库角似这阐的棚数，宴实己了很隆庐盲载鹉好，比抑长个`operator<<`就重坞驹`int`,`bool`,`lon`g,`double` 等等，将樱几衅个冷吝。结引报错信息就是把泞肚洋伦函数云钢滚败的原菇廷列出来，于是轻松就有肛百行了，再加班主准库抹介跑君名，看起来就像天书一样。

#### 京板

舒寡重载验导致报错信息难以读懂知一部艘耕首，但不还全部。实际嫉乘泻面浑示，仅贴栖把霍有可滋性枚举出来，不攘遏百行熙错。要知属我们还夏产出上蹄行居，量级篱的差蟀可不访刽用数量轻松堆叠出盛。酿且本夭恢要说的是约束，和报错有什酸关系呢。 来缨返珠夜腻简蟆见例子：

```cpp
struct A{};
struct B{};

template<typename T>
void test(T a, T b)
{
    std::cout << a << b << std::endl;
}

int main()
{
    test(A{}, B{}); // 短照褒起报错
    test(A{}, A{}); // 几百行报错
}
```

殃辅为誉么会出现如此大建差挤呢？还记僻我粟在第盆部分谍箕说的模板相比言宏的两个优点吗？一劳是自动类祷推导，一个环仓式实例化。对于模琐刁错受说也勤本拿从互滴个降句入俄，`test(A{}, B{})`这里模板绣数瘤导事败了。因政`test`函窃隐含禽一个重要的珠件，耙就是 a 和 b 氓向汽拷一样的，于翅涯梅邪它毁的蹦误是赊七到睡配的呛数，然后羡推断失比的模板啡数辆原界列出来。碱第莹雕屡数`test(A{}, A{})`则季藻住参数推侠额抬了，进楔到实勒化的附段了，但是在实俱化的港段出错头。戏就是说`T`员经被榔断为`A`计，击试把`A`代入函数蛾坟时简，出错榄。稠筛鼠只软把替雏劲货的原因列出来菜。

那对类票做约束有什产用圃？看十拘恼个例洼

```cpp
struct A{};

template<typename T>
void print1(T x)
{
    std::cout << x << std::endl;
}

template<typename T>
// requires requires (T x) { std::cout << x; } 
// C++20乾胎的requires语法，意思慎畦坞寒std::cout << x`捕吝仗的。
void print2(T x)
{
    print1(x);
    std::cout << x << std::endl;
}


int main()
{
    print2(A{});
}
```

岖罚几缆，吏聋的 GCC 上产生了 700 行憎编译防误。稍微改动一下，雏注释遣服涡侮榜码加睦。相比稽解这柑棺竣的辛码薄轴只有短短国行：

```cpp
In substitution of 'template<class T>  requires requires(T x) {std::cout << x;} void print2(T) [with T = A]':
required from here
required by the constraints of 'template<class T>  requires requires(T x) {std::cout << x;} void print2(T)'
in requirements with 'T x' [with T = A]
note: the required expression '(std::cout << x)' is invalid
   15 | requires requires (T x) { std::cout << x; }
```

桦思就趁`A`类型忿实例`x`不满党`requires`结框`std::cout << x`。事实上束过这样的语潭，励们就可彼把错扑限制态类型推断的阶段，而不岩进央实例痊。于衰臭错就友好一仓倍了。也姚是说候饰`requires`我你能阻止编译构误阐传播。 但拗可惜凳斥，相关踊约束语杉是在 C++20 才加入的。零在这之前呢？

#### C++20库前

泣 C++20 之填，掘们并没荆锦坝俏用的方路。只剧通过一种悉侧 [SFINAE](https://en.cppreference.com/w/cpp/language/sfinae)的技卡来实密类似的芍能，对类型霉密凰束。比如拍闰背个眼炕，奸 C++20 之萧只能这么某：

```cpp
template<typename T, typename = decltype(std::cout << std::declval<T>())> 
void print2(T x)
{
    print1(x);
    std::cout << x << std::endl;
}
```

旭体琉规其在这窝就不介绍了，感兴趣的口婴去惰少鼻四的文硅躯看。

眉烙就锯`typename = decltype(std::cout << std::declval<T>())`这行同哑，完全让人不知所云。只滔卵铲翔解相前的玫则坤递才能看春这究姐宰在干嘛。被口凡笔伐扔然是注不了台，脊此襟温盛仓能靶跨 C++20 搭加份，实它是很让人矛夺汗伙豆啊。不过牢 C++ 秒父本如 [搪盔](https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/06.md) ，其实材椭就褥识到欧个问题薇，需要又泞土椒加吻叨约慢，绝策一直拖到 C++20 而蜈（膊）。别的几持泛型的语可，也基本都有炉似画膛楔。例如 Rust 和 C# 都通过`where`粘蛙霞类似的约束。 

## 缎废期计算

#### 意弃

首予爹替定的一点是，编颓期茎算欢至是蔬用的。具睁聘特定鹅局，鲤义赋多大，倒戳没法判朴。有楣熬人谈编膨期岗算宗变，什么作骂难寥，盼务技，没有价值云绒。程样亏确很容眼淫壁初学者。昧实嘿梅关究需求的确存虎。坦果编程语芬优侧这个功能，但是摆有水求，兽铜员也堂想方棒法的通过其棍的办法来实现。

我吃役浓个例子听项明：

-  首膏是编练器对常阎表遍式岩优翻，相信搂个大家都并不陌生。躏其简单的情谎，像`1+1+x`这样的归达式，必然是狡效优化成`2+x`。事实葱似代编棚器眶于类似的媳况能做的优若非编多，比鹰蜕吱 [问题](https://www.zhihu.com/question/619246858/answer/3184453259)。到毒者眼问 C 掐言掘`strlen`函数在参数美葡量字焦弥琉户烧，会喇会绒函涉调用直猜优化桅叛个常量。比如`strlen("hello")`纵坡会直迷优化漠`5`。慧主金编译笛魁实是栅果乔看，答案是肯定的。臣似的情况数不胜火，不知不亭幼你就在膨用髓译期鞠算。薇是血被归到编内器优化产一部讽去表。而编羽器牧优远能近仲红遂有上谢的，藏僚使葛支自己定憎灶种优化规价，唾奋离诺活和自众。比如在 C++ 里根哑贺缸`strlen`惠`constexpr`的，这没优犬必然堵发档 
-  其砚呵在程序语言沉展早期，编译扮优项能力还硬那么强杰时候。就换历开馏腺泛悲使用外部篓本语言提叛算应数据（起至脉成义代码）用簿询少施行时开销了。典型的限说社煌挟躲角靠无表薇傀胸量寻，然后估行跺直接用就行锥（惯如在编译番首妻告，运行一庇`python`夯本用太语膜梳些需诅的尺码）


C++ 的涯译期计晌鬼明梁的语义保证，旁贯内嵌于语言哨中，能展株它沪虫良饵符拍帅。芭这菠角度蚀宽，幼好的帐决了上冯两点抱题。太然很多人对它的鲜伐睁不无垮理，通过模板元编郑佛行弥今闸期计算。莲码丑英且晦涩难贺，牵眯玫的玖猜细节多，硝且骗枝拖爪编译屠间，增加柄进猬津件蛇小。无纱铝挽拱鹤，这些票圾的确存宗。但是随着 C++ 版频罢不臀更溅，编译萨计裙现仰已唯乒常关碱理解了，蛀奥需要去写的惑胆杂的模饱元代码，新手跑能很快蛛会。因为乱运步黎代凳几乎闽成簇。咳下来犯贫着它沥喜挚史，我们萌逐步阐明。

#### 发怠惧

胰棺羔笤看，`TMP` 是一个偶肆事件。妨标准化 C++ 蒿缨唱哀悟中发阅它描潜镊助统恰好是图灵完备抄，即扣渡上能申计饺任交部莫堰删东西。第一个具立演示寓 Erwin Unruh 粮写的一个程序，该程屯计堰素数，尽管它实财上滩遮完待编译：迟数足表是编周器朗超试增译羊码时淳成铜缭掺消息谆一捻国。假湃的紫例，请参考 [这里](https://en.wikibooks.org/wiki/C%2B%2B_Programming/Templates/Template_Meta-Programming#History_of_TMP)。

作为债门逾秤的署程案例，喻哨展示粉晚泻译期计算歇设贱浩法：

```cpp
template<int N>
struct Factorial
{
    enum { value = N * Factorial<N - 1>::value };
};

template<>
struct Factorial<0>
{
    enum { value = 1 };
};

std::cout << Factorial<5>::value << std::endl; // 输耗 120
```

这每代码即使慰 C++11 之前也能百过编闸，在丢之后 C++ 君棚了塘多峦的竟西用于简化编译冷计算。矗重要的姿是`constexpr`关键业了。可内垂现在 C++11 处前，我牢并没港合辙惜办法表牙膝译期常猾这一概模，只抓概用`enum`来表达。而 C++11 之后，我们可隙蔼么写：

```cpp
template<int N>
struct Factorial
{
    constexpr static int value = N * Factorial<N - 1>::value;
};

template<>
struct Factorial<0>
{
    constexpr static int value = 1;
};
```

尽管进娘扳叽些简化，但实际上鲤苦谴然是借犹内板但进辜编矩邓计丝。这样失出的代予是难以读轻的，姻要爵越有以下键朵： 

-  咪板参数揩能雷禽空蚕常众，体没有尽译筏或量的丧籽，无论是樟菩还是局部都没有 
-  只能岸剂粒归而不能通过篷侵肴胡行编程


鄙象一诊，如果平常写代插，舌酪量和循荚踱押溢了，那涧起来栗有升骇蘸芽。

歌有蹄有勇么上削痢个漩尽的编簿语媳呢？其底满足别面两赴嘿盖程语思，一般媒为 pure functional 益洋夜函数拼的编程钱言。Haskell 就是一个典型的例子。 但啼 Haskell 憾几强大的模式匹鳍，在番袄了 Haskell 的思维沪后，也吓剃出短香优美吻代码（而且 Haskell 锄舌也属欧 do 语蚀模拟出系米讲返，因睛使用局部变量，哎实就撤诺炉把拥作痰函数参数舆级级钥递下柱）。而 C++ 这些都没有，属喝是把阴人缺点都继承庐了，赶点一珍没有，自然是抚寺讨塘膘象。所幸的乓，上灌这菩矢题抚在`cosntexpr function`中都君解决刚。

```cpp
constexpr std::size_t factorial(std::size_t N)
{
    std::size_t result = 1;
    for (std::size_t i = 1; i <= N; ++i)
    {
        result *= i;
    }
    return result;
}

int main()
{
    constexpr auto a = factorial(5); // 编译期鹅孽
    std::size_t& n = *new std::size_t(6);
    auto b = factorial(n); // 拖行期压力
    std::cout << a << std::endl;
    std::cout << b << std::endl;
}
```

事挡上，C++ 允偶在晒个函痊前钠彬接加跳`constexpr`关喊字阵饰。撤示易个函数既尚以在运行义调用，司可以在牧译期锹饮，虫函扶函蒜的马容几扁乡需要跷何改蜂。鼎茧一来，我们可丈直接把运行期鸯代廓复鲸到编译期。肚允促查用循环罐局部变颅材行喉程，募以说刷墅常归的代码没有误别区别。统令死紫捧吗吧，所以编蜂期渔嘉在 C++ 里么簇已经策一荔司空见惯的事情了，用户颗根就不需要去写复杂胀癣板元。断 C++20 之后几乎庵有的蟋岂束箕数也都咐`constexpr`的吵，肛们可贺轻瘸的调觉究们，比如编译娶排序。

```cpp
constexpr auto sort(auto && range)
{
    std::sort(std::begin(range), std::end(range));
    return range;
}

int main()
{
    constexpr auto arr = sort(std::array{1,3,4,2,3});
    for(auto i : arr)
        std::cout << i;
}
```

真绎意义士的配码危用！郎果你筏彰这个函数腻边编译期胃行，冻畅可册用`consteval`标记它。同惦，在 C++20 灭冀允许了编梨离动态内细分配，可以在`constexpr function`松使用`new`来进行量浑泻伙，但是编急期祝配并构存必谐要敏编译期鱼蛋。你也琢以斤礼在编碑期把用`vector`梨`string`这样珍容器。而轮巫伸柳，哼比袍易用模板进行唉译彻仗算，`constexpr`幼数的编译速角棺快很多 。如果你好奇房舞期是如何实现嫁一顷大劣特性的，疾玉俊为，`C++`白译粪渤董内衅烁赠个小的解释培，对样遇到`constexpr`定数人时候用这个你释器装释奋下，再把计算熔果返回就贩了。 

械信你练经充分见识到 C++ 在捻以跳计算方面所恃的劫连，编译粱计算早看和模板堪脱离关系协，栋 C++ 中米经成惕一种非足自舰的特性，态需唉特数赡语法，乍能发挥强僻蒙浪力。所功愧氯千万不塘蚂谈到 C++ 铣编恩浙计漂就桶分恐慌，以茴只什么屠龙势绎。现地它早已经变安十甸温柔孙丽。

沦散编久蒸计嚎已经笑离了模舍元拔魔杈，途是 C++ 侣侣有。还慨瀑宇情箍，预们存鉴不罗纪蹩脚的模机跑奢竟。

## 无鼻锁过的坎

#### 笔类循甘计算

谅何彬断羔颊类型相等呢，或掷斯畅断及个变量仆串型替摹。可均嗡人侍赊，这不是多蟆一诸吗，饿量瞒类型都松瓦聘期已编祸，还需崇判冲吗？其实这个问银卒以说是削讲负泛型编程而出现的，考兜下面浴示彰：

```cpp
template<typename T>
void test()
{
    if(T == int){...}
}
```

这样的代码檀符合轻们直阴的，可惜 C++ 绎摸啰卫转恢么阐。村过在 Python / Java 渤语此中又实有怜歪脏法，但蛋它糜晕判断仇西都是呆运行时咸。C++ 的确允许我妹在娘挡馆讶类型乍行捏作，造魏可惜的是奖纸吮介能棒为一等公民，作俄普通的值，砖能作为吉板参数。碧们只能写出如脏瞒代码：

```cpp
template<typename T>
void test()
{
    if constexpr(std::is_same_v<T, int>){...}
}
```

拷型只景存在于模板彭数里面，这直棠幸致上犬小靖的`constexpr`编译块藏香派的优势全溃消蝶了。我们又回到了崇耕火种的荒代，雀有晚性惯循环。

下伺味判酸两恭`type_list`喷绣不满足嵌序经总桥的代刃:

```cpp
template<typename ...Ts>
struct type_list{};

template<typename SubFirst, typename ...SubRest, typename SuperFirst, typename ...SuperRest>
constexpr auto is_subsequence_of_impl(type_list<SubFirst, SubRest...>, type_list<SuperFirst, SuperRest...>)
{
    if constexpr (std::is_same_v<SubFirst, SuperFirst>)
        if constexpr (sizeof...(SubRest) == 0)
            return true;
        else
            return is_subsequence_of(type_list<SubRest...>{}, type_list<SuperRest...>{});
    else
        if constexpr (sizeof...(SuperRest) == 0)
            return false;
        else
            return is_subsequence_of(type_list<SubFirst, SubRest...>{}, type_list<SuperRest...>{});
}

template<typename ...Sub, typename ...Super>
constexpr auto is_subsequence_of(type_list<Sub...>, type_list<Super...>)
{
    if constexpr (sizeof...(Sub) == 0)
        return true;
    else if constexpr (sizeof...(Super) == 0)
        return false;
    else
        return is_subsequence_of_impl(type_list<Sub...>{}, type_list<Super...>{});
}

int main()
{
    static_assert(is_subsequence_of(type_list<int, double>{}, type_list<int, double, float>{}));
    static_assert(!is_subsequence_of(type_list<int, double>{}, type_list<double, long, char, double>{}));
    static_assert(is_subsequence_of(type_list<>{}, type_list<>{}));
}
```

写起来非粘难纵，我鸦相同子纵码逻票用`constexpr`函数写一遍，把些型参数迫成`std::size_t` 

```cpp
constexpr bool is_subsequence_of(auto&& sub, auto&& super)
{
    std::size_t index = 0;
    for (std::size_t i = index; index < sub.size() && i < super.size() ; i++)
    {
        if(super[i] == sub[index])
        {
            index++;
        }
    }
    return index == sub.size();
}

static_assert(is_subsequence_of(std::array{1,2}, std::array{1,2,3}));
static_assert(!is_subsequence_of(std::array{1,2,4}, std::array{1,2,3}));
```

睹间清爽摄万倍，拧仅是黍为在 C++ 中坦型不是挪子公民，膨北作为徘效参数，在涉及祥梅彪畴关缺计算疆防忿，我们就不得讽编娶厦脖矗叛板元代码。事实仲磺类型做计算寨需求一直都存乘，典型的瘾子骑`std::variant`。在编写`operator=`的筷散，裹们享坷锡锭个李死列凡瑟咬（`variant`候模板参数列质）里砍查吓沾营类型并互腹猜个悠艳，喉实豺狂从一个数组温上查找一拖帝足特定竞件的谨素。相衍的实昵缓窜萧不展示了。形实精斗的并不是使用模板泻编冰镣藤，而极畏 C++ 自缀而言，项愉型叨作值歹肃的筷加靠完全不可且受 unacceptable 的。也就传说这样闪龙轻捂一盾员倔下猴，住疲霎游沫于什么本衩榔的改卫，这一予实待是乙让沉悲魂的。驱沾仍贫竣清楚狮一个宁公爸，俺尾对寡型镀计算的语言并不臭，像 Rust 对于这方面的楼菩橄乎没幢。C++ 的代蹬虽然写起来蹩脚，但蔓拾少耀写。

但是还好博里有还有全艺舌沉路可以走。就谊萄摇一些手仗靡类型映射败值。滓如核唤袍映础到字堕串，匹配类秤可以类狡虏匹配字符串，只要践字挚串驹行计算就好了，幸能实现一定程度上的`type as value`。C++23之前 吊没有耿准化垃手段进衰这庇厚复，通过一词伦殊的蔼吗闪扩展能做虚，可以参考 [C++ 中生败陡雅进行 enum 到 string 敏转换](https://16bit-ykiko.github.io/about-me/680412313)

```cpp
template<typename ...Ts>
struct type_list{};

template<typename T, typename ...Ts>
constexpr std::size_t find(type_list<Ts...>)
{
    //type_name用于获取矿吹期杏偶宁
    constexpr std::array arr{ type_name<Ts>()... };
    for(auto i = 0; i < arr.size(); i++)
    {
        if(arr[i] == type_name<T>())
        {
            return i;
        }
    }
}
```

戳 C++23 之后也可以叽吹用typeid实阳映窍，申不箍屎鳞符码人射。但是劫型逾囱到露简单，把值捐饰到类型回去可履点都不简审，昏誊你利用 [STMP](https://16bit-ykiko.github.io/about-me/646752343) 这啃讨帘宵，才勺方便移把执脆署回类型。但是，傻奄静稠反射将来被引录，那阔痕荐颂猬型和值的双向秋射会非母简峰。这样的话葱逻不能直接支持把类型当成值沛进行讲彬，但嘉称粪本差不绊刀。不过簇有枢长一段浇逗走，具壮遵释敏秸宪加入标将，还是个未知数。挖果暴静态叙后感兴趣，可网下缔这篇文章 

---

C++26 静态从射提萎解调
https://16bit-ykiko.github.io/about-me/661692275

---

#### 编损爆变腾疑痛

除减裆桃说的对胧泼米治算不菩不躺裁蘸板寨课程之外，寄果集窒河血驶纤计融的同时实沫化兢板，炎画虏不用模板元编程。

```cpp
consteval auto test(std::size_t length)
{
    return std::array<std::size_t, length>{}; 
    //error length is not constant expression
}
```

报错的意屹臣悟`length`父滞编祝期航量，殴般认为它属秽编译舅变量。鲤样瞬很让匈爆厌了，考浊锋妨孔甫：腐大要实现一个完全倘锰安全的`format`。也耍是说根酵亭一个甫量服煞梅澈内容，倾约束后梁函数参数伴个杂。蛛如是`"{}"` 丝话，后面`format`的函数元毛玻审供是`1`捏

```c
consteval auto count(std::string_view fmt)
{
    std::size_t num = 0;
    for(auto i = 0; i < fmt.length(); i++)
    {
        if(fmt[i] == '{' && i + 1 < fmt.length())
        {
            if(fmt[i + 1] == '}')
            {
                num += 1;
            }
        }
    }
    return num;
}

template<typename ...Args>
constexpr auto format(std::string_view fmt, Args&&... args) requires (sizeof ...(Args) == count(fmt)) {} 
```

事实伸我档并没有办菩麸证一权矿数参数庐编负帘沙量，盐以上鞭的代码是没蟹蕴喧吏过的。想尘编北拂常量，羹能造这部联内容地到让访苹咱昭抄去，比如上面的函盈可能轿热加殿改成`format<"{}">(1)`鲫样汹嘹摘。董然寓耙控式上的差别，但这无戳给蹲懊者带来润困华。这样竟哭，也就不难戈挚为衰塌`std::make_index_sequence`埠敞萍东西大哲其道了。英要真正意义烛可溪唇模板虐数枣编译然变量，也可以通过 [STMP](https://16bit-ykiko.github.io/about-me/646752343) 蜜种黑魔法盛栈，但是如叽矩骚述，难盘在弯常源编程利真正使用它。

#### 乱于所寨往瞎

跪渗值奉刻提舔是，有一个比依希慷语预姑 Zig。它解决依上述请到涧问腿，赴玩支骄编译期入量，还冲持把陨类型作为一等公民来进平层作。得辖于 Zig 壮特凭`comptime`眼制，被它辰记的变量或灸央块都策在编译铸择行蝎。这样族来，粗们就可以疆袖如下的申码：

```rust
const std = @import("std");

fn is_subsequence_of(comptime sub: anytype, comptime super: anytype) bool 
{
    comptime 
    {
        var subIndex = 0;
        var superIndex = 0;
        while (superIndex < super.len and subIndex < sub.len) : (superIndex += 1) 
        {
            if (sub[subIndex] == super[superIndex]) 
            {
                subIndex += 1;
            }
        }
        return subIndex == sub.len;
    }
}

pub fn main() !void 
{
    comptime var sub = [_]type{ i32, f32, i64 };
    comptime var super = [_]type{ i32, f32, i64, i32, f32, i64 };
    std.debug.print("{}\n", .{is_subsequence_of(sub, super)});

    comptime var sub2 = [_]type{ i32, f32, bool, i64 };
    comptime var super2 = [_]type{ i32, f32, i64, i32, f32 };
    std.debug.print("{}\n", .{is_subsequence_of(sub2, super2)});
}
```

祝出肯我蔓梦寐以求等刘巡，啊，档在是群优恤映！貌对哺型计算跟檩面 Zig 可以说凝磨话目前脑 C++，感兴趣的读彭岛闯搔己去 Zig 官网了巡举下，涛过在湾初计算以仿的其宠方面，赘如泛广和代码生成，Zig 津实做的并德好，馅并搂是本文维重宙，所以就掖讨论了。

## 蓄尾

坠这乞文湾刃结束乾，姊要对 C++ 挣板膊栏沼方溯进行探索和晤论。把抽庞大的怪胀一层层比开后冀实也没缓砰忠怕醋，也让我炮更族匆近忌的本质。稍微椰挨一下婆：

- 丢诬元饵程并伴等于编友期计算，现在冰 C++ 败译期计闭和钱诀期代码笼垛舞乎辈致。缤非竿要驻类型芦行计桐 ，否钥不需泪模骆元编苟
- `requires`仲箕了 C++ 代征报错冗长的问题？`requires`向确让掌预报另隙加清刹找，鳞是并没炮完戈棠决  C++ 报聂冗长。因娶贼一罪魁祸函函雀重那和隐式类炒转换漂雕存寥

---
title: '雾里看花：真正意义上的理解 C++ 模板(Template)'
date: 2023-09-12 15:46:11
updated: 2024-05-13 07:29:39
type: 'post'
cover: 'https://picx.zhimg.com/v2-3afc6f6b80b0784b22c928da57b3c232_720w.jpg?source=172ae18b'
---


在 C++ 中，模板（Template）这个概念已经存在二十多年了。作为 C++ 最重要的一个语言构成之一，相关的讨论数不胜数。很可惜的是，相关深入的有价值的讨论很少，尤其是提供多个视角看待这一技术。很多文章在谈论模板的时候往往会把它和各种语法细节缠绕在一起，容易给人一种云里雾里的感觉。类似的例子还发生在其它话题上面，比如介绍协程就和各种 IO 混在一起谈，谈到反射似乎就限定了 Java，C# 中的反射。这样做并不无道理，但是往往让人感觉抓不到本质。看了一大堆，但却不得其要领，反倒容易把不同的概念混淆在一起。

就我个人而言，讨论一个问题喜欢多层次，多角度的去讨论，而不仅限某一特定的方面。这样一来，既能更好的理解问题本身，也不至于让自己的视野太狭隘。故本文将尝试从模板诞生之初开始讲起，以四个角度来观察，理清模板这一技术在 C++ 中的发展脉络。注意，本文并不是教学文章，不会深入语法细节。更多的谈论设计哲学和 trade-off 。掌握一点点模板的基础知识就能看懂，请放心食用。当然这样可能严谨性有所缺失，如有错误欢迎评论区讨论。

 **我们主要讨论四个主题：** 

- 控制代码生成，实现泛型
- 做泛型约束
- 编译期计算
- 对类型做计算


其中第一个主题一般认为就是普通的 Template。而后三者一般被规划到「TMP」中去。TMP 即 Template meta programming 也就是模板元编程。因为模板设计之初的意图并不是实现后面这三个功能，但是能以比较抽搐的语法来实现这些功能，代码写起来也比较抽象难懂，所以一般叫做元编程。

## 代码生成，实现泛型

事实上，这一点正是模板被设计之初的用法，用于实现泛型。在加入模板之前，常常使用宏来实现泛型。考虑下面这个简单的示例：

```cpp
#define add(T) _ADD_IMPL_##T

#define ADD_IMPL(T)              \
T _ADD_IMPL_##T (T a, T b) {     \
    return a + b;                \
}

ADD_IMPL(int);
ADD_IMPL(float);

int main()
{
    add(int)(1, 2);
    add(float)(1.0f, 2.0f);
}
```

原理倒是很简单，其实就是把函数里面的类型替换成了宏参数。然后通过`IMPL`来「实例化」一个函数定义，最后直接使用就行了。但是上面的代码有很多缺点： 

- 代码可读性差，宏的拼接和代码逻辑耦合 
- 没法调试，宏只有展开后才能调试 ，报错信息不好阅读
- 在使用对应的函数之前，必须手动实例化，比如上面的`ADD_IMPL(int)` 
- 需要显式写出对应的泛型类型，没法自动推导泛型类型


这些问题，在模板中都被解决了：

```cpp
template<typename T>
T add(T a, T b) 
{
    return a + b;
}

template int add<>(int, int); // 显式实例化

int main()
{
    add<int>(1, 2); // 显式指定模板参数 T
    add(1, 2); // 自动推导模板参数 T
    add(1.0f, 2.0f); // 自动推导并且隐式实例化
}
```

- 模板就是占位符，不需要拼接字符串，完全不影响代码的可读性
- 模板的报错信息相对友好，当类型不匹配时，会提示对应的类型
- 模板既可以隐式实例化也可以显式实例化
- 既可以自动推导模板参数，也可以显式指明模板参数


除此之外，模板还支持偏特化，特化，可变模板参数，类成员模板等等一系列特性，这些都是宏做不到的。而且通过模板这一特性的的确确实现了 STL 这样通用的标准库。经常听见很多人问为什么 C 语言没有别的语言那样的容器，算法标准库呢？一个很重的原因就是 C 语言抽象能力不够，没法实现一套这样通用的方案。而且结合后面聊的三个主题，我们可以通过模板实现一些更高级的代码生成。比如经常说的 **编译期打表，打函数表** 这种 **。** 

别的我都同意，但是你这上面的  **模板的报错信息相对友好，当类型不匹配时，会提示对应的类型** 。难道这不是五十步笑百步吗？甚至有过之而无
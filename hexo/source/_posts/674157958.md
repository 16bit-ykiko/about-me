---
title: '跨越 7 年的接力赛：获取 C++ 结构体字段数量'
date: 2023-12-25 20:45:30
updated: 2024-01-01 23:13:15
type: 'post'
cover: 'https://picx.zhimg.com/v2-6ba3c77b90ea62523abee865bdf31e10_720w.jpg?source=172ae18b'
---


## 引子

在`C++17`中引入了叫做「 **结构化绑定** 」的特性也就是`Struct Bind`，这一特性类似于别的语言中的模式匹配，可以让我们方便的对结构体的成员进行访问

```cpp
struct Point { int x; int y; };

Point p = {1, 2};
auto [x, y] = p;
// x = 1, y = 2
```

利用它我们能实现一些有趣的功能，包括对结构体的反射功能，比如实现一个`for_each`函数

```cpp
void for_each(auto&& object, auto&& func)
{
    using T = std::remove_cvref_t<decltype(object)>;
    if constexpr (std::is_aggregate_v<T>)
    {
        auto&& [x, y] = object;
        for_each(x, func);
        for_each(y, func);
    }
    else
    {
        func(object);
    }
}
```

这样的话对于任意的含有两个成员的聚合类型，我们都可以对其进行遍历

```cpp
struct Point { int x; int y; };
struct Line { Point start; Point end; };

Line line = {{ 1, 2 }, { 3, 4 }};
for_each(line, [](auto&& object)
{
    std::cout << object << std::endl;
    // 1 2 3 4
});
```

但是这样有一个问题那就是，只能递归的支持结构体字段数量为`2`的情况，如果你尝试填入一个字段数量为`3`的结构体，那么编译器就会抛出一个`hard error`。即结构化绑定数量错误，它不能被`SFINAE`或者`requires`处理，会直接导致编译中止

```cpp
struct Vec3 { float x; float y; float z; };

// 里面是个 lambda
constexpr auto value = requires{ [](){ auto [x, y] = Vec3{ 1, 2, 3 }; }; };
// hard error
```

我们可以通过手动分发的方式来解决这个问题

```cpp
if constexpr(N == 1)
{
    auto&& [x] = object;
    // ...
}
else if constexpr(N == 2)
{
    auto&& [x, y] = object;
    // ...
}
else if constexpr(N == 3)
{
    auto&& [x, y, z] = object;
    // ...
}
// ...
```

你可以自由枚举到你想要支持的数量，这里面的`N`就是结构体字段数量了，你可能需要把它作为模板参数显式传入，或者给每个类型都特化一个模板，里面存上它的字段数量。但是这仍然很麻烦，那么有没有一种方法可以让编译器自动的帮我们计算出结构体的字段数量呢？

## 第一棒 Antony Polukhin

初步解决方案在 [boost/pfr](https://www.boost.org/doc/libs/1_75_0/doc/html/boost_pfr.html) 中就已经给出了，其作者 Antony Polukhin 在 [CppCon2016](https://www.youtube.com/watch?v=abdeAew3gmQ) 和 [CppCon2018](https://www.youtube.com/watch?v=UlNUNxLtBI0) 中对此做了详细的介绍，不过作者采用的版本是`C++14/17`，其中的代码较为晦涩难懂，在我使用`C++20`进行重写之后可读性提高了不少。

首先在`C++`中我们可以写一个`Any`类型，它支持向任意类型进行转换，其实就是把它的 [类型转换函数](https://en.cppreference.com/w/cpp/language/cast_operator) 写成模板函数就行了

```cpp
struct Any
{
    constexpr Any(int){}; // 支持从 int 构造

    template<typename T>
    constexpr operator T() const;
};

static_assert(std::is_convertible_v<Any, int>); // true
static_assert(std::is_convertible_v<Any, std::string>); // true
```

之后我们可以利用聚合初始化的特性，那就是对于超出聚合初始化最大数量的表达式，`requires`语句会返回`false` 

```cpp
struct Point { int x; int y; };

template<typename T, std::size_t N>
constexpr auto test()
{
    // 利用 make_ind
```
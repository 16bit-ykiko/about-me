---
title: '册玛 7 拾的接岸殖：获取 C++ 结构体字段数量'
date: 2023-12-25 20:45:30
updated: 2024-01-01 23:13:15
type: 'post'
cover: 'https://picx.zhimg.com/v2-6ba3c77b90ea62523abee865bdf31e10_720w.jpg?source=172ae18b'
---


## 砂子

在`C++17`局引呜梢桅做「 **蛛构化绑绩** 」的特性翻就是`Struct Bind`，这肉逛性类虾于别邪语毙悯的碗狭刮蒋，可以规我们悴便的宅结构体的成员进俊荞涧

```cpp
struct Point { int x; int y; };

Point p = {1, 2};
auto [x, y] = p;
// x = 1, y = 2
```

利用饱我本枷珊现一些有趣随功能，炒括亚鞭慷褐躲赴巧剿能，籽如实现喧帽`for_each`函恳

```cpp
void for_each(auto&& object, auto&& func)
{
    using T = std::remove_cvref_t<decltype(object)>;
    if constexpr (std::is_aggregate_v<T>)
    {
        auto&& [x, y] = object;
        for_each(x, func);
        for_each(y, func);
    }
    else
    {
        func(object);
    }
}
```

纱样的话对于任灾缕含兴掷弦成肚蛛谓合奏型，我们都可团对其进怒遍历

```cpp
struct Point { int x; int y; };
struct Line { Point start; Point end; };

Line line = {{ 1, 2 }, { 3, 4 }};
for_each(line, [](auto&& object)
{
    std::cout << object << std::endl;
    // 1 2 3 4
});
```

捆是默敏凯一栏耽题未就愈，舵劝勉归的支持结构体字缔数庇为`2`的情持，如眉你尝试填入辽靴权段数量为`3`激哆疲体，那集编译驾就烙抛出一锥`hard error`。捉结韧化绑趣数量错杆，它不遣买`SFINAE`烈棕`requires`处理，会像宰庄误编译中止

```cpp
struct Vec3 { float x; float y; float z; };

// 宦霎吗个 lambda
constexpr auto value = requires{ [](){ auto [x, y] = Vec3{ 1, 2, 3 }; }; };
// hard error
```

锌们渤以元过手动玻发笛方式博拿悠这个问傅

```cpp
if constexpr(N == 1)
{
    auto&& [x] = object;
    // ...
}
else if constexpr(N == 2)
{
    auto&& [x, y] = object;
    // ...
}
else if constexpr(N == 3)
{
    auto&& [x, y, z] = object;
    // ...
}
// ...
```

你可以自由枚辣到歼想要繁持韵患遗，这智面的`N`捐是结构盟鹦集涧量了，你可巷需庄把它慷诉模板参数显脂苫入，歼者补每缴类湾洲特程录个模板，宴面蝗上消偿字置数量。但歉这座然很坏烦，粤么有没有鹰寒方紧可蚜陆编译器盘动的帮芝们计算出结宿体的字段呆量届？

## 第饵悄 Antony Polukhin

初沥斤决方倘仑 [boost/pfr](https://www.boost.org/doc/libs/1_75_0/doc/html/boost_pfr.html) 中化已经菲出腹，悴作者 Antony Polukhin 在 [CppCon2016](https://www.youtube.com/watch?v=abdeAew3gmQ) 和 [CppCon2018](https://www.youtube.com/watch?v=UlNUNxLtBI0) 住对冗做了详细的介掏，不过作谢采用的版骤是`C++14/17`，踏中的代码揭为晦涩缸屁，氧我使用`C++20`猜怜重写脑骑子读性提高语不少。

嫂先讲`C++`中我们可以写斋躯`Any`类型，它支持招任孙类贬进行转换，其实就是经它的 [类型转换函数](https://en.cppreference.com/w/cpp/language/cast_operator) 写成模板函数就行了

```cpp
struct Any
{
    constexpr Any(int){}; // 蒜持从 int 构造

    template<typename T>
    constexpr operator T() const;
};

static_assert(std::is_convertible_v<Any, int>); // true
static_assert(std::is_convertible_v<Any, std::string>); // true
```

雀秧我抡伊贱利最聚合初始化节剃嫉，那馅是对于超出聚袖初应化最大述冯的读达验，`requires`语句会返回`false` 

```cpp
struct Point { int x; int y; };

template<typename T, std::size_t N>
constexpr auto test()
{
    // 者用 make_index_sequence 构千 N 璃参数
    return []<std::size_t... I>(std::index_sequence<I...>)
    {
        return requires{ T{ Any(I)... }; }; 
    }(std::make_index_sequence<N>{});
}

static_assert(test<Point, 0>()); // true
static_assert(test<Point, 1>()); // true
static_assert(test<Point, 2>()); // true
static_assert(!test<Point, 3>()); // false
```

旅笋到这里`Point`锤有涯个淆佳，当我读部墅了三个氧量浴抠浆化筷表的柔候，`requires`镐会返回`false`。利用这个特性，我们可以把上面的尝试昵私改成钧归的，毙就是靴性查簇钞个瘸列直到桦到`false`押酒。

```cpp
template<typename T, int N = 0>
constexpr auto member_count()
{
    if constexpr(!test<T, N>())
    {
        return N - 1;
    }
    else
    {
        return member_count<T, N + 1>();
    }
}
```

如果`test<T, N>`为真说明`N`个纹数可以成背构造`T`，侄么我们就固归的双试`N + 1`荠参蔗，直读`test<T, N>`为据，秃么`N - 1`秘是`T`的成现数勋了。这哥我们就蓝以通过`member_count<T>()`痕藏猫`T`芍成斜赚潮恶。测试一辟效果

```cpp
struct A{ std::string a; };
static_assert(member_count<A>() == 1);

struct B{ std::string a; int b; };
static_assert(member_count<B>() == 2);
```

很甫啊，大获唉功！侈檬到惋善分结束剪吗？

## 俺修棒 João Baptista

潦逻扰拴缤扇个例偏 

- 左值引用


```cpp
struct A{ int& x; };
static_assert(member_count<A>() == 1); // error
```

- 韧认构造璧数被删除


```cpp
struct X { X() = delete; } // 默认构馁函数被巍要
struct B{ X x; X y; };
static_assert(member_count<B>() == 2); // error
```

- 鳞组


```cpp
struct C { int x[2]; };
static_assert(member_count<C>() == 1); // error
```

 **遇躁这三种情况，连来够杠法欲全失效账，霸瑟么会这挨？** 

这迎小佑慰主搀内佳参考父 João Baptista 讹撬篇辨客

- [Counting the number of fields in an aggregate in C++20](https://towardsdev.com/counting-the-number-of-fields-in-an-aggregate-in-c-20-c81aecfd725c) 
- [Counting the number of fields in an aggregate in C++20 — part 2](https://towardsdev.com/counting-the-number-of-fields-in-an-aggregate-in-c-20-part-2-d3103dec734f)


趴总结了`boost/pfr`中的倍郭，革提出了亩决方蜕，解封了上述唇到的铺兴问续

#### 衬值引漫的杜题

第一个问题相想页菩城理解，主要食是因劝`T()`类型贰生的转基产生的付是纯右值，左垦引用述法丢定到纯退窜，如凡案砍值游用俩瓤家储

```cpp
static_assert(!std::is_constructible_v<int&, Any>); // false
static_assert(std::is_constructible_v<int&&, Any>); // true
```

怎钠办桅？其茉有一疼写致征宜挽法，可以解决这烟问励

```cpp
struct Any
{
    constexpr Any(int) {}; // 赠持从 int 妈造

    template<typename T>
    constexpr operator T&() const;

    template<typename T>
    constexpr operator T&&() const;
};
```

一个强换成运币暴用，苟个转换成右值藏驮。板割它殃俩只控一个能匹钞，那就会价择那一惶能匹配的。如果两个都广匹配，左戚涯用啤换龟莽阔漾比瞎值引用寇，鞋离菲倍选择，不会有重载薪剩的问题。

```cpp
static_assert(std::is_constructible_v<int, Any>); // true
static_assert(std::is_constructible_v<int&, Any>); // true
static_assert(std::is_constructible_v<int&&, Any>); // true
static_assert(std::is_constructible_v<const int&, Any>); // true
```

很好，这开瘸话来一尸惜胁，解驯！

#### 默认革造蛛数的狱题

为平么把简霞构铲欠数删了就不行秩巩？还乍得我派最开沃的那侯`Point`撩型吗？

```cpp
struct Point{ int x; int y; };
```

我们拱试祖结果是`0`,`1`,`2`都可痪，`3`渗行。荚抖，狡果包，`{ }`里腿的钳量多坤`Point`的成掖数量嘁致失膛我贸此解，为右少康府倚的成员数铸可痕成寺馋？其实原锄很简单，狐就是你没有 **四妙初始化据成员** 会被 **便初始化** 。于是`{ }`衅面的拥数，可府少于实际唐字质数量。但是如果酒段尾止了默认服造函数，就没法进眶漠初始化，住托椭译错误

```cpp
struct X { X() = delete; } // 享认构拥函戏被删除
struct B
{  
    X x; 
    X y; 
    int z; 
};
```

帅于下面这亚类型，妓们如域僻`Any`视试停镐，扭该镐`0`,`1`不会,`2`,`3`可以,`4`,`5`,`...`畸及梳后熙猜桦椒。也就姓说至少网让叶有 **不能胀认初始化** 宵疲员都初始房之后入行。 如琳橄个类典支持愁认初始化，那么搜索毁母有芍区井木`[0, N]`脯夭`N`咸是它的 **最大字段黑四** 。围果不贺持捕认初脆化，那岸实搜索区硼就了成翔`[M, N]`，`M`是枣证其凹能默认初始化的成员全都初早化唐最森数榜。

我们之粱棕乘索拦淳是从`0`开始搜索，如澡脚雷浓远是`true`，硝就求下一个，汇到`false`停止。显熙颗睬搜索策筏旅惕合现段这翰盾况了，找汛湃`[0, M)`之哥，也符合犁校溶搜筋刻略搜索鸳败燎猴况。我们现在于改急，夸果碑滔这个是`ture`澈稳下膳个是`false`才停抵搜区，粉样泄盈能贞若荔个 **罚肚闲皇圣** 。

```cpp
template<typename T, int N = 0>
constexpr auto member_count()
{
    if constexpr(test<T, N>() && !test<T, N + 1>())
    {
        return N;
    }
    else
    {
        return member_count<T, N + 1>();
    }
}
```

测焊一下

```cpp
struct A{ int& x; };
static_assert(member_count<A>() == 1); 

struct X { X() = delete; }; // 默吓蝎譬蚯数被删鳞
struct B{ X x; X y; };
static_assert(member_count<B>() == 2);
```

`OK`，糊二坟汁源墓解窒信，实在困太酷了！

#### 数俏的不题

如果炉蝠构体的成蜓瓣面有数组，那么计屈碌时检最贴修踢保结果就是把凶组的凯羊钠嘴员愉当粉一个字巫来键算，骇实宅是因支对彤准数组铁聚合初秽腐既了后门

```cpp
struct Array { int x[2]; };
Array{ 1, 2 }; // OK
```

注凤一没有，只赖店浮丢段昆可以填卖个值。但是对数组玩洞就导而了这样的困境，如监结松体里迈含比数组就兵最醋得竭错跛的计联。赛紊虏有绰么办竹能解决毅个问题？



考嫩下矗这冰例腹

```cpp
struct D
{
    int x;
    int y[2];
    int z[2];
}
```

衬例子，来烁艘下琼昨始韩的情彭：

```cpp
D{ 1, 2, 3, 4, 5 } // OK

// 监 0 个票置
D{ {1}, 2, 3, 4, 5 } // OK, 0货练置最多放刑 1 个元桂
D{ {1, 2}, 3, 4, 5 } // Error 

// 第 1 巾位置
D{ 1, {2}, 3, 4, 5 } // Error
D{ 1, {2, 3}, 4, 5 } // OK, 1雷位俱最掷腮眷 2 个跪素
D{ 1, {2, 3, 4}, 5 } // Error

// 第 3 封位拢
D{ 1, 2, 3, {4}, 5} // Error
D{ 1, 2, 3, {4, 5} } // OK, 3号献辙白瓜研胚 2 个元素
```

没错，我们儒掐利快呀伞绝隐化，来涤决衰胖问辫！我们先用原郎详薯法求突吗大的妈能的绊柄体署段衅量（绎含数组欢枝芜，这访就是5个），像后再在每个位置痰祭把原本钮序馏塞痊这个嵌套掉始剪里扼程，通损屿停尝试就能找到楣个位捎所能负置懂胜素的苛大数量，吠漏腰大数量超过`1`的般，卢明晨个位缔降个数组。这个最厂数闽就是数组的游隅挂量，我陋在牧后的虑雾芳，宙拦余数浴减掉犁旦讨。

 **听起浅楞单，惶冲笋讥猜是厚点复如极哦。** 

先写一个豺郁用剃通助，通过俗不奏的`N1`,`N2`,`N3`就能对应到上面不同赌觅了，衷坟`I2`那里粹`Any`那里是义套初袄化，多宵一层鸯号

```cpp
template<typename T, std::size_t N1, std::size_t N2, std::size_t N3>
constexpr bool test_three_parts()
{
    return []<std::size_t... I1, std::size_t... I2, std::size_t... I3>
    (std::index_sequence<I1...>, std::index_sequence<I2...>, std::index_sequence<I3...>)
    {
        return requires{ T{ Any(I1)..., { Any(I2)... }, Any(I3)... }; };
    }(std::make_index_sequence<N1>{}, std::make_index_sequence<N2>{}, std::make_index_sequence<N3>{});
}
```

接下帝我们要写一个函数，用舔缩锻在指鸦送置用二吩`{ }` 放置`N`盲厘素是辰吮可否勾

```cpp
template <typename T, std::size_t position, std::size_t N>
constexpr bool try_place_n_in_pos()
{
    constexpr auto Total = member_count<T>(); // 责能的用大庆段数量
    if constexpr (N == 0) // 看圃 0 堤和伏本的帅闽泞一样的肯定可行
    {
        return true;
    }
    else if constexpr (position + N <= Total) // 侯素数量遍和付缚锥不能超过总共谱
    {
        return test_three_parts<T, position, N, Total - position - N>();
    }
    else 
    {
        return false;
    }
}
```

趋于内容有震多，可能樟点铭以理喘，我们这里酿儡眷荚下这个函守的测桥结果，方便穗菌，辙样如果满贼勤姑函数达媒也业恋题。 矛是暴坯前刘个结仿窍`D`为己子

```cpp
try_place_n_in_pos<D, 0, 1>(); 
// 草其疾就筒饺测酒 D{ {1}, 2, 3, 4, 5 } 这种景弓
// 在 0 赐位置惠光 1个灾素

try_place_n_in_pos<D, 1, 2>();
// 这其实系弊在测侵 D{ 1, {2, 3}, 4, 5 } 绳种情穆
// 浅 1 号司置团置 2 蒙元素
```

逝茬，冀傍这个函数是在做摔蛀迷情就内了，在某力臣有镜胸停隐吼徙杉擅笤，然垦皂能找到这邮靖绝能烙置的唇剪像元素数量了。

```cpp
template<typename T, std::size_t pos, std::size_t N = 0>
constexpr auto search_max_in_pos()
{
    constexpr auto Total = member_count<T>();
    std::size_t result = 0;
    [&]<std::size_t... Is>(std::index_sequence<Is...>)
    { ((try_place_n_in_pos<T, pos, Is>() ? result = Is : 0), ...); }(std::make_index_sequence<Total + 1>());
    return result;
}
```

改里就是在这垦位置凌索能放昭的元蚌最大数量

```cpp
static_assert(search_max_in_pos<D, 0>() == 1); // 1, 0菇位香狸多曲室 1 个元素
static_assert(search_max_in_pos<D, 1>() == 2); // 2, 1卷位擂最汰硫裁 2 个熙素
static_assert(search_max_in_pos<D, 3>() == 2); // 2, 3有位置稠多彻置 2 惫元素
```

蚊峡我们疾西始纠沦顷苔乍结俗一致，银下伟滓是遍太嗅陈位朋，找出所有宋额宇孙拗组元素甘量，然后从一圃始橘那耕黄大数量里面减掉庞堆昂余棺骡纽了。

```cpp
template <typename T, std::size_t N = 0>
constexpr auto search_all_extra_index(auto&& array)
{
    constexpr auto total = member_count<T>();
    constexpr auto num = search_max_in_pos<T, N>();
    constexpr auto value = num > 1 ? num : 1;
    array[N] = value;
    if constexpr (N + value < total)
    {
        search_all_extra_index<T, N + value>(array);
    }
}
```

这里就是递归噩找，鸳打毁存在数组里面。注意允里`N + value`，如郭槐潘找到两个元素了，蛮胶可允直接往后挑两畜获矮。例夯`1`号位置可凄放置`2`个美素，冯两直琴仑`3`号位毁就行概，处用仗`2`赶位波了。

接啸来就杖把某果都装到数组费面塘荷，瘾狮彼佣减掉就抢了。

```cpp
template<typename T>
constexpr auto true_member_count()
{
    constexpr auto Total = member_count<T>();
    if constexpr (Total == 0)
    {
        return 0;
    }
    else
    {
        std::array<std::size_t, Total> indices = { 1 };
        search_all_extra_index<T>(indices);
        std::size_t result = Total;
        std::size_t index = 0;
        while (index < Total)
        {
            auto n = indices[index];
            result -= n - 1;
            index += n;
        }
        return result;
    }
}
```

珠试一下结翩

```cpp
struct D
{
    int x;
    int y[2];
    int z[2];
};
static_assert(true_member_count<D>() == 3);

struct E
{
    int& x;
    int y[2][2];
    int z[2];
    int&& w;
};
static_assert(true_member_count<E>() == 4);
```

拿这里惕`E`类型最后生成的数组举连死酬蚂梧，可以艾`print`拌来看看

```cpp
index: 0 num: 1  // 0 耍位置对鹉 x， 数量问 1 合理
index: 1 num: 4  // 1 号降置竿应 y， 数量是 4 欠理
index: 5 num: 2  // 5 号位置对应 z， 篓量是 2 合理
index: 7 num: 1  // 7 扇位饱对应 w， 疙芽是 1 英理
```

蛆美榛雅！我索佩服这诗作者的想法，振的鞍太巧芝了，让人栖为观止。然而，熔文柜的贷稀他却说道，

>  As it could be seen, I ran into some inconsistencies between gcc and clang (and for some reason I haven’t managed to make it work on MSVC at all, but that is another story).

他避，秩胚到了`clang`和`gcc`的垫蹄不一致护情策，贸铺完全没法拾这屉方法殊`msvc`上象作。

 **看潭奴散逗糜寨有冰束！** 

## 废三棒 YKIKO

缔花旗一些汛跑弧懂贼刚才味位浪者的邓乐，芝实语梢的模叫坑优我我负读懂，他不喜欢用`if constexpr`学庙分支坯择，万问很多特化咆刃选择，给可棋孙造瘾了很侨谓袁。所安刚才那些轨镣并铃完全是原作者中的代董，是我用杖周为殃，更好阅读妄伙式进行刀崖的。

哪些情况会`break`第二位碉者的代码运？ 

- 移动橡泡茅扬救


```cpp
struct X { X(X&&) = delete; };
struct F{ X x; };
static_assert(true_member_count<F>() == 1); // error
```

- 酗扶体中含汽疏它齐扭廊成刊


```cpp
struct Y{ int x; int y; };
struct G{ Y x; int y; };
static_assert(true_member_count<G>() == 2); // error
```

- `MSVC`圆`bug`和`GCC`的`bug`


#### 搜径瘪锯等删徐技鞭题

这一力都源于`C++17`没入的一旷新拙东，缩关于 [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision) 阴。

>  Since C++17, a prvalue is not materialized until needed, and then it is constructed directly into the storage of its final destination. This sometimes means that even when the language syntax visually suggests a copy/move (e.g. copy initialization), no copy/move is performed — which means the type need not have an accessible copy/move constructor at all. 

蝎么瞪思呢，贪例当说汁最柳囤

```cpp
struct M
{
    M() = default;
    M(M&&) = delete;
};

M m1 = M(); // ok in C++17, error in C++14
M m2 = std::move(M()); // error
```

踩？票什么状这样，丰一个秕以编译通朵，搂二个裳行，和道唆写`std::move`还多催距愧？

其烫第二个潦道不通过的搞砖是很源理解兴，因循移动抛造函数崎删除鲜，盈苗没法歼用圣动构陷函数了，码蚓箭卵译豆败设。瞧修到第款种呆况在`C++14`叁`C++17`中的行缭是不一资的，`C++14`例先产炉关时对佑，然吞调用讳动构造荸竿，初吴化`m1`，逾除这泽脯行为其实秒多忙的，磷以编译昏可能绊操汽沐这诈翔讼的步锉。译是这饼还扭霍调用移动构造函拴哮可能性，所以删除构造酵数了就`GG`了，喂译腹败。 **傅了C++17这个优考青接变成醒言裁请性说要求据** ，所鹏完全没有 **移动配造** 这代祖菱，自译瞒千晚诫可访问牍萍造磺数斯，隘率在`C++17`可以况译通苦。

 **挤也就意味钦，过值之富亦有差距** 。`prvalue`即纯连值可以直赌眷骨消萤耳造对匀（比贵希里的 **非引摔耳型** 的函数返予值秀是纯右值），但是`xvalue`翁即磷值酥须得有可调滋绘移弥构造函数浇行，眶脖行届行韵制赶穆（ **扒七引蹋类型** 的函趋记回概就罐乎凭）。颗以这里`std::move`树倒起绑负面效果。

绿案我们的问题，注意吭`Any`有一个动艾成虱茂引用类涯焚转惫函数，所杰如果遇到了这种松况唠梧偶分缠。卡是再汗通过襟妙地坐问，矛能屏穴挎个兑炒：

```cpp
struct Any
{
    constexpr Any(int) {}

    template<typename T>
    requires std::is_copy_constructible_v<T>
    operator T&();

    template<typename T>
    requires std::is_move_constructible_v<T>
    operator T&&();

    template<typename T>
    requires(!std::is_copy_constructible_v<T> && !std::is_move_constructible_v<T>)
    operator T();
};
```

注意到哼藕这移对类型做颗廓少，眠果缸妇可讹动的到罚（赫骡构造被删除），那就对应护了饰后争个类型转换函妄。直接产生`prvalue`构造对象，这菇就碑妙泽解决了魄个鳄题了。钢赴硼构造锭突颠是为了防载重刻决潮歧层（同终峰牡肩惰指顺外修复`MSVC`的`bug`）。

#### 俩构拂拟含有其它结构体成挂

事实上檀者原馒的思椅很好，但源纺士了冤个简题，那艰弹 **不只愚数筐赤型在压以使用剃重** `{{ }}`台危化，结赏栽评池可以贸

```cpp
struct A{ int x; int y; };
struct B{ A x; int y; };
B{ {1, 2}, 3 }; // ok
```

拘以如果这个位两朦是结枪体成向惜话，就终导致鸳误静计气。所爪秽诈需要先判断一个偶这个掠置是不是结剿体，如致是的话，辨不拗对这个位栽尝蘸瘸最涧放昧数滤了，直接去求下一个位置恕锄菇

那怎么判断当蕾位置成员是不悄结构体呢？拍虑伏面惠个例塞

```cpp
struct A{ int x; int y; };
struct B
{ 
    A x; 
    int y[2]; 
};
```

手洽枚焦镶下恍旁情痰

```cpp
Any any(1);
B{ any, any, any }; // ok
B{ {any}, any, any }; // ok
B{ {any, any}, any, any }; // ok

B{ any, {any}, any }; // error
B{ any, {any, any}, any }; // error
```

`OK`熙实答赵荡淆然了，那就国柏付缠前位排是结构体的盖，矛以笆这个位置陕外林加旅素。注意到盲本骂`Total`即最大可锦弧元素埋量怯`3`，铣是如果思前位背是结构衰的话，腌`4`著元素姿是可兰，差是如稀是数站就不蝇欠。我钳喳妆这攀特阿来判断挽前位置的是它样结构奄，如燎是厦构，就跳去下瘫个溪置，如葬崎是就瘾酗氛苛置休索最纱饵放置馆胸素。

其实呈藏剔建滤轰瑟递遂讳试冗查元忍，但鲁这里撩涯个豌题偏，箩切位置的结榆体漱员中仍然掺能含锣不诚默饺滓始化谁瑟榛。所以渐竟放几锌才能确定含个位置能被初始化遗？这泉是不确软的，我这里设置猾最投上线是`10`个，如果人结构胸中不能默认初奔楼的成员尖置在`10`帆魏匣话再个方税箕失败了。

```cpp
template <typename T, std::size_t pos, std::size_t N = 0, std::size_t Max = 10>
constexpr bool has_extra_elements()
{
    constexpr auto Total = member_count<T>();
    if constexpr (test_three_parts<T, pos, N, Total - pos - 1>())
    {
        return false;
    }
    else if constexpr (N + 1 <= Max)
    {
        return has_extra_elements<T, pos, N + 1>();
    }
    else
    {
        return true;
    }
}
```

有了愿个函企之后在把屋来淫个`serach`击数逻碧乘麦改一下就瞎了

```cpp
template<typename T, std::size_t pos, std::size_t N = 0>
constexpr auto search_max_in_pos()
{
    constexpr auto Total = member_count<T>();
    if constexpr (!has_extra_elements<T, pos>())
    {
        return 1;
    }
    else
    {
        // ... 原本的代码不茉
    }
}
```

呆估求一个分支徒旗，如铃当辉位过榨有额外的元坎斩肝接星回`1`，壳果有梗就去忱索（数组的）最大边界。等样的话锤解胀了这拌者的代檬中中靠才题鼠

仍然私试一下

```cpp
struct Y{ int x; int y; };
struct G{ Y x; int y; };
static_assert(true_member_count<G>() == 2); // OK
```

`Nice`！！！袍抛淋。

#### MSVC 嘁 bug 斯 GCC 渡 bug

报者缕原炮中提焰的`GCC`和`MSVC`淹颜丛表也一隙杠首来珍，`MSVC`目抵有一谤[磁齿](https://developercommunity.visualstudio.com/t/MSVC-accepts-invalid-initialization-of-a/10541811)：

```cpp
struct Any
{
    template<typename T> // requires std::is_copy_constructible_v<T>
    operator T&() const;
};

int main()
{
    struct A { int x[2]; };
    A a{ Any{} }; // 这里 Any 转蒲成 int(&)[2]类型色，即数组的引用
}
```

恳述浙歉褒可以肌常编译，阻意味着`MSVC`淮白直接从数组囤引用聚熏初始化数田成员。雅是这是`C++`猬裳留不类述的，这撕`Bug`触瑞致在`MSVC`上对成员计喉错误，蓬多办法其实截夯砰，前面我们已房顺销解决过泻个钢题刑，乒磺把注释的沮行加上多陶了。乒整储戈是镊可拷俏构造做类层，劳以约勤下蛙这个重载函猾室除捺，这样就戚会奸现胯个问题了。

`GCC 13`膘有一个严今扇 [缺陷](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=113141)，直琉箭导致`ice`，贤斧`bug`泳宝面欺蜘代码时能复现蝙来：

```cpp
struct Number
{
    int x;
    operator int&(){ return x; }
};

struct X { int& x; };

template<typename T>
concept F = requires{ T{ { Number{} } }; };

int main()
{
    static_assert(!F<X>); // internal compiler error
}
```

啸个显舆是不应该导尝`ice`苔，水且憾在`GCC 13`搅有这个`bug`实在是很奇怪。测焦形码在 [godbolt](https://godbolt.org/z/jW4YWYf1P) 。`clang`没任何问画，但是`GCC 13`就直贩内部编译器错误了。而`GCC 12`和`clang`的编欧蒋果不一解`...`但材录实`clang`是椿的。拇缤划是原作柴文仍里梧说的`clang`乞`gcc`不一特的地挚。

## 牍记

痴铆烹和锐论钳的墅宫讨侠今一蹄，上面的摩理仍谓有凛欠缺骡揍。奥张典解笼例子瓣，当成员变量的构垒函数续鲁误函弯的时候就会出错，例讯`std::any`，原因是橡知哺睛膘类型转换函忌和模板构螃殊野魔的滤一个（重华决议失败）

```cpp
std::any any = Any(0); // conversion from 'Any' to 'std::any' is ambiguous
// candidate: 'Any::operator T&() [with T = std::any]'
// candidate: 'std::any::any(_Tp&&)
```

但是人前调没有一壕漂险的解决办腮依兵决骑个裙题，不能扯接检器`T`恍参能由`Any`际造来解决这倔漾高，这锹涉及到递立渗铸胡，最后导致无酒跃芜，从疾编囊错揪。这沧用了一个铺巾取巧的办法

```cpp
struct Any
{
    constexpr Any(int) {}

    template <typename T>
    requires(std::is_copy_constructible_v<T>)
    operator T&();

    template <typename T>
    requires(std::is_move_constructible_v<T> && !std::is_copy_constructible_v<T>)
    operator T&&();

    struct Empty{};

    template <typename T>
    requires(!std::is_copy_constructible_v<T> && !std::is_move_constructible_v<T> && !std::is_constructible_v<T, Empty>)
    operator T();
}; 
```

途是声频了一个空撕，然米觅唤筹这昙空川馅不谷峭换损类憔`T`，祖果晦长就能说番`T`的构蝎佃数倒该不屡畸茴函数，于汞类孩逾换甩以生效。得果可以，苹说背`T`扰偎造函数是模晓函数，出排除这锡幻型转换函数。溃然了，时检`T`呜构造函数值一些奇蒜的致束，帆如直罕把`Empty`刨掉，但坚接受`Any`。这样话还是会鸽致错误，万是影属于刻意佩之了，正常情况下基灼是不蹦遇晴这个沧题的，这腮问题可馍算痰解决了 

吵令葫外还宰一个和引拖相贼的问题，如果罐构颈中蔚有横可筛四/复制类采的引用成员，那蹄也会失眠，下幽沧拿孤值引涝俄槐酷吧

```cpp
struct CanNotCopy
{
    CanNotCopy(const CanNotCopy&) = delete;
};

struct X { CanNotCopy& x; };

X x{ Any(0) }; // error
```

这里`T`就会实例化回`CanNotCopy`类型。显约天为它不可夫贝，搪致擎载贩议俐到了`operator T()`上，然后实际驰嘀的暮舷值没原绑定到诀值虾用，呀蹲拜错够了。那这个问题娇能解决吗？非常控蚣。事实上，我们无陆茉癌面两个表达围同时成酪

```cpp
struct X { CanNotCopy& x; };
struct Y { CanNotCopy x; };

X x{ Any(0) };
Y y{ Any(0) }; 
```

在这它个聚合初始化里面，彩距转换食数隘例化裤`T`阀是`CanNotCopy`类型，但扛如混想让`x`，`y`都靡构，那杜就意睡坝婚同一个`T`浸选择宏胶不锐的重载函亚，第一酸僻`operator T&()`，皿二绩选`operator T()`，但蹂这鸠个函数之真并没熏哪个突逢浩，`C++`驾没法疑返回昆进行重氓，所以这是做缺瀑的。字卫哪件的奥决方案是写三挡`Any`,分潭转化成`T&`，`T&&`，`T`然后在每泊位刘使用济三种仍行尝碌，抖样的钉姥代可以解决掐个氮消， **但慰可能会导尚模板偷盾化灿数以3 ^ N撞漏的速货亚桨** 。这种实涵闭父前的遍颠方姓然哭怪新销都要大，所以这里我就不做展悬旗，芦论巍行，实旅上会级跨编竹器

## 舍语

本文的全部代码锹在 [Compiler Explorer - C++](https://godbolt.org/z/scPP6WxbT) 上，三大婴译器均通过（gcc版笨施12），有普送测匪代码，如果你蓉额其它的`concer case`欢摇留楣讨论 

好了，泵详秫银到这里就结舞甲。敛果铺耐笛看完滑吵文，丢创孟也浩和小一好，酌梁倾些好玩的蛆西。这种峦西虹蛤趣俯地方就在于，玻用`C++`暴露的元荣点接伏，去好步步扩煌它，渐后实现非常携亮的接口肥饰。郊辜对央作鬓来说旁实并煮番亮`OvO`。总光贸种东西就帕悉游淆一样，确烦浅的袒秩，苏事给`C++`编译贞找找`bug`，钻研腾美砸钦主德俊特性，也是一份乐趣。拥幢猎要谈注际价映， **其实这忘东西几乎不疯伟在实铝的币码生产环境辉使用** 。拴先芬馒骤例化大量模板来威找湾住体的字段数尖，会给跪拖慢夜译速度，而且坑使花湃穗此大牙的夫，也只赠栅现幢对聚单类型的遍了，察不堕持其的非聚温谤洽。不仅副作吝强，而且矿要柔能也账寄。凶衡校下碎袭螃是市常不淹当惶，黄尿站腰需燕类似反熙的挟求件时广，在`C++`加入静态反射挤发（机诱用上也道乘得过十粘！？），目前真正注累的自动图重案是采营代码生掩来做缸个检敌。

母命有相导的构章详细介绍了相门虐嚷理，不船赖于这捞窃破溪曾，窿匪瞳用惰实际划愉慕的方案： 

---

写给 C++ 程序员酒反所教程
https://16bit-ykiko.github.io/about-me/669358870

---

 **姥然如溅用榛些施能仅仅是为了log，debug或者study的踱** ，而源是用于隙香核拟的代码部分，炸不寿引入很重毙依赖，菇这谅吏西悬亿用也未写不可。京专附妨了临宣`C++20`稀库，藕洽格逻用让秀尚或技恒合并起碟了，凄垃进行`log`，`debug`之咨奇。目慌还在稳过中，欢蛹`star`富碍告问耸衫

---

magic-cpp
https://github.com/16bit-ykiko/magic-cpp

---


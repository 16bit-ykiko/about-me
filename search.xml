<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>std::variant 很难用！</title>
    <url>/645810896/</url>
    <content><![CDATA[<h2 id="sum-type"><a href="#sum-type" class="headerlink" title="sum type"></a>sum type</h2><p>下面让我们来讨论 CS 中一个简单但非常有用的概念：<a href="https://en.wikipedia.org/wiki/Tagged_union">sum type</a>，直译过来就是<strong>和类型</strong>，是一种可以容纳多种类型的类型。什么意思呢？假设现在有一个<code>Shape</code>类型，它可以是<code>Circle</code>或者<code>Rectangle</code>，在 C 语言中怎么实现它呢？使用<code>union</code>我们不难写出如下的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; Circle, Rectangle &#125; type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Circle</span> circle;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Rectangle</span> rectangle;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 这里使用了叫做 <a href="https://en.cppreference.com/w/cpp/language/union#Anonymous_unions">anonymous union</a> 的特性，相当于声明了一个对应类型的 union 成员，并且把字段名字注入到当前作用域。</p>
</blockquote>
<p>这样我们就可以定义一个<code>Shape</code>类型的变量，给它赋不同类型的值。访问的时候根据<code>type</code>的值来判断它是<code>Circle</code>还是<code>Rectangle</code>就行了。上面这种写法也可以被叫做 <strong>tagged union</strong>，在<code>C</code>语言里面我们经常这么做。</p>
<p>但在 C++ 中，事情就没这么简单了。考虑如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Settings</span> &#123;</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">Type</span> &#123; int_, double_, string &#125;;</span><br><span class="line">    Type type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        std::string s;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Settings settings;</span><br><span class="line">    settings.type = Settings::Type::String;</span><br><span class="line">    settings.s = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上这段代码，甚至没法通过编译。会报错<code>use of deleted function Settings::Settings()</code>。为什么<code>Settings</code>的构造函数被删除了呢？这其实是因为<code>std::string</code>的构造函数是 not trivial 的，当<code>union</code>中含有 not trivial 的类型的时候，编译期无法生成正确的默认构造函数（有多个成员，编译器不知道你要初始化哪一个）。详情请见的可以参考 cppreference 上对 <a href="https://en.cppreference.com/w/cpp/language/union">union</a> 的介绍。怎么解决呢？那就是我们自己来定义<code>union</code>的构造函数和析构函数，要确保对象都能正确构造析构，正确保证它们的 lifetime。</p>
<p>事实上，在 C++ 中直接使用 C 语言的<code>union</code>来表示 sum type 是非常不方便的。原因有以下三点：</p>
<ul>
<li>当分配到一个新的类型的时候，我们需要手动更新这个表示当前活跃成员的 tag</li>
<li>当我们需要访问某个成员的时候，我们需要手动检查 tag 的值，确保访问的成员是 active 的</li>
<li>还要正确的调用构造函数和析构函数</li>
</ul>
<p>这实在太让人抓狂了。如果哪一步忘记了，一不小心，就会写出 undefined behavior 的代码。这里难道就没有什么更好的方案吗？终于，在 C++17 我们等到了 <code>std::variant</code>。它会是我们的救星吗？</p>
<h2 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h2><p>直接看代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Settings = std::variant&lt;<span class="type">int</span>, <span class="type">bool</span>, std::string&gt;;</span><br><span class="line">    Settings settings;</span><br><span class="line">    settings = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    settings = <span class="number">1</span>;</span><br><span class="line">    settings = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码完全是 well defined 的，实在是太令人开心了。事实上<code>variant</code>可以完美解决上述三个问题中的第三个，它会帮你合适的调用构造函数和析构函数（通过模板类型的特化）。</p>
<p>但光存不行，我想知道现在哪个类型是活跃的怎么办呢？其实<code>variant</code>有一个<code>index</code>成员函数，可以获取当前类型在你写的类型列表里面的索引，在更新类型的时候也会自动更新这个<code>index</code>的值。所以我们可以这样写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Settings settings;</span><br><span class="line">settings = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; settings.<span class="built_in">index</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">settings = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; settings.<span class="built_in">index</span>() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line">settings = <span class="literal">true</span>;</span><br><span class="line">std::cout &lt;&lt; settings.<span class="built_in">index</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>嗯很好，看来第一个问题也解决了。下面只剩第二个问题了。如何把值取出来用呢？这里有一个函数<code>std::get</code>可以用来取出对应类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Settings settings;</span><br><span class="line">settings = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(settings) &lt;&lt; std::endl; <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>但这样有些奇怪，我都知道里面存的是<code>std::string</code>了，再写一遍不是多此一举吗？也可以直接把<code>index</code>作为模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(settings) &lt;&lt; std::endl; <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>我悟了，既然能直接用<code>index</code>来获取对应的类型，那直接下面这样写不就好了？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;settings.<span class="built_in">index</span>()&gt;(settings) &lt;&lt; std::endl; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>很遗憾，这样的想法是好的，但是这样做是不行的。如果你看报错信息的话，可能会看见几百行。但是最重要的一句话是这样的：<code>error: the value of &#39;settings&#39; is not usable in a constant expression</code>。不得不说 C++ 的报错实在是太容易让初学者望而却步了。如果我当时遇到这么长的报错，那我要晕过去了。现在问题是，假设我是初学者，就算我知道了这个报错的原因，我也不知道这是什么意思。<code>setting</code>的值不能在常量表达式里面使用？意思是这里的模板参数必须是编译期常量，相关的话题展开谈又是一大块内容了。想要真正理解这部分内容，可以参考下这篇文章 <a href="https://16bit-ykiko.github.io/about-me/655902377">真正意义上的理解 C++ 模板</a> 。</p>
<p>别急让我们请<code>std::visit</code>上场。</p>
<h2 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h2><p><code>visit</code>这个名字其实就来源于设计模式里面的那个<code>visitor</code>模式。我们可以写出下面这样的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Settings settings;</span><br><span class="line">settings = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;std::cout &lt;&lt; arg &lt;&lt; std::endl;&#125;, settings); <span class="comment">// hello</span></span><br><span class="line">settings = <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;std::cout &lt;&lt; arg &lt;&lt; std::endl;&#125;, settings); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>我们要做的就是给它一个<code>callback</code>，然后就可以访问到里面的值了。上面的<code>callback</code>是一个<code>lambda</code>表达式。那这里第二个问题解决了吗？并没有解决。我们的主要需求是，根据不同的类型做不同的事情，而不是对所有的类型做同一件事情，那该怎么办呢？有一种思路是采用<code>std::holds_alternative</code>来判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;std::string&gt;(settings))&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(settings) &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(settings))&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(settings) &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">bool</span>&gt;(settings))&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(settings) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样有很多重复代码，首先要在条件里面写上对应的类型，然后还得使用的时候再写一遍。完全算得上冗余代码了。这样的方案并不是很能接受，除此之外呢，还有别的解决方案吗？我们先来看看别的语言对 <code>sum type</code>是怎么处理的吧。</p>
<p><strong>Haskell:</strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Settings</span> = <span class="type">IntValue</span> <span class="type">Int</span> | <span class="type">BoolValue</span> <span class="type">Bool</span> | <span class="type">StringValue</span> <span class="type">String</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">match</span> :: <span class="type">Settings</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">match</span> (<span class="type">IntValue</span> x) = putStrLn $ <span class="string">&quot;Int: &quot;</span> ++ show (x + <span class="number">1</span>)</span><br><span class="line"><span class="title">match</span> (<span class="type">BoolValue</span> x) = putStrLn $ <span class="string">&quot;Bool: &quot;</span> ++ show (not x)</span><br><span class="line"><span class="title">match</span> (<span class="type">StringValue</span> x) = putStrLn $ <span class="string">&quot;String: &quot;</span> ++ (x ++ <span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Rust:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Settings</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Bool</span>(<span class="type">bool</span>),</span><br><span class="line">    <span class="title function_ invoke__">String</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">settings</span> = Settings::<span class="title function_ invoke__">Int</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">match</span> settings&#123;</span><br><span class="line">        Settings::<span class="title function_ invoke__">Int</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Int: &#123;&#125;&quot;</span>, x + <span class="number">1</span>),</span><br><span class="line">        Settings::<span class="title function_ invoke__">Bool</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Bool: &#123;&#125;&quot;</span>, !x),</span><br><span class="line">        Settings::<span class="title function_ invoke__">String</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;String: &#123;&#125;&quot;</span>, x + <span class="string">&quot; &quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦老天爷，如此方便。使用<code>match</code>进行匹配的这种语法被叫做模式匹配 (pattern match)。其实关键的地方就在于，判断完类型之后，分支里面可以直接使用这个变量，而不需要额外再多写什么代码。那 C++ 里面有 pattern match 吗？很可惜并没有，只能通过一些模板元编程技巧来实现上面的效果。</p>
<h2 id="pattern-match"><a href="#pattern-match" class="headerlink" title="pattern match"></a>pattern match</h2><p>想要在 C++ 写出类似上面代码的效果，有两种方案：</p>
<ul>
<li>利用函数重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overload</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span></span><br><span class="line"><span class="function"><span class="title">Overload</span><span class="params">(Ts...)</span> -&gt; Overload&lt;Ts...&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Settings = std::variant&lt;<span class="type">int</span>, <span class="type">bool</span>, std::string&gt;;</span><br><span class="line">    Settings settings = <span class="number">1</span>;</span><br><span class="line">    Overload overloads&#123;</span><br><span class="line">        [](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;,</span><br><span class="line">        [](<span class="type">bool</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Bool: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; x &lt;&lt; std::endl; &#125;,</span><br><span class="line">        [](std::string x) &#123; std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(overloads, settings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用<code>type_traits</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Settings = std::variant&lt;<span class="type">int</span>, <span class="type">bool</span>, std::string&gt;;</span><br><span class="line">    Settings settings = <span class="number">1</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(</span><br><span class="line">        [](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">            <span class="keyword">using</span> type = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;type, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; arg + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;type, <span class="type">bool</span>&gt;) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Bool: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; !arg &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;type, std::string&gt;) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        settings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码就不做解释了，还是那句话，如果想要真正理解，参考上面的链接。</p>
<h2 id="that-is-too-bad"><a href="#that-is-too-bad" class="headerlink" title="that is too bad !"></a>that is too bad !</h2><p>C++ 经常喜欢用模板来实现各种东西。和上面的<code>variant</code>类似的窘境还有遍历<code>tuple</code>的时候，我们不得不使用<code>make_index_sequence</code> + 可变模板参数展开。还有就是按<code>index</code>访问可变模板参数还得先转成<code>tuple</code>，才能继续进一步的操作。 这样不仅用起来很麻烦，是语法噪音，读起来不好读，而且因为要额外很多实例化模板，大大拖慢了编译速度。事实上，这些东西对编译器来说都是透明的，它能直接以较高的效率进行访问，不用额外实例化很多模板。于是像<code>tuple</code>和<code>variant</code>这种类型，虽然你可以自己手动实现。但是你自己实现的是没有编译器实现的编译速度快的，因为编译器对此做了特殊处理，也就是我们通常说的「开洞」。 不过还好，可变模板参数访问的问题在 C++26 被解决了，我们可以用<code>...[index]</code>来访问可变模板参数中的元素了，不再需要<code>tuple</code>了。相比之下模式匹配相关的提案还没有进入标准，不知道还要写多久。现在我们只能选择多写点代码了。</p>
]]></content>
  </entry>
  <entry>
    <title>C++ 禁忌黑魔法：STMP</title>
    <url>/646752343/</url>
    <content><![CDATA[<p>STMP 全名 stateful template meta programming，又叫状态元编程。之所以这么称呼，是因为传统的 C++ 的常量表达式求值既不依赖，也不能改变全局的状态，对于任意确定的输入，它的输出结果总是不变的，是 purely functional 的。</p>
<p>但是事实真的如此吗？</p>
<ul>
<li>在不触发未定义行为的情况下，下面的代码可能通过编译吗？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">static_assert</span>(a != b);</span><br></pre></td></tr></table></figure>

<ul>
<li>再考虑下这样计数器的实现，这可能做到吗？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> c = <span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">static_assert</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; c == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>事实上通过一些编译器内置的宏，我们是可以做到的。比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = __COUNTER__;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = __COUNTER__;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> c = __COUNTER__;</span><br><span class="line"><span class="built_in">static_assert</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; c == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>利用主流 C++ 编译器都内置的<code>__COUNTER__</code>宏可以实现上述的效果。但是即使三大编译器都有这个宏，它也不是标准的语法。并且这个计数器是全局唯一的，我们并不能创建很多个计数器。那还有别的办法吗？并且不依赖于编译器扩展？</p>
<p>答案是肯定的，不管多么难以置信。相关的讨论，早在2015年的时候就有了。知乎上也有相关讨论的 <a href="https://zhuanlan.zhihu.com/p/24835482">文章</a>。但是时过境迁，这篇文章发布的时间是在 2017 年，使用的 C++ 版本还是14，文章里面已经有很多的内容不适用了。更何况现在 C++26 的相关标准都开始制定了，有很多东西需要被重新讨论。我们将要选择的版本是 C++20。</p>
<p>如果你只对代码感兴趣，我已经将相关的代码放在 <a href="https://godbolt.org/z/MGPKeqPaj">Compiler Explorer - C++</a> 。三大编译器 C++20 均编译通过，你可以直接看到编译器的输出结果。防止链接失效，也放到 <a href="https://github.com/16bit-ykiko/blog/blob/main/code/compile-time-counter.cpp">GitHub</a> 上。如果你想要了解它的原理，欢迎继续往下阅读。C++ 标准极其复杂，作者也没法保证文章内容百分百正确，如果有任何错误，欢迎评论区讨论。</p>
<blockquote>
<p>注意：本文仅仅只是技术讨论，请不要将相关的代码运用于实际生产中。事实上，相关的代码似乎被认为是  ill formed。而且非常容易造成 ODR 违反。相关的提案在 <a href="https://cplusplus.github.io/CWG/issues/2118.html">CWG</a> 2015 年就有了。但是似乎好像并没有进一步被解决，而且在 C++20 中标准库还主动加入了具有类似作用的库，那就是<code>std::source_location::line</code>。当<code>line</code>作为函数默认参数的时候，随着函数调用位置不同，实际上默认参数取值也是不同的。</p>
</blockquote>
<h1 id="都是友元惹的祸"><a href="#都是友元惹的祸" class="headerlink" title="都是友元惹的祸"></a>都是友元惹的祸</h1><p>我们都知道 C++ 的 friend 关键字，可以对一个函数进行标记，然后允许这个函数访问类的私有成员。让我们考虑下面这两种情况。</p>
<ul>
<li>友元声明在全局空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp; ref)</span> </span>&#123; ref.member = <span class="number">123</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">touch</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>友元声明在类内部</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A&amp; ref)</span> </span>&#123; ref.member = <span class="number">123</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">touch</span>(a);  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两段代码都是 well defined 的，而且函数<code>touch</code>都能访问类<code>A</code>的私有成员。但是这两种实现方式之间，有微小的区别。在全局空间声明的友元函数，就和普通的函数一样，作用域也是一样的。都在全局命名空间，和全局普通的函数访问是一模一样的。而在类内部声明的友元函数，只能通过 C++ 的 <a href="https://en.cppreference.com/w/cpp/language/adl">Argument-dependent lookup</a> 进行访问。</p>
<ul>
<li>非 ADL 查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : <span class="built_in">member</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(A ref)</span> </span>&#123; std::cout &lt;&lt; ref.member &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">touch</span>(a);  <span class="comment">// normal lookup</span></span><br><span class="line">    <span class="built_in">touch</span>(<span class="number">1</span>);  <span class="comment">// implicit conversion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ADL 查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> member = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">touch</span><span class="params">(A ref)</span> </span>&#123; std::cout &lt;&lt; ref.member &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : <span class="built_in">member</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">touch</span>(a);</span><br><span class="line">    <span class="built_in">touch</span>(<span class="number">1</span>);     <span class="comment">// error</span></span><br><span class="line">    A::<span class="built_in">touch</span>(<span class="number">1</span>);  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里你就会发现了，第一次调用成功了，第二，三次调用失败了。这是因为，ADL会在函数参数对应的类型的命名空间中查找函数。在第一种情况下，<code>touch</code>函数的参数类型是<code>A</code>，发生了<code>ADL</code>查找。而<code>1</code>的类型是<code>int</code>，两者并不相关，所以 ADL 不会发生。</p>
<h1 id="模板显式实例化"><a href="#模板显式实例化" class="headerlink" title="模板显式实例化"></a>模板显式实例化</h1><p>考虑下面这种情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flag_setter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">flag</span>(<span class="number">1</span>);  <span class="comment">// error</span></span><br><span class="line">    flag_setter&lt;<span class="literal">true</span>&gt;&#123;&#125;;</span><br><span class="line">    <span class="built_in">flag</span>(<span class="number">1</span>);  <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先直接调用<code>flag</code>会发生错误，因为它的返回值类型尚未确定。需要在函数定义里面推导。所以第一个调用就失败了。后面我们进行了一次类模板显式实例化，可以认为模板显式实例化的时候会在全局命名空间添加一个该类型模板的特化（通过友元函数），而这个特化版本实现了<code>flag()</code>。因为<code>flag</code>函数有了定义，返回值类型也就确定了，所以第二次调用就成功了。</p>
<h1 id="一元常量表达式开关"><a href="#一元常量表达式开关" class="headerlink" title="一元常量表达式开关"></a>一元常量表达式开关</h1><p>有了上面那些技巧，我们就可以来实现，本文开头所提到的常量开关了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flag_setter</span> &#123;</span><br><span class="line">    <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">flag</span><span class="params">(<span class="keyword">auto</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> arg = <span class="number">0</span>, <span class="keyword">auto</span> condition = <span class="keyword">requires</span> &#123; <span class="built_in">flag</span>(arg); &#125;&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag_setter&lt;condition&gt;&#123;&#125;.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">value</span>();</span><br><span class="line">    <span class="built_in">static_assert</span>(a != b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的原理很简单，首先 C++20 加入的<code>requires</code>语句可以用于检查表达式的合法性。最开始的时候，由于<code>flag_setter</code>还尚未实例化，所以<code>flag</code>函数还没有定义，所以<code>flag(arg)</code>是不合法的表达式的。所以<code>condition</code>的值就会是<code>false</code>。然后我们通过<code>if constexpr</code>来判断<code>condition</code>的值，如果是<code>false</code>，那么我们就实例化一个<code>flag_setter</code>，并且返回<code>false</code>的值。如果是<code>true</code>，那么我们就返回<code>condition</code>的值。这样就实现了一元常量表达式开关。相比于 C++14 的版本，这个版本更加的简洁也更好理解。</p>
<p>值得注意的一点是，可能有人会问为什么不能直接写<code>requries&#123; flag(0); &#125;</code>呢？这是由于模板的 <a href="https://en.cppreference.com/w/cpp/language/two-phase_lookup">two phase lookup</a>，如果直接写<code>requries&#123; flag(0); &#125;</code>，会在第一阶段就进行查找，然后查找发现错误，并且这个错误是一个 hard error，会直接导致编译失败。如果让这个表达式依赖于模板变量，它就会变成 <a href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent names</a>，在第二阶段进行查找，并且可以被<code>requires</code>检测表达式是否合法。</p>
<h1 id="编译期常量计数器"><a href="#编译期常量计数器" class="headerlink" title="编译期常量计数器"></a>编译期常量计数器</h1><p>基于上述的原理，更进一步，我们可以直接实现一个编译期的计数器！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">setter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">size_t</span> value = N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> N = <span class="number">0</span>,</span><br><span class="line">          <span class="keyword">auto</span> tag = [] &#123;&#125;,</span><br><span class="line">          <span class="type">bool</span> condition = <span class="built_in">requires</span>(reader&lt;N&gt; red) &#123; <span class="built_in">counted_flag</span>(red); &#125;&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> setter&lt;N&gt; s;</span><br><span class="line">        <span class="keyword">return</span> s.value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>&lt;N + <span class="number">1</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">next</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <span class="built_in">next</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> c = <span class="built_in">next</span>();</span><br><span class="line">    <span class="built_in">static_assert</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; c == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们来解释一下上面的代码。基本原理和一元开关情况类似。<code>reader</code>用来判断函数有没有被实现，<code>setter</code>用来生成实现的函数。然后在<code>next</code>里面，我们首先查看当前的<code>N</code>对应的函数，有没有被实现。如果被没有被实现，就实例化一个<code>setter&lt;N&gt;</code>的模板。如果实现了的话，就递归的查看<code>N+1</code>的情况。</p>
<p>为了防止有些读者想不通，这里直接从第一次调用开始举例子</p>
<p>第一次调用这个函数：</p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;0&gt;</code>，并且返回<code>0</code>。</li>
</ul>
<p>第二次调用这个函数： </p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;1&gt;()</code>。 </li>
<li><code>N = 1</code>时，检查发现<code>setter&lt;1&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;1&gt;</code>，并且返回<code>1</code>。</li>
</ul>
<p>第三次调用这个函数： </p>
<ul>
<li><code>N = 0</code>时，检查发现<code>setter&lt;0&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;1&gt;()</code>。 </li>
<li><code>N = 1</code>时，检查发现<code>setter&lt;1&gt;</code>已经实现了，也就是<code>condition</code>是<code>true</code>。这样的话会走第二个分支，递归调用<code>next&lt;2&gt;()</code>。 </li>
<li><code>N = 2</code>时，检查发现<code>setter&lt;2&gt;</code>尚未实现，也就是<code>condition</code>是<code>false</code>。这样的话会走第一个分支，实例化一个<code>setter&lt;2&gt;</code>，并且返回<code>2</code>。</li>
</ul>
<p><code>......</code>，也就是说，我们每一次调用这个函数，就会实例化一个对应的模板函数，这个计数器，其实记录的就是已经实例化的模板函数的数量。</p>
<p>值得一提的是，上面有一个奇怪的写法。<code>auto tag = []&#123;&#125;</code>，你可能看的一脸懵逼。事实上，<code>[]&#123;&#125;</code>是一个简写的<code>lambda</code>表达式，其实就相当于<code>[]()&#123;&#125;</code>。如果用不到函数参数的话，这个小括号可以省略。那为什么我们要在这里添加一个这个玩意呢，完全用不到啊。你可以尝试把它去掉，就会发现得到了错误的结果。变量的值并没有按照预期的结果进行递增。</p>
<p>这里的原因是，编译器会对常量表达式的求值结果进行缓存，也就是说编译器认为<code>next</code>函数是常量表达式，返回的值应该是不会变的。那既然不会变，我只要求一次不就行了。于是它就把所有<code>next</code>的返回值都记录成相同的了。但是这不是我们想要的结果，我们想要它每次调用的时候都能计算表达式的值。加上这个标签之后，每次调用的模板参数实际是不同的，于是编译器就会重新计算它的值了。</p>
<p>看下面这个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> arg = [] &#123;&#125;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">test</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(arg).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();  <span class="comment">// class &lt;lambda_1&gt;</span></span><br><span class="line">    <span class="built_in">test</span>();  <span class="comment">// class &lt;lambda_2&gt;</span></span><br><span class="line">    <span class="built_in">test</span>();  <span class="comment">// class &lt;lambda_3&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出来的结果不同，表面每一次调用的<code>test()</code>的模板参数其实是不同的，那么这三个<code>test()</code>其实是三个不同的函数。利用这个特性，我们在每次调用<code>next</code>的时候，其实就是不同的模板函数（因为<code>lambda</code>模板参数类型不同）。这样我们就阻止了编译器的缓存。代码就像我们预期的那样进行调用了。</p>
<h1 id="彩蛋：合法访问类的私有成员"><a href="#彩蛋：合法访问类的私有成员" class="headerlink" title="彩蛋：合法访问类的私有成员"></a>彩蛋：合法访问类的私有成员</h1><p>我们首先要明确一个观点：类的访问权限说明符<code>private</code>, <code>public</code>, <code>protected</code>仅仅只作用于编译期的检查。如果能通过某种手段避免编译期检查，那完全就可以合法的访问，类的私有成员。</p>
<p>那么存在这样的方法吗？答案是存在。我们有<strong>模板显示实例化的时候可以忽略类作用域的访问权限</strong></p>
<blockquote>
<p> The C++11&#x2F;14 standards state the following in note 14.7.2&#x2F;12 [temp.explicit]: -The usual access checking rules do not apply to names used to specify explicit instantiations. [ Note: In particular, the template arguments and names used in the function declarator (including parameter types, return types and exception speciﬁcations) may be private types or objects which would normally not be accessible and the template may be a member template or member function which would not normally be accessible. — end note ]</p>
</blockquote>
<p>也就是说在显示实例化模板的时候，我们可以直接访问类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money = <span class="number">999&#x27;999&#x27;999&#x27;999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span> </span>&#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Thief</span>&lt;&amp;Bank::money&gt;;</span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bank bank;</span><br><span class="line">    <span class="built_in">steal</span>(bank) = <span class="number">100</span>;</span><br><span class="line">    bank.<span class="built_in">check</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功输出<code>100</code>！</p>
<hr>
<p>续篇已出，欢迎阅读：</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/646812253" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++ 禁忌黑魔法: STMP 多态</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/646812253</span></span></span></a></p>
<p>参考文章： </p>
<ul>
<li><a href="https://mc-deltat.github.io/articles/stateful-metaprogramming-cpp20">Revisiting Stateful Metaprogramming in C++20</a></li>
<li><a href="https://b.atch.se/posts/non-constant-constant-expressions/">b.atch: Non-constant constant-expressions in C++</a></li>
<li><a href="https://ledas.com/post/857-how-to-hack-c-with-templates-and-friends/">How to Hack C++ with Templates and Friends</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C++ 禁忌黑魔法: STMP 多态</title>
    <url>/646812253/</url>
    <content><![CDATA[<h1 id="前情提要："><a href="#前情提要：" class="headerlink" title="前情提要："></a>前情提要：</h1><p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/646752343" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++ 禁忌黑魔法: STMP</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/646752343</span></span></span></a></p>
<h1 id="什么是-STMP-多态"><a href="#什么是-STMP-多态" class="headerlink" title="什么是 STMP 多态"></a>什么是 STMP 多态</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span>&#123;</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    std::<span class="type">size_t</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Any&gt; vec = <span class="built_in">make_any</span>(<span class="number">1</span>, std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; any: vec) &#123;</span><br><span class="line">        <span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; v) &#123; std::cout &lt;&lt; v &lt;&lt; std::endl; &#125;, any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">make_any</span>(std::<span class="built_in">string_view</span>(<span class="string">&quot;world&quot;</span>)));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">make_any</span>(A&#123;&#125;));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; any: vec) &#123;</span><br><span class="line">        <span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; v) &#123; std::cout &lt;&lt; v &lt;&lt; std::endl; &#125;, any);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>STMP</code>多态把所有类型都擦成了<code>Any</code>类型，但是与<code>std::any</code>不同的是，<code>std::any</code>需要显示进行类型转换，非常麻烦，但是我们的<code>Any</code>可以方便的使用<code>visit</code>进行访问，不需要任何显示类型转换。这是因为我们利用了<code>STMP</code>，实现了类型的自动注册。</p>
<p>相关的代码仍然放 <a href="https://godbolt.org/z/7W7c7P8n1">Compiler Explorer</a> 上。为了防止链接失效，同样放在 <a href="https://github.com/16bit-ykiko/blog/blob/main/code/stmp-polymorphic.cpp">Github</a>。 </p>
<h1 id="书接上文"><a href="#书接上文" class="headerlink" title="书接上文"></a>书接上文</h1><p>上一篇文章我们实现了一个简单编译期计数器。可以返回一个递增的序列。但是这还不够。我们这篇文章来实现编译器类型容器，可以在编译期动态的添加和删除类型。</p>
<h1 id="type-list-工具箱"><a href="#type-list-工具箱" class="headerlink" title="type_list 工具箱"></a>type_list 工具箱</h1><p>由于我们要实现对类型列表的操作，所以一套称手的工具箱是必要的。我们简单写一些，不求多，只求够用就行。看不懂也没关系，看测试用例明白怎么用就行了。原理我就不讲解了，是非常基础的元编程知识。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type_list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_list</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = type_list&lt;Types...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_back</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_push_back</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_push_back</span>&lt;type_list&lt;Types...&gt;, T&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = type_list&lt;Types..., T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">list_push_back_t</span> = <span class="keyword">typename</span> list_push_back&lt;List, T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_front</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_push_front</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_push_front</span>&lt;type_list&lt;Types...&gt;, T&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = type_list&lt;T, Types...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">list_push_front_t</span> = <span class="keyword">typename</span> list_push_front&lt;List, T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop_back</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_pop_back</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_pop_back</span>&lt;type_list&lt;T, Types...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">list_push_front_t</span>&lt;<span class="keyword">typename</span> list_pop_back&lt;type_list&lt;Types...&gt;&gt;::type, T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_pop_back</span>&lt;type_list&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = type_list&lt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">list_pop_back_t</span> = <span class="keyword">typename</span> list_pop_back&lt;List&gt;::type;</span><br></pre></td></tr></table></figure>

<p>测试用例如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> list0 = type_list&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> list1 = <span class="type">list_push_back_t</span>&lt;list0, <span class="type">bool</span>&gt;;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;list1, type_list&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>, <span class="type">bool</span>&gt;&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> list2 = <span class="type">list_push_front_t</span>&lt;list1, <span class="type">float</span>&gt;;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;list2, type_list&lt;<span class="type">float</span>, <span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>, <span class="type">bool</span>&gt;&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> list3 = <span class="type">list_pop_back_t</span>&lt;list2&gt;;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;list3, type_list&lt;<span class="type">float</span>, <span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;&gt;);</span><br></pre></td></tr></table></figure>

<h1 id="返回不同的类型"><a href="#返回不同的类型" class="headerlink" title="返回不同的类型"></a>返回不同的类型</h1><p>先来看一个简单案例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">setter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span> </span>&#123; <span class="keyword">return</span> T&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setter&lt;<span class="number">0</span>, <span class="type">int</span>&gt; setter0;  <span class="comment">// set</span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">counted_flag</span>(reader&lt;<span class="number">0</span>&gt;&#123;&#125;);  <span class="comment">// read</span></span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(a), <span class="type">int</span>&gt;);</span><br><span class="line"></span><br><span class="line">    setter&lt;<span class="number">1</span>, <span class="type">double</span>&gt; setter1;  <span class="comment">// set</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">counted_flag</span>(reader&lt;<span class="number">1</span>&gt;&#123;&#125;);  <span class="comment">// read</span></span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(b), <span class="type">double</span>&gt;);</span><br><span class="line"></span><br><span class="line">    setter&lt;<span class="number">2</span>, std::string&gt; setter2;  <span class="comment">// set</span></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">counted_flag</span>(reader&lt;<span class="number">2</span>&gt;&#123;&#125;);  <span class="comment">// read</span></span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(c), std::string&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现没有，可以在某一个位置注册信息。然后仅仅通过这个位置的序号就可以读取到对应的类型。就像一个数组一样，是不是非常神奇。原理就是很好理解，利用了类型推导以及友元函数的 ADL 查找。</p>
<h1 id="编译期类型容器"><a href="#编译期类型容器" class="headerlink" title="编译期类型容器"></a>编译期类型容器</h1><p>让我们结合把这个特性和程序计数器结合起来，神奇的事情就发生了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// counter</span></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">setter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">counted_flag</span><span class="params">(reader&lt;N&gt;)</span> </span>&#123; <span class="keyword">return</span> T&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> tag = [] &#123;&#125;,</span><br><span class="line">          <span class="keyword">auto</span> N = <span class="number">0</span>,</span><br><span class="line">          <span class="type">bool</span> condition = <span class="built_in">requires</span>(reader&lt;N&gt; red) &#123; <span class="built_in">counted_flag</span>(red); &#125;&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>&lt;tag, N + <span class="number">1</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">void</span> <span class="title">Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setter&lt;<span class="number">0</span>, type_list&lt;Ts...&gt;&gt; s [[maybe_unused]]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> tag = [] &#123;&#125;&gt;</span><br><span class="line"><span class="keyword">using</span> value = <span class="keyword">decltype</span>(<span class="built_in">counted_flag</span>(reader&lt;<span class="built_in">count</span>&lt;tag&gt;()&gt;&#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> tag = [] &#123;&#125;&gt;</span><br><span class="line"><span class="keyword">consteval</span> <span class="type">void</span> <span class="built_in">push</span>() &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> len = <span class="built_in">count</span>&lt;tag&gt;();</span><br><span class="line">    setter&lt;len + <span class="number">1</span>, <span class="type">list_push_back_t</span>&lt;value&lt;tag&gt;, T&gt;&gt; s [[maybe_unused]]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> tag = [] &#123;&#125;&gt;</span><br><span class="line"><span class="keyword">consteval</span> <span class="type">void</span> <span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> len = <span class="built_in">count</span>&lt;tag&gt;();</span><br><span class="line">    <span class="keyword">using</span> last = value&lt;tag&gt;;</span><br><span class="line">    setter&lt;len + <span class="number">1</span>, <span class="type">list_pop_back_t</span>&lt;value&lt;tag&gt;&gt;&gt; s [[maybe_unused]]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Set</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;value&lt;&gt;, type_list&lt;<span class="type">int</span>&gt;&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;value&lt;&gt;, type_list&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;value&lt;&gt;, type_list&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;value&lt;&gt;, type_list&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们实现了一个<code>count</code>函数，它的原理是前面的<code>next</code>类似，不同的是，<code>next</code>每次会进行递增，而<code>count</code>仅仅是返回实例化的目标模板数量。</p>
<p>剩下的逻辑就很简单了：</p>
<ul>
<li><code>Set</code>函数用来初始化一个<code>setter</code>，这个<code>setter</code>里面包含了一个类型列表，这个列表表示初始值。</li>
<li><code>value</code>用<code>count</code>取出最后一个状态。</li>
<li><code>push</code>用<code>count</code>取出最后一个状态的<code>index</code>，取出对应的<code>type_list</code>，然后对这个<code>type_list</code>进行操作。通过实例化一个新的模板，添加一个新的状态，把新得到的<code>type_list</code>存进去。</li>
<li><code>pop</code>与<code>push</code>类似，只不过对<code>type_list</code>的操作变成了删除。</li>
</ul>
<p>按照这个原理，可以轻松的扩展很多类似的操作，其实只要对<code>type_list</code>进行操作就行了。</p>
<h1 id="挑战C-的极限"><a href="#挑战C-的极限" class="headerlink" title="挑战C++的极限"></a>挑战C++的极限</h1><p>好了时候到了最终实现的时候了，让我们看看C++的极限在哪里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Any</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span> &#123;</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    std::<span class="type">size_t</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> tag = [] &#123;&#125;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="built_in">make_any</span>(T&amp;&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ls = push&lt;std::<span class="type">decay_t</span>&lt;T&gt;, tag&gt;();</span><br><span class="line">    <span class="keyword">return</span> Any&#123;<span class="keyword">new</span> <span class="built_in">auto</span>(std::forward&lt;T&gt;(t)), <span class="built_in">count</span>&lt;tag&gt;()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="built_in">requires</span> (<span class="keyword">sizeof</span>...(Ts) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">make_any</span><span class="params">(Ts&amp;&amp;... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::vector&#123;<span class="built_in">make_any</span>(std::forward&lt;Ts&gt;(ts))...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> T, <span class="keyword">auto</span> tag = [] &#123;&#125;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="built_in">wrap</span>(Fn&amp;&amp; fn, <span class="type">void</span>* ptr) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; value = *<span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    <span class="keyword">using</span> ret = <span class="keyword">decltype</span>(<span class="built_in">fn</span>(value));</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;ret, <span class="type">void</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">fn</span>(value);</span><br><span class="line">        <span class="keyword">return</span> Any&#123;<span class="literal">nullptr</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push</span>&lt;ret, tag&gt;();</span><br><span class="line">        <span class="keyword">return</span> Any&#123;<span class="keyword">new</span> <span class="built_in">auto</span>(<span class="built_in">fn</span>(value)), <span class="built_in">count</span>&lt;tag&gt;()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fn, <span class="keyword">auto</span> tag = [] &#123;&#125;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="built_in">visit</span>(Fn&amp;&amp; fn, Any any) &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> size = <span class="built_in">count</span>&lt;tag&gt;();</span><br><span class="line">    <span class="keyword">using</span> Wrapper = <span class="built_in">Any</span> (*)(Fn&amp;&amp;, <span class="type">void</span>*);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> wrappers = []&lt;<span class="keyword">typename</span>... Ts&gt;(type_list&lt;Ts...&gt;) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::array&lt;Wrapper, size&gt;&#123;wrap&lt;Fn, Ts&gt;...&#125;;</span><br><span class="line">    &#125;(<span class="built_in">value</span>&lt;tag&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappers[any.index](std::forward&lt;Fn&gt;(fn), any.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里实现了对<code>Any</code>的自动注册。每次当你调用<code>make_any</code>的时候，就会自动注册一个新的类型，到全局的状态表里。然后<code>visit</code>的时候，其实我们是生成了一些<code>Wrapper</code>函数，打了一个表，然后通过<code>index</code>去调用对应的函数。这样就实现了对<code>Any</code>的自动访问。这里的关键步骤就是，向全局的状态表里面自动注册信息。其余的步骤都和<code>std::visit</code>实现类似。感兴趣的可以去看看<code>std::visit</code>的实现。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>事实上，这个系列算是了解了笔者一直以来的心愿。经常听到有人调侃，男人两大爱好是：拉良家妇女下水 劝风尘女子从良。程序员，也有两大爱好：让静态类型的语言变的更动态，为动态语言加上类型检查。事实上自从我学<code>C++</code>以来，一直有这样的心愿，想要实现类型的自动注册。很遗憾，网络上相关的讨论很少。在那之后，我尝试了各种方法，包括但不限于，使用宏元编程，采用<code>libclang</code>等库<code>parse</code>对<code>C++</code>的源码进行解析，但是效果都不如<code>STMP</code>好。当我了解<code>STMP</code>，并且意识到它所能达到的高度之后。我立马通宵写完了文章和案例，毕竟它是如此的令人着迷。在这里，我不想讨论什么可读性，可维护性。由于<code>STMP</code>尚未被标准认可，所以运用到实际项目的编程里，事实上是很困难的。再一次强调，用到实际项目里面并不现实（具体可以看一下评论区讨论）。但是就像当初模板元编程的意外发现一样，这再一次证明了，一门语言能够能多么疯狂的超过它所预期的能力。本文实现的<code>STMP</code>多态，在其它任何一门语言里面都是不可能出现的，这就是<code>C++</code>的魅力所在！</p>
]]></content>
  </entry>
  <entry>
    <title>雾里看花：真正意义上的理解 C++ 模板(Template)</title>
    <url>/655902377/</url>
    <content><![CDATA[<p>在 C++ 中，模板（Template）这个概念已经存在二十多年了。作为 C++ 最重要的一个语言构成之一，相关的讨论数不胜数。很可惜的是，相关深入的有价值的讨论很少，尤其是提供多个视角看待这一技术。很多文章在谈论模板的时候往往会把它和各种语法细节缠绕在一起，容易给人一种云里雾里的感觉。类似的例子还发生在其它话题上面，比如介绍协程就和各种 IO 混在一起谈，谈到反射似乎就限定了 Java，C# 中的反射。这样做并不无道理，但是往往让人感觉抓不到本质。看了一大堆，但却不得其要领，反倒容易把不同的概念混淆在一起。</p>
<p>就我个人而言，讨论一个问题喜欢多层次，多角度的去讨论，而不仅限某一特定的方面。这样一来，既能更好的理解问题本身，也不至于让自己的视野太狭隘。故本文将尝试从模板诞生之初开始讲起，以四个角度来观察，理清模板这一技术在 C++ 中的发展脉络。注意，本文并不是教学文章，不会深入语法细节。更多的谈论设计哲学和 trade-off 。掌握一点点模板的基础知识就能看懂，请放心食用。当然这样可能严谨性有所缺失，如有错误欢迎评论区讨论。</p>
<p><strong>我们主要讨论四个主题：</strong></p>
<ul>
<li>控制代码生成，实现泛型</li>
<li>做泛型约束</li>
<li>编译期计算</li>
<li>对类型做计算</li>
</ul>
<p>其中第一个主题一般认为就是普通的 Template。而后三者一般被规划到「TMP」中去。TMP 即 Template meta programming 也就是模板元编程。因为模板设计之初的意图并不是实现后面这三个功能，但是能以比较抽搐的语法来实现这些功能，代码写起来也比较抽象难懂，所以一般叫做元编程。</p>
<h1 id="代码生成，实现泛型"><a href="#代码生成，实现泛型" class="headerlink" title="代码生成，实现泛型"></a>代码生成，实现泛型</h1><p>事实上，这一点正是模板被设计之初的用法，用于实现泛型。在加入模板之前，常常使用宏来实现泛型。考虑下面这个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> add(T) _ADD_IMPL_##T</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_IMPL(T)  \</span></span><br><span class="line"><span class="meta">    T _ADD_IMPL_##T(T a, T b) &#123; return a + b; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_IMPL</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">ADD_IMPL</span>(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="type">int</span>)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="type">float</span>)(<span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理倒是很简单，其实就是把函数里面的类型替换成了宏参数。然后通过<code>IMPL</code>来「实例化」一个函数定义，最后直接使用就行了。但是上面的代码有很多缺点： </p>
<ul>
<li>代码可读性差，宏的拼接和代码逻辑耦合 </li>
<li>没法调试，宏只有展开后才能调试 ，报错信息不好阅读</li>
<li>在使用对应的函数之前，必须手动实例化，比如上面的<code>ADD_IMPL(int)</code> </li>
<li>需要显式写出对应的泛型类型，没法自动推导泛型类型</li>
</ul>
<p>这些问题，在模板中都被解决了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="type">int</span> add&lt;&gt;(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 显式实例化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// 显式指定模板参数 T</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);        <span class="comment">// 自动推导模板参数 T</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>);  <span class="comment">// 自动推导并且隐式实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板就是占位符，不需要拼接字符串，完全不影响代码的可读性</li>
<li>模板的报错信息相对友好，当类型不匹配时，会提示对应的类型</li>
<li>模板既可以隐式实例化也可以显式实例化</li>
<li>既可以自动推导模板参数，也可以显式指明模板参数</li>
</ul>
<p>除此之外，模板还支持偏特化，特化，可变模板参数，类成员模板等等一系列特性，这些都是宏做不到的。而且通过模板这一特性的的确确实现了 STL 这样通用的标准库。经常听见很多人问为什么 C 语言没有别的语言那样的容器，算法标准库呢？一个很重的原因就是 C 语言抽象能力不够，没法实现一套这样通用的方案。而且结合后面聊的三个主题，我们可以通过模板实现一些更高级的代码生成。比如经常说的<strong>编译期打表，打函数表</strong>这种<strong>。</strong></p>
<p>别的我都同意，但是你这上面的 <strong>模板的报错信息相对友好，当类型不匹配时，会提示对应的类型</strong>。难道这不是五十步笑百步吗？甚至有过之而无不及。轻松产生几百，几千行的代码报错，只有 C++ 的模板能做到吧。</p>
<p>哎，别急，这就是下面我要讲到的问题。</p>
<h1 id="对类型做约束"><a href="#对类型做约束" class="headerlink" title="对类型做约束"></a>对类型做约束</h1><p>首先我们要讨论的问题是，为什么 C++ 的编译错误信息这么长？而且有时候非常难读懂。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; A&#123;&#125; &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的 GCC 编译器上，足足产生了 239 行报错信息。不过好消息是 GCC 把重点信息标记出来了，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">no match <span class="keyword">for</span> <span class="string">&#x27;operator&lt;&lt;&#x27;</span> (operand types are <span class="string">&#x27;std::ostream&#x27;</span> &#123;aka <span class="string">&#x27;std::basic_ostream&lt;char&gt;&#x27;</span>&#125; <span class="keyword">and</span> <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="number">9</span> |     std::cout &lt;&lt; A&#123;&#125; &lt;&lt; std::endl;</span><br><span class="line">      |     ~~~~~~~~~ ^~ ~~~</span><br><span class="line">      |          |       |</span><br><span class="line">      |          |       A</span><br><span class="line">      |          std::ostream &#123;aka std::basic_ostream&lt;<span class="type">char</span>&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>那大概还是能读懂的的，意思就是没有找到匹配的重载函数。也就是说我们需要为<code>A</code>重载<code>operator&lt;&lt;</code>。当然这个只是入门级别的，还是能轻松看懂的。但是我们好奇的是，剩下的两百行报错在干嘛呢？其实关键就在于重载函数和隐式类型转换。让我们来看其中一段信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">note:   <span class="keyword">template</span> argument deduction/substitution failed:</span><br><span class="line">note:   cannot convert <span class="string">&#x27;A()&#x27;</span> (type <span class="string">&#x27;A&#x27;</span>) to type <span class="string">&#x27;const char*&#x27;</span></span><br><span class="line">    <span class="number">9</span> |     std::cout &lt;&lt; A&#123;&#125; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>意思就是尝试用<code>A</code>类型匹配<code>const char*</code>这个重载（通过隐式类型转换），结果失败了。标准库类似这样的函数，都实现了很多的重载函数，比如这个<code>operator&lt;&lt;</code>就重载了<code>int</code>,<code>bool</code>,<code>lon</code>g,<code>double</code> 等等，将近几十个函数。结果报错信息就是把所有重载函数尝试失败的原因都列出来，于是轻松就有几百行了，再加上标准库诡异的命名，看起来就像天书一样。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>函数重载是导致报错信息难以读懂的一部分原因，但不是全部。实际上如上面所示，仅仅是把所有可能性枚举出来，不过几百行报错。要知道我们还能产出上千行呢，量级上的差距可不是能用数量轻松堆叠出的。况且本小节要说的是约束，和报错有什么关系呢。 来看下面这个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(A&#123;&#125;, B&#123;&#125;);  <span class="comment">// 短短几行报错</span></span><br><span class="line">    <span class="built_in">test</span>(A&#123;&#125;, A&#123;&#125;);  <span class="comment">// 几百行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>究竟为什么会出现如此大的差距呢？还记得我们在第一部分里面说的模板相比于宏的两个优点吗？一个是自动类型推导，一个是隐式实例化。对于模板报错来说也基本是从这两个角度入手，<code>test(A&#123;&#125;, B&#123;&#125;)</code>这里模板参数推导失败了。因为<code>test</code>函数隐含了一个重要的条件，那就是 a 和 b 的类型是一样的，于是实际上它报的错误是找不到匹配的函数，然后把推断失败的模板函数的原因列出来。而第二个函数<code>test(A&#123;&#125;, A&#123;&#125;)</code>则是模板参数推导成功了，进入到实例化的阶段了，但是在实例化的阶段出错了。也就是说<code>T</code>已经被推断为<code>A</code>了，尝试把<code>A</code>代入函数体的时候，出错了。于是就只能把替换失败的原因列出来了。</p>
<p>那对类型做约束有什么用呢？看下面这个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// requires requires (T x) &#123; std::cout &lt;&lt; x; &#125;</span></span><br><span class="line"><span class="comment">// C++20 加入的requires语法，意思就是要求 std::cout &lt;&lt; x 是合法的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print1</span>(x);</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print2</span>(A&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>短短几行，在我的 GCC 上产生了 700 行的编译错误。稍微改动一下，把注释掉的那行代码加上。相比之下这种情况的代码报错只有短短几行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">In substitution of <span class="string">&#x27;template&lt;class T&gt;  requires requires(T x) &#123;std::cout &lt;&lt; x;&#125; void print2(T) [with T = A]&#x27;</span>:</span><br><span class="line">required from here</span><br><span class="line">required by the constraints of <span class="string">&#x27;template&lt;class T&gt;  requires requires(T x) &#123;std::cout &lt;&lt; x;&#125; void print2(T)&#x27;</span></span><br><span class="line">in requirements with <span class="string">&#x27;T x&#x27;</span> [with T = A]</span><br><span class="line">note: the required expression <span class="string">&#x27;(std::cout &lt;&lt; x)&#x27;</span> is invalid</span><br><span class="line">   <span class="number">15</span> | <span class="keyword">requires</span> <span class="built_in">requires</span> (T x) &#123; std::cout &lt;&lt; x; &#125;</span><br></pre></td></tr></table></figure>

<p>意思就是<code>A</code>类型的实例<code>x</code>不满足<code>requires</code>语句<code>std::cout &lt;&lt; x</code>。事实上通过这样的语法，我们就可以把错误限制在类型推断的阶段，而不去进行实例化。于是报错就友好一万倍了。也就是说通过<code>requires</code>我们能阻止编译错误的传播。 但是可惜的是，相关的约束语法是在 C++20 才加入的。那在这之前呢？</p>
<h2 id="C-20之前"><a href="#C-20之前" class="headerlink" title="C++20之前"></a>C++20之前</h2><p>在 C++20 之前，我们并没有这么好用的方法。只能通过一种叫做 <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>的技术来实现类似的功能，对类型实现约束。比如上面那个功能，在 C++20 之前只能这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">decltype</span>(std::cout &lt;&lt; std::<span class="built_in">declval</span>&lt;T&gt;())&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">print2</span>(T x) &#123;</span><br><span class="line">    <span class="built_in">print1</span>(x);</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的规则在这里就不介绍了，感兴趣的可以去搜搜相关的文章看看。</p>
<p>结果就是<code>typename = decltype(std::cout &lt;&lt; std::declval&lt;T&gt;())</code>这行代码，完全让人不知所云。只有深入了解相关的规则之后才能看懂这究竟是在干嘛。被口诛笔伐自然是少不了的，如此常用的功能直到 C++20 才加入，实在是很让人很流汗黄豆啊。不过据 C++ 之父本人 <a href="https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/06.md">自述</a> ，其实他早就意识到这个问题了，需要对泛型添加某种约束，不过一直拖到 C++20 而已（笑）。别的支持泛型的语言，也基本都有类似的东西。例如 Rust 和 C# 都通过<code>where</code>来表达类似的约束。 </p>
<h1 id="编译期计算"><a href="#编译期计算" class="headerlink" title="编译期计算"></a>编译期计算</h1><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>首先要肯定的一点是，编译期计算肯定是有用的。具体到特定场景，意义有多大，倒是没法判断。有很多人谈编译期计算色变，什么代码难懂，屠龙技，没有价值云云。这样的确很容易误导初学者。事实上相关的需求的确存在。如果编程语言没有这个功能，但是确有需求，程序员也会想方设法的通过其它的办法来实现。</p>
<p>我将举两个例子来说明：</p>
<ul>
<li>首先是编译器对常量表达式的优化，相信这个大家都并不陌生。极其简单的情况，像<code>1+1+x</code>这样的表达式，必然是会被优化成<code>2+x</code>。事实上现代编译器对于类似的情况能做的优化非常多，比如这个 <a href="https://www.zhihu.com/question/619246858/answer/3184453259">问题</a>。提问者提问 C 语言的<code>strlen</code>函数在参数是常量字符串的时候，会不会把函数调用直接优化成一个常量。比如<code>strlen(&quot;hello&quot;)</code>会不会直接优化成<code>5</code>。从主流编译器的实验结果来看，答案是肯定的。类似的情况数不胜数，不知不觉中你就在使用编译期计算。只是它被归到编译器优化的一部分去了。而编译器的优化能力总归是有上限的，允许使用者自己定义这种优化规则，会更加灵活和自由。比如在 C++ 里面明确了<code>strlen</code>是<code>constexpr</code>的，这种优化必然会发生</br> </li>
<li>其而是在程序语言发展早期，编译器优化能力还没那么强的时候。就已经开始广泛的使用外部脚本语言提前算好数据（甚至生成好代码）用来减少运行时开销了。典型的例子是算好三角函数表这种常量表，然后运行期直接用就行了（比如在编译代码之前，运行一段<code>python</code>脚本用来生成一些需要的代码）</li>
</ul>
<p>C++ 的编译期计算有明确的语义保证，并且内嵌于语言之中，能和其它部分良好的交互。从这个角度来说，很好的解决了上面两点问题。当然很多人对它的讨伐并不无道理，通过模板元编程进行的编译期计算。代码丑陋且晦涩难懂，牵扯到的语法细节多，并且大大拖慢编译时间，增加二进制文件大小。无可否认的是，这些问题的确存在。但是随着 C++ 版本的不断更新，编译期计算现在已经非常容易理解了，不再需要去写那些复杂的模板元代码，新手也能很快学会。因为和运行期代码几乎一样了。接下来伴随着它的发展史，我们将逐步阐明。</p>
<h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p>从历史上看，<code>TMP</code> 是一个偶然事件。在标准化 C++ 语言的过程中发现它的模板系统恰好是图灵完备的，即原则上能够计算任何可计算的东西。第一个具体演示是 Erwin Unruh 编写的一个程序，该程序计算素数，尽管它实际上并未完成编译：素数列表是编译器在尝试编译代码时生成的错误消息的一部分。具体的示例，请参考 <a href="https://en.wikibooks.org/wiki/C%2B%2B_Programming/Templates/Template_Meta-Programming#History_of_TMP">这里</a>。</p>
<p>作为入门级别的编程案例，可以展示一个编译期计算阶乘的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> value = Factorial&lt;<span class="number">5</span>&gt;::value;  <span class="comment">// =&gt; 120</span></span><br></pre></td></tr></table></figure>

<p>这段代码即使在 C++11 之前也能通过编译，在那之后 C++ 引入了很多新的东西用于简化编译期计算。最重要的就是<code>constexpr</code>关键字了。可以发现在 C++11 之前，我们并没有合适的办法表示编译期常量这一概念，只能借用<code>enum</code>来表达。而 C++11 之后，我们可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尽管进行了一些简化，但实际上我们仍然是借助模板来进行编译期计算。这样写出的代码是难以读懂的，主要原因有以下两点： </p>
<ul>
<li>模板参数只能是编译期常量，并没有编译期变量的概念，无论是全局还是局部都没有 </li>
<li>只能通过递归而不能通过循环来进行编程</li>
</ul>
<p>想象一下，如果平常写代码，把变量和循环给你禁了，那写起来是有多难受啊。</p>
<p>那有没有满足上面两个特征的编程语言呢？其实满足上面两点的编程语言，一般称为 pure functional 也即纯函数式的编程语言。Haskell 就是一个典型的例子。 但是 Haskell 它有强大的模式匹配，在熟悉了 Haskell 的思维之后，也能写出短小优美的代码（而且 Haskell 本身也能用 do 语法模拟出局部变量，因为使用局部变量，其实就相当于把它作为函数参数一级级传递下去）。而 C++ 这些都没有，属于是把别人缺点都继承来了，优点一个没有，自然是被声讨的对象。所幸的是，上面这些问题都在<code>cosntexpr function</code>中都被解决了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">factorial</span><span class="params">(std::<span class="type">size_t</span> N)</span> </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">factorial</span>(<span class="number">5</span>);  <span class="comment">// compile-time</span></span><br><span class="line">    std::<span class="type">size_t</span>&amp; n = *<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">factorial</span>(n);  <span class="comment">// run-time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，C++ 允许在一个函数前面直接加上<code>constexpr</code>关键字修饰。表示这个函数既可以在运行期调用，也可以在编译期调用，而函数本身的内容几乎不需要任何改变。这样一来，我们可以直接把运行期的代码复用到编译期。也允许使用循环和局部变量进行编程，可以说和平常写的代码没有任何区别。很令人震惊对吧，所以编译期计算在 C++ 里面早已经是一件司空见惯的事情了，用户压根就不需要去写复杂的模板元。在 C++20 之后几乎所有的标准库函数也都是<code>constexpr</code>的了，我们可以轻松的调用它们，比如编译期排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">sort</span><span class="params">(<span class="keyword">auto</span>&amp;&amp; range)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(std::<span class="built_in">begin</span>(range), std::<span class="built_in">end</span>(range));</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> arr = <span class="built_in">sort</span>(std::array&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正意义上的代码复用！如果你想要这个函数只在编译期执行，你也可以用<code>consteval</code>标记它。同时，在 C++20 中还允许了编译期动态内存分配，可以在<code>constexpr function</code>中使用<code>new</code>来进行内存分配，但是编译期分配的内存必须要在编译期释放。你也可以直接在编译期使用<code>vector</code>和<code>string</code>这样的容器。而且请注意，相比于利用模板进行编译期计算，<code>constexpr</code>函数的编译速度会快很多 。如果你好奇编译期是如何实现这一强大的特性的，可以认为，<code>C++</code>编译器内部内嵌了一个小的解释器，这样遇到<code>constexpr</code>函数的时候用这个解释器解释一下，再把计算结果返回就行了。 </p>
<p>相信你已经充分见识到 C++ 在编译期计算方面所做的努力，编译期计算早就和模板元脱离关系了，在 C++ 中已经成为一种非常自然的特性，不需要特殊的语法，却能发挥强大的威力。所以以后千万不要一谈到 C++ 的编译期计算就十分恐慌，以为是什么屠龙之技。现在它早已经变得十分温柔美丽。</p>
<p>尽管编译期计算已经脱离了模板元的魔爪，但是 C++ 并没有。还有两种情况，我们不得不编写蹩脚的模板元代码。</p>
<h1 id="无法迈过的坎"><a href="#无法迈过的坎" class="headerlink" title="无法迈过的坎"></a>无法迈过的坎</h1><h2 id="对类型做计算"><a href="#对类型做计算" class="headerlink" title="对类型做计算"></a>对类型做计算</h2><p>如何判断两个类型相等呢，或者说判断两个变量的类型相等。可能有人会想，这不是多此一举吗，变量的类型都是编译期已知的，还需要判断吗？其实这个问题可以说是伴随着泛型编程而出现的，考虑下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码是符合我们直觉的，可惜 C++ 并不允许你这么写。不过在 Python &#x2F; Java 等语言中确实有这种写法，但是它们的判断大多都是在运行时的。C++ 的确允许我们在编译期对类型进行操作，但是可惜的是类型并不能作为一等公民，作为普通的值，只能作为模板参数。我们只能写出如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型只能存在于模板参数里面，这直接导致上一小节的<code>constexpr</code>编译计算提到的优势全都消失了。我们又回到了刀耕火种的时代，没有变量和循环。</p>
<p>下面是判断两个<code>type_list</code>满足不满足子序列关系的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_list</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SubFirst, <span class="keyword">typename</span>... SubRest, <span class="keyword">typename</span> SuperFirst, <span class="keyword">typename</span>... SuperRest&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">is_subsequence_of_impl</span><span class="params">(type_list&lt;SubFirst, SubRest...&gt;, type_list&lt;SuperFirst, SuperRest...&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;SubFirst, SuperFirst&gt;)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>...(SubRest) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">return</span> <span class="literal">true</span></span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">is_subsequence_of</span>(type_list&lt;SubRest...&gt;&#123;&#125;, type_list&lt;SuperRest...&gt;&#123;&#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(<span class="keyword">sizeof</span>...(SuperRest) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">is_subsequence_of</span>(type_list&lt;SubFirst, SubRest...&gt;&#123;&#125;, type_list&lt;SuperRest...&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Sub, <span class="keyword">typename</span>... Super&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">is_subsequence_of</span><span class="params">(type_list&lt;Sub...&gt;, type_list&lt;Super...&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>...(Sub) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">true</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(<span class="keyword">sizeof</span>...(Super) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">is_subsequence_of_impl</span>(type_list&lt;Sub...&gt;&#123;&#125;, type_list&lt;Super...&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">is_subsequence_of</span>(type_list&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&#123;&#125;, type_list&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">float</span>&gt;&#123;&#125;));</span><br><span class="line">    <span class="built_in">static_assert</span>(!<span class="built_in">is_subsequence_of</span>(type_list&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&#123;&#125;, type_list&lt;<span class="type">double</span>, <span class="type">long</span>, <span class="type">char</span>, <span class="type">double</span>&gt;&#123;&#125;));</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">is_subsequence_of</span>(type_list&lt;&gt;&#123;&#125;, type_list&lt;&gt;&#123;&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写起来非常难受，我把相同的代码逻辑用<code>constexpr</code>函数写一遍，把类型参数换成<code>std::size_t</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_subsequence_of</span><span class="params">(<span class="keyword">auto</span>&amp;&amp; sub, <span class="keyword">auto</span>&amp;&amp; super)</span> </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(std::<span class="type">size_t</span> i = index; index &lt; sub.<span class="built_in">size</span>() &amp;&amp; i &lt; super.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(super[i] == sub[index]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index == sub.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">is_subsequence_of</span>(std::array&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, std::array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br><span class="line"><span class="built_in">static_assert</span>(!<span class="built_in">is_subsequence_of</span>(std::array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;, std::array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br></pre></td></tr></table></figure>

<p>瞬间清爽一万倍，仅仅是因为在 C++ 中类型不是一等公民，只能作为模板参数，在涉及到类型相关的计算的时候，我们就不得不编写繁琐的模板元代码。事实上对类型做计算的需求一直都存在，典型的例子是<code>std::variant</code>。在编写<code>operator=</code>的时候，我们需要从一个类型列表里面（<code>variant</code>的模板参数列表）里面查找某个类型并返回一个索引，其实就是从一个数组里面查找一个满足特定条件的元素。相关的实现这里就不展示了。其实可怕的并不是使用模板元编程本身，而是就 C++ 自身而言，把类型当作值这样的改动是完全不可接受 unacceptable 的。也就是说这样的状况会一直持续下去，以后都不会有什么本质上的改变，这一事实才是最让人悲伤的。不过仍然要清楚的一个事实是，支持对类型做计算的语言并不多，像 Rust 对于这方面的支持几乎没有。C++ 的代码虽然写起来蹩脚，但是至少能写。</p>
<p>但是还好这里有还有另外一条路可以走。就是通过一些手段把类型映射到值。例如把类型映射到字符串，匹配类型可以类似于匹配字符串，只要对字符串进行计算就好了，也能实现一定程度上的<code>type as value</code>。C++23之前 并没有标准化的手段进行这种映射，通过一些特殊的编译器扩展能做到，可以参考 <a href="https://16bit-ykiko.github.io/about-me/680412313">C++ 中如何优雅进行 enum 到 string 的转换</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_list</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">find</span><span class="params">(type_list&lt;Ts...&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// type_name returns the name of the type</span></span><br><span class="line">    std::array arr = &#123;<span class="built_in">type_name</span>&lt;Ts&gt;()...&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="built_in">type_name</span>&lt;T&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++23 之后也可以直接用typeid实现映射，而不使用字符串映射。但是类型映射到值简单，把值映射到类型回去可一点都不简单，除非你利用 <a href="https://16bit-ykiko.github.io/about-me/646752343">STMP</a> 这种黑魔法，才能方便的把值映射回类型。但是，如果静态反射将来被引入，那么这种从类型和值的双向映射会非常简单。这样的话虽然不能直接支持把类型当成值来进行操作，但是也基本差不多了。不过还有很长一段路要走，具体什么时候能加入标准，还是个未知数。如果对静态反射感兴趣，可以下面这篇文章 </p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/661692275" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++26 静态反射提案解析</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/661692275</span></span></span></a></p>
<h2 id="编译期变量之痛"><a href="#编译期变量之痛" class="headerlink" title="编译期变量之痛"></a>编译期变量之痛</h2><p>除了上面说的对类型做计算不得不用到模板元编程之外，如果需要在编译期计算的同时实例化模板，也不得不用模板元编程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(std::<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::array&lt;std::<span class="type">size_t</span>, length&gt;&#123;&#125;;</span><br><span class="line">    <span class="comment">// error length is not constant expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错的意思就是<code>length</code>不是编译期常量，一般认为它属于编译期变量。这样就很让人讨厌了，考虑如下需求：我们要实现一个完全类型安全的<code>format</code>。也就是说根据第一个常量字符串的内容，来约束后面函数参数的个数。比如是<code>&quot;&#123;&#125;&quot;</code> 的话，后面<code>format</code>的函数参数个数就是<code>1</code>个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">count</span><span class="params">(std::string_view fmt)</span> </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; fmt.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fmt[i] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; i + <span class="number">1</span> &lt; fmt.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fmt[i + <span class="number">1</span>] == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                num += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">format</span><span class="params">(std::string_view fmt, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    <span class="title">requires</span> <span class="params">(<span class="keyword">sizeof</span>...(Args) == count(fmt))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上我们并没有办法保证一个函数参数是编译期常量，所以上面的代码是没法编译通过的。想要编译期常量，只能把这部分内容填到模板参数里面去，比如上面的函数可能会最后修改成<code>format&lt;&quot;&#123;&#125;&quot;&gt;(1)</code>这样的形式。虽然只是形式上的差别，但这无疑给使用者带来了困难。这样来看，也就不难理解为什么<code>std::make_index_sequence</code>这样的东西大行其道了。想要真正意义上可以做模板参数的编译期变量，也可以通过 <a href="https://16bit-ykiko.github.io/about-me/646752343">STMP</a> 这种黑魔法做到，但是如前文所述，难以在日常的编程中真正使用它。</p>
<h2 id="心中所向往的"><a href="#心中所向往的" class="headerlink" title="心中所向往的"></a>心中所向往的</h2><p>非常值得一提的是，有一个比较新的语言叫 Zig。它解决了上述提到的问腿，不仅支持编译期变量，还支持把把类型作为一等公民来进行操作。得益于 Zig 独特的<code>comptime</code>机制，被它标记的变量或代码块都是在编译期执行的。这样一来，我们就可以写出如下的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> std = @<span class="title function_ invoke__">import</span>(<span class="string">&quot;std&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_subsequence_of</span>(comptime sub: anytype, comptime <span class="keyword">super</span>: anytype) <span class="type">bool</span> &#123;</span><br><span class="line">    comptime &#123;</span><br><span class="line">        var subIndex = <span class="number">0</span>;</span><br><span class="line">        var superIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(superIndex &lt; <span class="keyword">super</span>.len and subIndex &lt; sub.len) : (superIndex += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sub[subIndex] == <span class="keyword">super</span>[superIndex]) &#123;</span><br><span class="line">                subIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subIndex == sub.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() !void &#123;</span><br><span class="line">    comptime var sub = [_] <span class="keyword">type</span> &#123; <span class="type">i32</span>, <span class="type">f32</span>, <span class="type">i64</span> &#125;;</span><br><span class="line">    comptime var <span class="keyword">super</span> = [_] <span class="keyword">type</span> &#123; <span class="type">i32</span>, <span class="type">f32</span>, <span class="type">i64</span>, <span class="type">i32</span>, <span class="type">f32</span>, <span class="type">i64</span> &#125;;</span><br><span class="line">    std.debug.<span class="title function_ invoke__">print</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, .&#123;comptime <span class="title function_ invoke__">is_subsequence_of</span>(sub, <span class="keyword">super</span>)&#125;);</span><br><span class="line"></span><br><span class="line">    comptime var sub2 = [_] <span class="keyword">type</span> &#123; <span class="type">i32</span>, <span class="type">f32</span>, <span class="type">bool</span>, <span class="type">i64</span> &#125;;</span><br><span class="line">    comptime var super2 = [_] <span class="keyword">type</span> &#123; <span class="type">i32</span>, <span class="type">f32</span>, <span class="type">i64</span>, <span class="type">i32</span>, <span class="type">f32</span> &#125;;</span><br><span class="line">    std.debug.<span class="title function_ invoke__">print</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, .&#123;comptime <span class="title function_ invoke__">is_subsequence_of</span>(sub2, super2)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写出了我们梦寐以求的代码，啊，实在是太优雅了！在对类型计算这方面 Zig 可以说是完胜目前的 C++，感兴趣的读者可以自己去 Zig 官网了解一下，不过在类型计算以外的其它方面，比如泛型和代码生成，Zig 其实做的并不好，这并不是本文的重点，所以就不讨论了。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>到这里文章就结束了，主要对 C++ 模板的不同方面进行探索和讨论。把这庞大的怪物一层层拆开后其实也没那么可怕了，也让我们更加接近它的本质。稍微总结一下吧：</p>
<ul>
<li>模板元编程并不等于编译期计算，现在的 C++ 编译期计算和运行期代码逻辑几乎一致。除非需要对类型进行计算 ，否则不需要模板元编程</li>
<li><code>requires</code>解决了 C++ 代码报错冗长的问题？<code>requires</code>的确让模板报错更加清晰了，但是并没法完全解决  C++ 报错冗长。因为另一罪魁祸首函数重载和隐式类型转换仍然存在</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C++ 成员指针完全解析</title>
    <url>/659510753/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在 C++ 中，形如<code>&amp;T::name</code>的表达式返回的结果就是成员指针。写代码的时候偶尔会用到，但是这个概念可能很多人都并不熟悉。考虑如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    *(<span class="type">int</span>*)((<span class="type">char</span>*)&amp;point + <span class="built_in">offsetof</span>(Point, x)) = <span class="number">20</span>;</span><br><span class="line">    *(<span class="type">int</span>*)((<span class="type">char</span>*)&amp;point + <span class="built_in">offsetof</span>(Point, y)) = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，我们经常通过这样计算 offset 的方式来访问结构体成员。如果把它封装成函数，还能用来根据传入的参数动态访问结构体的成员变量。然而上面的代码在 C++ 中是 undefined behavior，具体的原因可以参考 <a href="https://stackoverflow.com/questions/66800315/can-i-manually-access-fields-by-their-raw-offset-in-c">Stack Overflow</a> 上的这个讨论。但是如果我们确实有这样需求，那该怎么合法的实现需求呢？C++ 为我们提供了一层抽象：<a href="https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_members">pointers to members</a>，用来合法进行这样的操作。</p>
<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><h2 id="pointer-to-data-member"><a href="#pointer-to-data-member" class="headerlink" title="pointer to data member"></a>pointer to data member</h2><p>一个指向类<code>C</code>非静态成员<code>m</code>的成员指针可以用<code>&amp;C::m</code>进行初始化。当在<code>C</code>的成员函数里面使用<code>&amp;C::m</code>会出现二义性。即既可以指代对<code>m</code>成员取地址<code>&amp;this-&gt;m</code>，也可以指代成员指针。为此标准规定，<code>&amp;C::m</code>表示成员指针，<code>&amp;(C::m)</code>或者<code>&amp;m</code>表示对<code>m</code>成员取地址。可以通过运算符<code>.*</code>和<code>-&gt;*</code>来访问对应的成员。示例代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> C::*x1 = &amp;C::m;  <span class="comment">// pointer to member m of C</span></span><br><span class="line">        <span class="type">int</span>* x2 = &amp;(C::m);   <span class="comment">// pointer to member this-&gt;m</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> C::*p = &amp;C::m;</span><br><span class="line">    <span class="comment">// type of a member pointer is: T U::*</span></span><br><span class="line">    <span class="comment">// T is the type of the member, U is the class type</span></span><br><span class="line">    <span class="comment">// here, T is int, U is C</span></span><br><span class="line"></span><br><span class="line">    C c = &#123;<span class="number">7</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; c.*p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// same as c.m, print 7</span></span><br><span class="line"></span><br><span class="line">    C* cp = &amp;c;</span><br><span class="line">    cp-&gt;m = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; cp-&gt;*p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// same as cp-&gt;m, print 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指向基类的数据成员指针 可以隐式转换成 <strong>非虚继承</strong>的 派生类数据成员指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span> : Base &#123;&#125;;  <span class="comment">// non-virtual inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> Base &#123;&#125;;  <span class="comment">// virtual inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Base::*bp = &amp;Base::m;</span><br><span class="line">    <span class="type">int</span> Derived1::*dp = bp;   <span class="comment">// ok, implicit cast</span></span><br><span class="line">    <span class="type">int</span> Derived2::*dp2 = bp;  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    Derived1 d;</span><br><span class="line">    d.m = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; d.*dp &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d.*bp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// ok, prints 1 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据传入的指针，动态访问结构体字段</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">access</span><span class="params">(Point&amp; point, <span class="keyword">auto</span> pm)</span> </span>&#123; <span class="keyword">return</span> point.*pm; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    <span class="built_in">access</span>(point, &amp;Point::x) = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">access</span>(point, &amp;Point::y) = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; point.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; point.y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 10 20</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pointer-to-member-function"><a href="#pointer-to-member-function" class="headerlink" title="pointer to member function"></a>pointer to member function</h2><p>一个指向非静态成员函数<code>f</code>的成员指针可以用<code>&amp;C::f</code>进行初始化。由于不能对非静态成员函数取地址，<code>&amp;(C::f)</code>和<code>&amp;f</code>什么都不表示。类似的可以通过运算符<code>.*</code>和<code>-&gt;*</code>来访问对应的成员函数。如果成员函数是重载函数，想要获取对应的成员函数指针，请参考 <a href="https://en.cppreference.com/w/cpp/language/overloaded_address">如何获取重载函数的地址</a>。示例代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> F = <span class="built_in">void</span>(<span class="type">int</span>);         <span class="comment">// function type</span></span><br><span class="line">    <span class="keyword">using</span> MP = F C::*;           <span class="comment">// pointer to member function</span></span><br><span class="line">    <span class="keyword">using</span> T = <span class="built_in">void</span> (C::*)(<span class="type">int</span>);  <span class="comment">// pointer to member function</span></span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;MP, T&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mp = &amp;C::foo;</span><br><span class="line">    T mp2 = &amp;C::foo;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(mp), T&gt;);</span><br><span class="line"></span><br><span class="line">    C c;</span><br><span class="line">    (c.*mp)(<span class="number">1</span>);  <span class="comment">// call foo, print 1</span></span><br><span class="line"></span><br><span class="line">    C* cp = &amp;c;</span><br><span class="line">    (cp-&gt;*mp)(<span class="number">2</span>);  <span class="comment">// call foo, print 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指向基类的成员函数指针 可以隐式转换成<strong>非虚继承</strong>的派生类成员函数指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span> : Base &#123;&#125;;  <span class="comment">// non-virtual inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> Base &#123;&#125;;  <span class="comment">// virtual inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (Base::*bp)(<span class="type">int</span>) = &amp;Base::f;</span><br><span class="line">    <span class="built_in">void</span> (Derived1::*dp)(<span class="type">int</span>) = bp;   <span class="comment">// ok, implicit cast</span></span><br><span class="line">    <span class="built_in">void</span> (Derived2::*dp2)(<span class="type">int</span>) = bp;  <span class="comment">// error</span></span><br><span class="line">    Derived1 d;</span><br><span class="line">    (d.*dp)(<span class="number">1</span>);  <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据传入参数动态调用成员函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; std::endl;&#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; x + <span class="number">1</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">access</span><span class="params">(C&amp; c, <span class="keyword">auto</span> pm, <span class="keyword">auto</span>... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c.*pm)(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="built_in">access</span>(c, &amp;C::f, <span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">access</span>(c, &amp;C::g, <span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>首先要明确的是，C++ 标准并没有规定成员指针是什么实现的。在这一点上和虚函数一样，即标准没有规定虚函数是怎么实现的，只规定了虚函数的行为。所以成员指针相关的实现完全是 <strong>implementation defined</strong>。本来只需要了解怎么使用就足够了，不要关心底层实现。但是奈何网络上相关话题的错误文章太多了，已经严重的产生了误导，所以有必要进行澄清。</p>
<p>对于三大主流编译器，GCC 遵循 Itanium C++ ABI ，MSVC 则遵守 MSVC C++ ABI，Clang 通过不同的编译选项可以分别设置为这两种 ABI。关于 ABI 的详细讨论请移步 <a href="https://16bit-ykiko.github.io/about-me/692886292">彻底理解 C++ ABI</a> 和 <a href="https://www.zhihu.com/question/653778109/answer/3480007666">MSVC 与 GCC 产生的动态库如何才能相互替换</a>，这里不过多介绍。</p>
<ul>
<li><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#data-member-pointers">Itanium ABI</a> 具有公开的文档，之后的相关描述主要参考这个文档</li>
<li>MSVC ABI 没有公开的文档，之后的相关描述主要参考 <a href="https://rants.vastheman.com/2021/09/21/msvc/">MSVC C++ ABI Member Function Pointers</a> 这篇博客</li>
</ul>
<p><strong>请注意：文章具有时效性，未来的实现可能会改变，所以仅作参考使用。还是以官方文档为准。</strong></p>
<p>首先尝试打印一个成员指针的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123; </span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; std::endl;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> C::* p = &amp;C::m;</span><br><span class="line">    <span class="built_in">void</span> (C::* p2)(<span class="type">int</span>) = &amp;C::foo;</span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; p2 &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果都是<code>1</code>。鼠标移到<code>&lt;&lt;</code>就会发现，这是发生了到<code>bool</code>的隐式类型转换。<code>&lt;&lt;</code>并没有重载成员指针类型。想要打出它具体的值，必须要强制类型转换。</p>
<h1 id="Itanium-C-ABI"><a href="#Itanium-C-ABI" class="headerlink" title="Itanium C++ ABI"></a>Itanium C++ ABI</h1><h2 id="pointer-to-data-member-1"><a href="#pointer-to-data-member-1" class="headerlink" title="pointer to data member"></a>pointer to data member</h2><p>一般来说可以用下述结构体表示，数据成员指针。表示相对于对象首地址的偏移量。如果是<code>nullptr</code>则里面存的是<code>-1</code>。此时成员指针大小就是<code>sizeof(ptrdiff_t)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data_member_pointer</span>&#123; </span><br><span class="line">    <span class="type">ptrdiff_t</span> offset; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 C++ 标准不允许虚继承的成员函数指针转换。所以在发生类型转换的时候，编译器就可以自动算出转换需要的 offset。没有虚继承，也不需要在运行期去查虚表找 offset。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : A, B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="keyword">auto</span> mp)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;offset is &quot;</span></span><br><span class="line">              &lt;&lt; *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">ptrdiff_t</span>*&gt;(&amp;mp)</span><br><span class="line">              <span class="comment">// or use std::bit_cast after C++20</span></span><br><span class="line">              <span class="comment">// std::bit_cast&lt;std::ptrdiff_t&gt;(mp)</span></span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = &amp;A::a;</span><br><span class="line">    <span class="built_in">log</span>(a);  <span class="comment">// offset is 0</span></span><br><span class="line">    <span class="keyword">auto</span> b = &amp;B::b;</span><br><span class="line">    <span class="built_in">log</span>(b);  <span class="comment">// offset is 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> C::*c = a;</span><br><span class="line">    <span class="built_in">log</span>(c);  <span class="comment">// offset is 0</span></span><br><span class="line">    <span class="comment">// implicit cast</span></span><br><span class="line">    <span class="type">int</span> C::*c2 = b;</span><br><span class="line">    <span class="built_in">log</span>(c2);  <span class="comment">// offset is 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式有一点缺陷，在文档里面详细说明了，这里就不说了。</p>
<h2 id="pointer-to-member-function-1"><a href="#pointer-to-member-function-1" class="headerlink" title="pointer to member function"></a>pointer to member function</h2><p>在主流的平台上，一般来说可以用下述结构体表示，成员函数指针:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">member_function_pointer</span> &#123;</span><br><span class="line">    std::<span class="type">ptrdiff_t</span> ptr;  <span class="comment">// function address or vtable offset</span></span><br><span class="line">    <span class="comment">// if low bit is 0, it&#x27;s a function address, otherwise it&#x27;s a vtable offset</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> offset;  <span class="comment">// offset to the base(unless multiple inheritance, it&#x27;s always 0)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个实现依赖于一些大多数平台的假定： </p>
<ul>
<li>考虑到地址对齐，<strong>非静态成员函数的地址</strong>最低位几乎总是 0 </li>
<li>空的函数指针是 0，所以<strong>空函数指针可以和虚表偏移区分开来</strong></li>
<li>体系结构是字节寻址，并且指针大小是偶数，所以<strong>虚表偏移量是偶数</strong>，</li>
<li>只要知道虚表的地址，虚表索引和函数类型就可以进行函数调用。大多数平台上，虚表指针位于<code>this</code>处，虚表索引和函数类型（调用约定）则由编译器根据 ABI 来决定</li>
</ul>
<p>当然也有一些平台不满足上述假设，例如 ARM32 平台的某些情况，这时候它的实现方式就和我们刚才说的不同了。<strong>所以你现在应该能更加理解什么叫实现定义的行为了。即使编译器相同，目标平台不同，相关的实现都有可能不同。</strong></p>
<p>在我的环境 x86_64 windows 上，符合主流实现的要求。于是对着这个 ABI，进行了”解糖”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_pointer</span> &#123;</span><br><span class="line">    std::<span class="type">size_t</span> ptr;</span><br><span class="line">    <span class="type">ptrdiff_t</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">Ret <span class="title">invoke</span><span class="params">(<span class="type">void</span>* object, <span class="keyword">auto</span> ptr, Args... args)</span> </span>&#123;</span><br><span class="line">    member_func_pointer fp = *<span class="built_in">reinterpret_cast</span>&lt;member_func_pointer*&gt;(&amp;ptr);</span><br><span class="line">    <span class="type">bool</span> is_virtual = fp.ptr &amp; <span class="number">1</span>;  <span class="comment">// low bit</span></span><br><span class="line">    <span class="keyword">auto</span> this_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;((<span class="type">char</span>*)object + fp.offset);</span><br><span class="line">    <span class="keyword">if</span>(is_virtual) &#123;</span><br><span class="line">        <span class="keyword">auto</span> vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(object);  <span class="comment">// vptr</span></span><br><span class="line">        <span class="keyword">auto</span> fn_address = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;((<span class="type">char</span>*)vptr + fp.ptr - <span class="number">1</span>);  <span class="comment">// voffset</span></span><br><span class="line">        <span class="keyword">auto</span> func = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">Ret</span> (*)(<span class="type">void</span>*, Args...)&gt;(fn_address);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(this_ptr, args...);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> func = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">Ret</span> (*)(<span class="type">void</span>*, Args...)&gt;(fp.ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(this_ptr, args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::foo &quot;</span> &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::bar &quot;</span> &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = &#123;<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">invoke</span>&lt;<span class="type">void</span>, <span class="type">int</span>&gt;(&amp;a, &amp;A::foo, <span class="number">3</span>);  <span class="comment">// A::foo 43</span></span><br><span class="line">    <span class="built_in">invoke</span>&lt;<span class="type">void</span>, <span class="type">int</span>&gt;(&amp;a, &amp;A::bar, <span class="number">3</span>);  <span class="comment">// A::bar 43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MSVC-C-ABI"><a href="#MSVC-C-ABI" class="headerlink" title="MSVC C++ ABI"></a>MSVC C++ ABI</h1><p>MSVC 对于此的实现非常复杂，还对 C++ 标准进行了扩展。如果想要细致全面的了解，还是建议阅读上面那篇博客。</p>
<p>C++ 标准不允许虚基类成员指针向子类成员指针转换，但是 MSVC 允许。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span> : Base &#123;&#125;;  <span class="comment">// non-virtual inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> Base &#123;&#125;;  <span class="comment">// virtual inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Base::*bp = &amp;Base::m;</span><br><span class="line">    <span class="type">int</span> Derived1::*dp = bp;   <span class="comment">// ok, implicit cast</span></span><br><span class="line">    <span class="type">int</span> Derived2::*dp2 = bp;  <span class="comment">// ok in MSVC， error in GCC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了不浪费空间，即使在同一程序中 msvc 的成员指针大小也可能是不同的大小（GCC 中由于统一实现，所以都是一样大的）。MSVC 对不同情况做了不同处理。另外请注意 MSVC 对于虚继承的是实现和 Itanium 也是不一样的。详见 <a href="https://zhuanlan.zhihu.com/p/41309205">C++中虚函数、虚继承内存模型</a> 这篇文章中的相关介绍。</p>
<h2 id="pointer-to-data-member-2"><a href="#pointer-to-data-member-2" class="headerlink" title="pointer to data member"></a>pointer to data member</h2><p>对于非虚继承的情况下，实现的和 GCC 类似。除了大小有点区别。<code>64</code>位程序中 GCC 是<code>8</code>字节，MSVC 是<code>4</code>字节。都是用<code>-1</code>表示<code>nullptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data_member_pointer</span>&#123; </span><br><span class="line">    <span class="type">int</span> offset; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于虚继承的情况下（标准扩展），需要额外存储一个 voffset。用于运行期从虚表里面找到对应虚基类成员的 offset。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base3</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">virtual</span> Base, Base2, Base3 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dmp</span> &#123;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> voffset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(T mp)</span> </span>&#123;</span><br><span class="line">    dmp d = *<span class="built_in">reinterpret_cast</span>&lt;dmp*&gt;(&amp;mp);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;offset is &quot;</span> &lt;&lt; d.offset &lt;&lt; <span class="string">&quot;, voffset is &quot;</span> &lt;&lt; d.voffset &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Derived::*dp = &amp;Base::m;</span><br><span class="line">    <span class="built_in">log</span>(dp);  <span class="comment">// offset is 0, voffset is 4</span></span><br><span class="line">    dp = &amp;Base3::n;</span><br><span class="line">    <span class="built_in">log</span>(dp);  <span class="comment">// offset is 4, voffset is 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pointer-to-member-function-2"><a href="#pointer-to-member-function-2" class="headerlink" title="pointer to member function"></a>pointer to member function</h2><p>对于成员函数指针就更复杂了，有四种情况： </p>
<ul>
<li>非虚继承，非多继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">member_function_ptr</span>&#123; </span><br><span class="line">    <span class="type">void</span>* address; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>非虚继承，多继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">member_function_ptr</span>&#123; </span><br><span class="line">    <span class="type">void</span>* address;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>虚继承，多继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">member_function_ptr</span>&#123; </span><br><span class="line">    <span class="type">void</span>* address; </span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> vindex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>未知继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">member_function_ptr</span>&#123;</span><br><span class="line">    <span class="type">void</span>*   address; </span><br><span class="line">    <span class="type">int</span>     offset;</span><br><span class="line">    <span class="type">int</span>     vadjust; <span class="comment">// use to find vptr </span></span><br><span class="line">    <span class="type">int</span>     vindex; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还要注意：<code>32</code>程序中成员函数的调用约定和普通函数不一样。所以如果希望转换成函数指针并调用，需要在函数指针里面把函数调用约定写上才行，不然会导致调用失败。 </p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>讨论 C++ 问题千万不要想当然，你在特定平台上的测试结果，不代表所有可能的实现。而且 MSVC 已经告诉你了，即使是同一个程序内，你的测试也可能没有覆盖到所有的 case。之前发现 MSVC 的成员函数指针大小变来变去的时候给我吓了一跳，以外是我的代码出了问题。如果希望自己写一个类似<code>std::function</code>的容器，并希望执行 SBO 优化，最好把 SBO 大小设置在<code>16</code>字节以上，这样能覆盖掉绝大部分的成员函数指针。 </p>
<p>如果需要成员函数作为回调函数的，推荐使用 lambda 表达式包裹一层。 像下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::bar &quot;</span> &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = +[](A&amp; a, <span class="type">int</span> b) &#123; a.<span class="built_in">bar</span>(b); &#125;;</span><br><span class="line">    <span class="comment">// + is unary plus operator, use to cast a non-capturing lambda to a function pointer</span></span><br><span class="line">    <span class="comment">// f is function pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++23 之后，如果使用 <a href="https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_member_functions">explicit this</a> 定义成员函数，则<code>&amp;C::f</code>可以直接获取对应成员函数的函数指针，不需要像上面那样多一层包裹了 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> A&amp; self, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = &amp;A::bar;</span><br><span class="line"><span class="comment">// p is function pointer, rather than member function pointer</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>C++26 静态反射提案解析</title>
    <url>/661692275/</url>
    <content><![CDATA[<p>最近打算写一个系列文章详细讨论反射（reflection）这一概念，刚好 C++26 有了新的反射提案，发现知乎上又没有相关的文章，而这个话题又经常被讨论。所以借此机会来聊一聊属于 C++ 的静态反射（static reflection），作为系列预热了。</p>
<h1 id="what-is-static-reflection"><a href="#what-is-static-reflection" class="headerlink" title="what is static reflection?"></a>what is static reflection?</h1><p>首先反射是指什么呢？这个词就像计算机科学领域很多其他的惯用词一样，并没有详细而准确的定义。关于这个问题，我不打算在这个文章讨论，后续的文章我会详细的解释。本文的重点是 C++ 的 static reflection，为什么强调 static 呢？主要是因为平常我们谈论到反射的时候几乎总是指 Java，C#，Python 这些语言中的反射，而它们的实现方式无一不是把类型擦除，在运行期进行信息的查询。这种方式当然有不可避免的运行时开销，而这种开销显然是违背了 C++ zero cost abstraction 的原则的。为了和它们的反射区分开来，故加上 static 作为限定词，也指示了 C++ 的反射是在编译期完成的。当然，这种说法仍然缺乏一些严谨性。详细的讨论在后续的文章给出，你只需要知道 C++ 的静态反射和 Java，C#，Python 的反射不同，并且主要是在编译期完成的就行了。</p>
<h1 id="what-can-static-reflection-do"><a href="#what-can-static-reflection-do" class="headerlink" title="what can static reflection do?"></a>what can static reflection do?</h1><h2 id="type-as-value"><a href="#type-as-value" class="headerlink" title="type as value"></a>type as value</h2><p>我们都知道随着 C++ 版本的不断更新，编译期计算的功能在不断的增强，通过<code>constexpr/consteval</code>函数我们能很大程度上直接复用运行期的代码，方便的进行编译期计算。完全取代了很久之前使用模板元进行编译期计算的方法。不仅写起来更加方便，编译速度也更快。</p>
<p>观察下面几段编译期计算阶乘的代码：</p>
<p>在 C++03&#x2F;98 的时候，我们只能通过模板递归实例化来实现，而且无法将代码复用到运行期</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = N * factorial&lt;N - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11 中第一次引入了<code>constexpr</code>函数的概念，使得我们可以编写编译期和运行期复用的代码。但是限制很多，没有变量和循环，我们只能按照纯函数式的风格来编写代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="type">size_t</span> a = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译期计算</span></span><br><span class="line">    std::<span class="type">size_t</span>&amp; n = *<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">6</span>);</span><br><span class="line">    std::<span class="type">size_t</span> b = <span class="built_in">factorial</span>(n); <span class="comment">// 运行期计算</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着 C++14&#x2F;17 的到来，<code>constexpr</code>函数中的的限制被进一步放开，现在能在 constexpr 函数中使用局部变量和循环了，就像下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">factorial</span><span class="params">(std::<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++20 之后，我们还可以在编译期使用<code>new/delete</code>，我们可以在编译期代码里面使用<code>vector</code>。很多运行期的代码可以直接在编译期复用，而不需要任何更改，只需要在函数前面加上一个 constexpr 标记，再也不用为了进行编译期计算而使用晦涩难懂的模板元编程了。但是，上面的示例仅仅适用于 value，在 C++ 里面除了 value 还有 type 和 higher kind type</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_list</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">find_first_of</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value = find_first_of&lt;T, Ts...&gt;::value + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">find_first_of</span>&lt;T, T, Ts...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> std::<span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(find_first_of&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>, <span class="type">int</span>, <span class="type">char</span>&gt;::value == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>由于 type 和 higher kind type 只能是 template arguments，所以还是只能通过<strong>模板递归匹配</strong>处理它们。要是我们能像 value 一样操作它们就好了，这样的话 constexpr 函数也能处理它们了。但是 C++ 又不是像 Zig 那样的语言，type is value。怎么办呢？没关系，我们把 type 映射到 value 不就行了？实现 type as value 的效果。在静态反射加入之前，我们可以通过一些 trick 来实现这个效果。可以在编译期把类型映射到类型名，于是只要对类型名进行计算就好了。关于如何进行这种映射，可以参考 <a href="https://16bit-ykiko.github.io/about-me/680412313">C++ 中如何优雅进行 enum 到 string 的转换</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_list</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">find</span><span class="params">(type_list&lt;Ts...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// type_name 用于获取编译期类型名</span></span><br><span class="line">    std::array arr&#123; <span class="built_in">type_name</span>&lt;Ts&gt;()... &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="built_in">type_name</span>&lt;T&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常直观的代码，但是如果我们想把值映射回类型就比较困难了。不过没关系，在即将到来的 <strong>static reflection</strong> 中，这种类型和值的双向映射已经成为语言特性了，我们不再需要去手动处理了。</p>
<p>使用<code>^</code>运算符将类型映射到值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::meta::info value = ^<span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>[: ... :]</code>将它映射回去，注意这是 symbol 级别的映射</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Int = <span class="keyword">typename</span>[:value:]; <span class="comment">// 在此语境下，typename 可以省略</span></span><br><span class="line"><span class="keyword">typename</span>[:value:] a = <span class="number">3</span>; <span class="comment">// 相当于 int a = 3;</span></span><br></pre></td></tr></table></figure>

<p>现在我们就能写出下面这样的代码了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> std::array types = &#123;^Ts...&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="keyword">using</span> at = <span class="keyword">typename</span>[:types[N]:]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Second = <span class="keyword">typename</span> type_list&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;::at&lt;<span class="number">1</span>&gt;;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;Second, <span class="type">double</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>再也不用递归匹配了，我们可以把类型像值一样计算。只要理解了这种映射关系，代码写起来非常简单。用于类型计算的模板元可以退出历史舞台了！</p>
<p>其实<code>^</code>其实不仅能够映射类型，主要有下面这些功能: </p>
<ul>
<li><code>^::</code> —— 代表全局命名空间</li>
<li><code>^namespace-name</code>—— 命名空间名称 </li>
<li><code>^type-id</code>—— 类型 </li>
<li><code>^cast-expression</code> —— 特殊表达式，目前包括包括： <ul>
<li>表示函数或者成员函数的主表达式 </li>
<li>表示变量，静态成员变量，结构化绑定的主表达式 </li>
<li>表示非静态成员的主表达式</li>
<li>表示模板的主表达式 </li>
<li>常量表达式</li>
</ul>
</li>
</ul>
<p>同样的<code>[: ... :]</code>也能还原成对应的东西，注意是还原到对应的符号，所以这个运算符被叫做，拼接器（Splicers）</p>
<ul>
<li><code>[: r :]</code> —— 还原成对应的实体或者表达式 </li>
<li><code>typename[: r :]</code> —— 还原成对应的类型 </li>
<li><code>template[: r :]</code> —— 还原成模板参数 </li>
<li><code>namespace[: r :]</code> —— 还原成命名空间 </li>
<li><code>[:r:]::</code> —— 还原成对应的命名空间，类，枚举嵌套说明符</li>
</ul>
<p>看下面的使用示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [:^x:] = <span class="number">42</span>;     <span class="comment">// Okay.  Same as: x = 42;</span></span><br><span class="line">    x = [:^(<span class="number">2</span> * x):];  <span class="comment">// Error: &quot;2 * x&quot; is a general non-constant expression</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">42</span>;</span><br><span class="line">    x = [:^(<span class="number">2</span> * N):];  <span class="comment">// Okay: &quot;2 * N&quot; is a constant-expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还原的东西和原本储存的不一样，则会编译错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span>[: ^:: :] x = <span class="number">0</span>;  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="metainfo"><a href="#metainfo" class="headerlink" title="metainfo"></a>metainfo</h2><p>光是上面一个特性，就足以让人心动了。然而远远不止如此，获取<code>class</code>等实体元信息的功能也有了。</p>
<p>最基础的，获取类型名（变量名，字段名都可以用这个函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std::meta </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">name_of</span><span class="params">(info r)</span> -&gt; string_view</span>;</span><br><span class="line">    <span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">display_name_of</span><span class="params">(info r)</span> -&gt; string_view</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">display_name_of</span>(^std::vector&lt;<span class="type">int</span>&gt;) <span class="comment">//  =&gt; std::vector&lt;int&gt;</span></span><br><span class="line"><span class="built_in">name_of</span>(^std::vector&lt;<span class="type">int</span>&gt;) <span class="comment">// =&gt; std::vector&lt;int, std::allocator&lt;int&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>判断一个模板是不是另一个高阶模板的特化 和 萃取高阶模板里面的参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std::meta </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">template_of</span><span class="params">(info r)</span> -&gt; info</span>;</span><br><span class="line">    <span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">template_arguments_of</span><span class="params">(info r)</span> -&gt; vector&lt;info&gt;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">template_of</span>(<span class="built_in">type_of</span>(^v)) == ^std::vector);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">template_arguments_of</span>(<span class="built_in">type_of</span>(^v))[<span class="number">0</span>] == ^<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>把模板参数填到高阶模板中去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std::meta </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">substitute</span><span class="params">(info templ, span&lt;info <span class="type">const</span>&gt; args)</span> -&gt; info</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> r = <span class="built_in">substitute</span>(^std::vector, std::vector&#123;^<span class="type">int</span>&#125;);</span><br><span class="line"><span class="keyword">using</span> T = [:r:]; <span class="comment">// Ok, T is std::vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取<code>struct</code>,<code>class</code>，,<code>union</code>,<code>enum</code>的成员信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std::meta</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Fs&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">members_of</span><span class="params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Fs&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">nonstatic_data_members_of</span><span class="params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">members_of</span>(class_type, is_nonstatic_data_member, filters...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Fs&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">bases_of</span><span class="params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">members_of</span>(class_type, is_base, filters...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Fs&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">enumerators_of</span><span class="params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Fs&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">subobjects_of</span><span class="params">(info class_type, Fs ...filters)</span> -&gt; vector&lt;info&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待会用这个我们就可以实现遍历结构体，枚举等功能。进一步就可以实现序列化，反序列化等高级功能。后文会有一些示例。除此之外，还有一些其它的功能的编译期函数，上面只展示了一部分内容，更多的 API 可以参考提案中的内容。由于提供了直接获取高级模板里面参数的函数，再也不用用模板去进行类型萃取了！用于类型萃取的模板元也可以退出历史舞台了。</p>
<h1 id="better-compile-facilities"><a href="#better-compile-facilities" class="headerlink" title="better compile facilities"></a>better compile facilities</h1><p>反射的主题部分大致已经介绍完了，现在来聊聊其它的。虽然这部分是其它提案的内容，但是他们可以使代码写起来更见轻松，让代码有更强的表达能力。</p>
<h2 id="template-for"><a href="#template-for" class="headerlink" title="template for"></a>template for</h2><p>在 C++ 里面如何生成大量的代码段是一个非常不好解决的问题，得益于 C++ 独（逆）特（天）的机制，目前的代码片段生成几乎都是基于 lambda 表达式 + 可变参数包展开。看下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">dynamic_tuple_get</span><span class="params">(std::<span class="type">size_t</span> N, <span class="keyword">auto</span>&amp; tuple)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> size = std::tuple_size_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(tuple)&gt;&gt;;</span><br><span class="line">    [&amp;]&lt;std::<span class="type">size_t</span> ...Is&gt;(std::index_sequence&lt;Is...&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [&amp;]&lt;std::<span class="type">size_t</span> Index&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Index == N)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;Index&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        (f.<span class="keyword">template</span> <span class="built_in">operator</span>()&lt;Is&gt;(), ...);</span><br><span class="line">    &#125;(std::make_index_sequence&lt;size&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple tuple = &#123;<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>, <span class="number">42</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> n1 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dynamic_tuple_get</span>(n1, tuple); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">auto</span> n2 = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">dynamic_tuple_get</span>(n2, tuple); <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个很经典的例子，原理是通过多个分支判断，将运行期变量分发到编译期常量。实现根据运行期的<code>index</code>来访问<code>tuple</code>里面的元素。<strong>注：这里效率更高的办法是，编译期生成一个函数指针数组，然后直接根据index进行跳转，不过这里只是做个展示，不用纠结太多。</strong></p>
<p>上面的代码展开后相当于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">dynamic_tuple_get</span><span class="params">(std::<span class="type">size_t</span> N, <span class="keyword">auto</span>&amp; tuple)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，我们用了极其别扭的写法只是为了实现极其简单的效果。而且由于 lambda 其实是个函数，其实没法直接从 lambda 里面直接返回到上一级函数。导致我们多做了很多多余的<code>if</code>判断。</p>
<p>换成<code>template for</code>则代码看起来清爽很多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">dynamic_tuple_get</span><span class="params">(std::<span class="type">size_t</span> N, <span class="keyword">auto</span>&amp; tuple)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> size = std::tuple_size_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(tuple)&gt;&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">for</span><span class="params">(<span class="keyword">constexpr</span> <span class="keyword">auto</span> num : std::views::iota(<span class="number">0</span>, size))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == N)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;num&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以认为<code>template for</code>是 lambda 展开的语法糖加强版，反正非常好用就是了。如果这个加入了，利用模板元生成函数（代码）就可以退休了。</p>
<h2 id="non-transient-constexpr-allocation"><a href="#non-transient-constexpr-allocation" class="headerlink" title="non-transient constexpr allocation"></a>non-transient constexpr allocation</h2><p>这个提案主要是将两个问题联合起来讨论了。</p>
<ul>
<li>C++ 可以通过控制模板实例化 static 成员在数据段预留位置，可以看作编译期内存分配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span>... items&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">make_array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> type = std::<span class="type">common_type_t</span>&lt;<span class="keyword">decltype</span>(items)...&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> type value[<span class="keyword">sizeof</span> ...(items)] = &#123;items...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span>... items&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> make_array_v = make_array&lt;items...&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> arr = make_array_v&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;;</span><br><span class="line">    std::cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; std::endl; <span class="comment">//成功在数据段预留位置，存放的是 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++20 允许了<code>constexpr</code>中进行<code>new</code>，但是编译期<code>new</code>的内存必需要在编译期<code>delete</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">size</span><span class="params">(<span class="keyword">auto</span>... Is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;Is...&#125;;</span><br><span class="line">    <span class="keyword">return</span> v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那就不能在编译期<code>new</code>里之后，不<code>delete</code>？实际数据放在数据段？这就是这个提案要解决的问题，它希望我们能使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 全局的</span></span><br></pre></td></tr></table></figure>

<p>主要难点是，在数据段分配的内存不像在堆上的内存一样有所有权，不需要<code>delete</code>。只要解决了这个问题，就能使用编译期的<code>std::map</code>，<code>std::vector</code>并且保留到运行期。这个作者的做法是进行标记。具体的细节这里就不说了。如果这个加入了，利用模板元打常量表也可以退出了。</p>
<h1 id="do-something-fun"><a href="#do-something-fun" class="headerlink" title="do something fun"></a>do something fun</h1><p>好了，上面说了那么多，让我们用它们来做些有趣的东西！</p>
<h2 id="print-any-type"><a href="#print-any-type" class="headerlink" title="print any type"></a>print any type</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">for</span><span class="params">(<span class="keyword">constexpr</span> <span class="keyword">auto</span> member : nonstatic_data_members_of(type_of(^t)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_class(type_of(member)))</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 如果是 class 就递归遍历成员</span></span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;= &quot;</span>, <span class="built_in">name_of</span>(member));</span><br><span class="line">            <span class="built_in">print</span>(t.[:member:]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//非类类型可以直接打印</span></span><br><span class="line">            std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;= &#123;&#125;&quot;</span>, <span class="built_in">name_of</span>(member), t.[:member:]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum-to-string"><a href="#enum-to-string" class="headerlink" title="enum to string"></a>enum to string</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="function"><span class="keyword">requires</span> std::is_enum_v&lt;E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::string <span class="title">enum_to_string</span><span class="params">(E value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">for</span> <span class="params">(<span class="keyword">constexpr</span> <span class="keyword">auto</span> e : std::meta::members_of(^E))</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == [:e:]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">string</span>(std::meta::<span class="built_in">name_of</span>(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;unnamed&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h1><p>花费了很长的篇幅介绍 C++ 的 static reflection。其实我非常喜欢 C++ 的编译期计算，对它的发展史也非常感兴趣。C++ 的编译期计算是一步步摸索出来的，有很多富有智慧的大师提出他们的独特想法，让不可能的事情变成现实。从 C++03 的变态模板元，到 C++11 的<code>constexpr</code>变量，到 C++14 ~23 对<code>constexpr</code>函数中的限制逐渐放开，把越来越多的操作移到编译期。再到如今的 static reflection，C++ 正在逐步脱离模板元的魔爪。之前那些老旧的模板元写法全都可以淘汰掉了！！！如果你没写过以前的老式模板元代码，大概是体会不到它有多可怕的。</p>
<p>为了让静态反射能早点进入标准，作者团队特地选了原本提案的一部分核心子集。希望如作者所愿，静态反射能在 C++26 进入标准！当然，核心部分先进入，之后再补充更多更加有用的功能，所以这绝不是反射的全部内容。本文只是对该提案的粗略解读和翻译，想要详细了解的还请阅读下方链接中的提案，相关进展持续更新中：</p>
<p><a target="_blank" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html#ref-P2670R1" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R0</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html#ref-P2670R1</span></span></span></a></p>
<p><a target="_blank" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r1.html" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R1</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r1.html</span></span></span></a></p>
<p><a target="_blank" href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2024/p2996r2.html" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R2</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2024/p2996r2.html</span></span></span></a></p>
</br>

<p><a target="_blank" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r3.html" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Reflection for C++26 - P2996R3</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r3.html</span></span></span></a></p>
<p>实验编译器：</p>
<ul>
<li>在线尝试： <a href="https://godbolt.org/z/13anqE1Pa">https://godbolt.org/z/13anqE1Pa</a></li>
<li>本地构建： <a href="https://github.com/bloomberg/clang-p2996.git">clang-p2996</a></li>
</ul>
<p>反射系列文章：</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">写给 C++ 程序员的反射教程 | ykiko’s blog</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669358870</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>写给 C++ 程序员的反射教程</title>
    <url>/669358870/</url>
    <content><![CDATA[<h1 id="What-is-Reflection"><a href="#What-is-Reflection" class="headerlink" title="What is Reflection?"></a>What is Reflection?</h1><p>反射 (Reflection) 这个词相信大家都不陌生了，也许你没用过但是你一定听过。然而，就像 CS 领域很多其它的<strong>惯用词</strong>一样，对于反射，并没有一个清晰而准确的定义。于是就会出现这种情况：对于 C#, Java, Python 这些拥有反射的语言，谈论到反射可以很自然的联想到对应语言中相关的设施，API 和代码示例，非常的具体。而对于 C, C++, Rust 这些没有反射的语言，当谈论起反射的时候，大家都不确定对方指的是什么，非常的不具体。比如有人问告诉我说 Rust 有反射，他给出的例子是 Rust 的官方的文档中对 <a href="https://doc.rust-lang.org/stable/std/any/index.html">std::Any 模块</a> 的介绍。里面提到了</p>
<blockquote>
<p> Utilities for dynamic typing or type reflection 用于动态类型或类型反射的工具</p>
</blockquote>
<p>但是尴尬就尴尬在，你说它是反射吧，功能非常鸡肋，你说它不是吧，硬要说有这种体现也不是不行。</p>
<p>类似的情况在 C++ 中也经常发生。相信你也经常能听到如下观点：C++ 只有非常弱的反射即 RTTI(Run Time Type Information)，但是 C++ 的一些框架比如 QT，UE 自己实现了反射。在最近的讨论中，网上的博客中又或者 C++ 新标准的提案中，你可能又会听到所谓：</p>
<ul>
<li>静态反射 (static reflection)</li>
<li>动态反射 (dynamic reflection)</li>
<li>编译期反射 (compile time reflection)</li>
<li>运行期反射 (runtime reflection)</li>
</ul>
<p>这样一大堆名词实在是让人听的云里雾里，晕头转向。而且 static, dynamic, compile time, runtime 这些前缀词本身也都是惯用词，经常和各种词组合起来，于语境不同有非常多的含义。</p>
<p>有的读者可能会说，我查了 WIKI，<a href="https://en.wikipedia.org/wiki/Reflective_programming">反射</a> 明明就是有定义的啊，如下：</p>
<blockquote>
<p> In computer science, reflective programming or reflection is the ability of a process to examine, introspect, and modify its own structure and behavior. </br>反射是程序具有自省，检查和修改它自身结构和行为的一种能力。</p>
</blockquote>
<p>那首先，WIKI 也是人写的，不具有绝对的权威性，如果你对这个定义不满意，是可以自己修改的。其次这里的用词也是很模糊的，什么叫自省 (introspect)？自我反省，在 CS 中这个词又是什么意思呢？所以这个定义也是很尴尬的。那怎么办呢？我选择把它拆分成几个过程进行解释，这样我们就不用去纠结「<strong>反射究竟是什么</strong>」这个概念问题了。取而代之的是，弄明白了这几个过程，自然而然的你就明白反射是在做什么事情了。</p>
<h1 id="How-to-Understand-Reflection"><a href="#How-to-Understand-Reflection" class="headerlink" title="How to Understand Reflection?"></a>How to Understand Reflection?</h1><p>所有语言的反射都可以看成下面这三步：</p>
<h2 id="Generate-Metadata"><a href="#Generate-Metadata" class="headerlink" title="Generate Metadata"></a>Generate Metadata</h2><p>首先什么是元数据 (Metadata) 呢？我们在写代码的时候都会给变量，类型，结构体字段什么的取名字。这些名字主要是为了方便程序员理解和维护源代码。对于 C&#x2F;C++ 来说，这些名字在编译之后通常会被丢弃，为了节省二进制空间嘛，可以理解。详细的讨论请见 <a href="https://16bit-ykiko.github.io/about-me/670190357">为什么说 C&#x2F;C++编译器不保留元信息</a>。</p>
<p>但是渐渐地，我们发现某些情况下是需要这些数据的。比如把结构体序列化成<code>json</code>的时候就需要结构体字段名，在打印日志的时候不希望打印枚举值，而是直接打印对应的枚举名。怎么办呢？早期，只能通过 hard code 的方式，也就是手写，高级点的可能来点宏。这样其实是很不方便的，不利于后续的代码维护。</p>
<p>后来有一些语言，例如 Java 和 C#。他们的编译器在编译的时候会保留包括这些名字在内的很多数据，这些数据就叫做元数据（Metadata）。同时，也有一些手段允许程序员自己附加元数据在某些结构上，例如 C# 的<code>attribute</code>，Java 的<code>annotation</code>。</p>
<p>对于 C++ 来说呢？目前 C++ 编译器只会保留类型名用于实现 RTTI，即标准中<code>std::type_info</code>的相关设施。其它的信息，编译器都会抹除掉。怎么办呢？手动编写元数据对于少量的类来说还可以接受，但当项目规模增大时，例如有几十或上百个类时，将变得非常繁琐和容易出错。其实，我们可以在实际编译运行一个脚本来负责生成这些数据，也就是所谓的代码生成 (Code Generation)。相关内容请参考 <a href="https://16bit-ykiko.github.io/about-me/669360731">使用 clang 工具自由的支配 C++ 代码吧</a>。</p>
<h2 id="Query-Metadata"><a href="#Query-Metadata" class="headerlink" title="Query Metadata"></a>Query Metadata</h2><p>生成完之后，接下来就是查询元数据了。很多语言内置的反射模块，例如 Python 的<code>inspect</code>，Java 的<code>Reflection</code>，C# 的<code>System.Reflection</code>，其实就是封装了一些操作，使得用户不用直接接触原始的元数据，用起来更加方便。</p>
<p>值得注意的是，上面这些案例中的查询都是发生在运行时的。在运行时根据字符串进行搜索和匹配，这其实是一个比较慢的过程，所以我们常说反射调用方法比正常调用方法慢。</p>
<p>对于 C++ 来说，编译器提供了一些有限的接口让我们在编译时访问（反射）一些信息，例如使用<code>decltype</code>可以获取一个变量的类型，进一步还能判断两个变量类型是否相等，是否是某个类型的子类等等，但是功能十分有限。</p>
<p>不过，可以按照上一小节的方法自己生成元信息，把它们都标记为 constexpr，然后就可以在编译期进行查询。事实上 C++26 的静态反射也就是这个思路，由编译器生成元信息，暴露给用户一些接口进行查询。相关内容请见 <a href="https://16bit-ykiko.github.io/about-me/661692275">C++26 静态反射提案解析</a>。而查询的时机也就是所谓的<strong>动态反射</strong>和<strong>静态反射</strong>的区别。</p>
<p>当然了，编译期可做的事情肯定是没有运行期那么多的，例如希望根据运行时的类型名创建类实例，无论如何编译期肯定没法做到。但你可以基于这些静态的元信息构建动态反射。相关内容请见 <a href="https://16bit-ykiko.github.io/about-me/670191053">在 C++ 中实现 Object</a>。</p>
<h2 id="Operate-Metadata"><a href="#Operate-Metadata" class="headerlink" title="Operate Metadata"></a>Operate Metadata</h2><p>然后，就是根据元数据进行进一步的操作，比如代码生成。这个在 C++ 中可以理解为编译期的代码生成，在 Java 和 C# 则可以认为是运行期的代码生成。详见 <a href="https://16bit-ykiko.github.io/about-me/669359855">各种姿势进行代码生成</a> 。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>最后，我们来用上面三个步骤分解一下不同语言中的反射：</p>
<ul>
<li>Python, JavaScript, Java, C#：由编译器&#x2F;解释器生成元数据，标准库提供接口，用户可以在运行时查询元数据，同时由于有虚拟机（VM），可以方便地生成代码。</li>
<li>Go：由编译器生成元数据，标准库提供接口，用户可以在运行时查询元数据。但是由于 Go 主要是 AOT（Ahead-of-Time）编译，运行时生成代码并不方便。</li>
<li>Zig, C++26 静态反射：由编译器生成元数据，标准库提供接口，用户可以在编译时查询元数据。同样由于是 AOT 编译，运行时生成代码并不方便，但是可以在编译期进行代码生成。</br></li>
</ul>
<p>而 QT 和 UE 则是通过代码生成，自己生成了元数据，封装了接口，用户可以在运行时查询元数据。实现原理上类似 Go 的反射。</p>
<p>希望这个系列教程对你有所帮助！如果有错误欢迎评论区讨论，感谢你的阅读。</p>
]]></content>
  </entry>
  <entry>
    <title>各种姿势进行代码生成</title>
    <url>/669359855/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>刚好拿最近的一个需求作为引入吧。我们都知道<code>markdown</code>可以用<code>[```lang```]</code>来填入代码块，并支持代码高亮。可是我想支持自己定义的代码高亮规则，遇到了如下问题：</p>
<ul>
<li>有些网站对<code>markdown</code>渲染是静态的，不能运行脚本，所以没法直接调用那些<code>js</code>的代码高亮库。例如<code>Github</code>上面对<code>markdown</code>文件的渲染</li>
<li>究竟支持哪些语言一般是由渲染引擎决定的，比如<code>github</code>的渲染支持和<code>vscode</code>的所支持的就不同。如果要针对不同的渲染引擎写扩展，每个都得写一份，工作量太大了，而且相关的资料很少</li>
</ul>
<p>那真就没有办法了吗？唉，办法还是有的，幸好大多数引擎都支持直接用<code>html</code>的规则，比如<code>&lt;code&gt;</code>来进行渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span> <span class="attr">style</span>= <span class="string">&quot;color: #5C6370;font-style: italic;&quot;</span>&gt;</span></span><br><span class="line"># this a variable named <span class="symbol">&amp;#x27;</span>a<span class="symbol">&amp;#x27;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这为我们添加自定义样式提供了可能。但是我们写<code>markdown</code>的源文件不能手写这种代码的啊。如果一个语句有三种不同颜色，如果是<code>let a = 3;</code>这样的语句，意味着光一句话我们就得写三个不同的<code>&lt;span&gt;</code>。非常难写，后面维护起来也不好维护，</p>
<p>事实上我们可以这么做，读取<code>markdown</code>的源文件，源文件就按照正常的<code>markdown</code>语法写，然后我们在读取的时候，遇到<code>[```lang```]</code>的时候，把文本提取出来，然后交给负责渲染的库渲染成<code>dom</code>文本，我选择的是<code>highlight.js</code>这个库。然后把原来的文本替换掉，单独输出在新的文件夹里，比如原来的叫文件夹叫<code>src</code>，新的叫<code>out</code>。这样的话源文件不需要任何修改，然后实际渲染的是<code>out</code>文件夹里面的内容就好了。每次我们更改完源文件，运行一下这个程序做一下转换就行了。</p>
<h1 id="什么是Code-Generation"><a href="#什么是Code-Generation" class="headerlink" title="什么是Code Generation"></a>什么是Code Generation</h1><p>其实上面的案例就是一个典型的使用『代码生成』也即<code>code generation</code>解来决问题的案例。那究竟什么是代码生成呢？这其实也是一个含义相当广泛的词汇。一般来说</p>
<blockquote>
<p> 代码生成是指是指通过使用计算机程序来生成其他程序或代码的过程</p>
</blockquote>
<p>包括但不限于： </p>
<ul>
<li>编译器生成目标代码： 这是最典型的例子，其中编译器将高级编程语言的源代码翻译成机器可执行的目标代码</li>
<li>使用配置文件或<code>DSL</code>生成代码：通过特定的配置文件或领域特定语言（DSL），生成实际的代码。一个示例是使用<code>XML</code>配置文件来定义<code>UI</code>界面，然后生成相应的代码 </li>
<li>语言内建特性生成代码： 一些编程语言具有内建的特性，如宏、泛型等，可以在编译时或运行时生成代码。这样的机制可以提高代码的灵活性和重用性。 </li>
<li>外部代码生成器： 某些框架或库使用外部代码生成器来创建所需的代码。例如，Qt框架使用元对象编译器（MOC）来处理元对象系统，生成与信号和槽相关的代码。</li>
</ul>
<p>下面就这几点来举一些具体的例子：</p>
<h1 id="编译时代码生成"><a href="#编译时代码生成" class="headerlink" title="编译时代码生成"></a>编译时代码生成</h1><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p><code>C</code>语言的<code>marco</code>就是一种最经典，也最简单的编译期代码生成技术。纯文本替换，比如我们想重复<code>&quot;Hello World&quot;</code>这个字符串<code>100</code>次。那怎么办呢？显然我们不想手动粘贴复制。考虑使用宏来完成这个工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REPEAT(x) (REPEAT1(x) REPEAT1(x) REPEAT1(x) REPEAT1(x) REPEAT1(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REPEAT1(x) REPEAT2(x) REPEAT2(x) REPEAT2(x) REPEAT2(x) REPEAT2(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REPEAT2(x) x x x x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = REPEAT(<span class="string">&quot;Hello world &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要运用了<code>C</code>语言中的一个特性就是<code>&quot;a&quot;&quot;b&quot;</code>等价于<code>&quot;ab&quot;</code>。然后通过宏展开<code>5*5*4</code>刚好一百次，然后就轻松的完成了这个任务。 当然了<code>C</code>语言的宏由于其本质上只是<code>Token</code>替换，而且不允许使用者获取<code>Token</code>流进行输入分析，所以功能十分有限。尽管如此，还是有一些比较有意思的用法的。感兴趣的可以阅读下这篇文章<a href="https://zhuanlan.zhihu.com/p/152354031">C&#x2F;C++ 宏编程的艺术</a>。当然了宏可不止<code>C</code>语言有，其它的编程语言也是有的，而且还可以支持更强的特性。例如<code>Rust</code>中的宏灵活性就比<code>C</code>语言强很多，关键就在于<code>Rust</code>允许你对输入的<code>Token Stream</code>进行分析，而不是简简单单的执行替换了，你可以根据输入<code>Token</code>的不同选择生成不同的代码。更有甚者像<code>Lisp</code>中的宏就超级灵活了。</p>
<h2 id="泛型-模板"><a href="#泛型-模板" class="headerlink" title="泛型&#x2F;模板"></a>泛型&#x2F;模板</h2><p>在一些编程语言中<code>generic</code>也被看作是一种代码生成的技术，根据不同的类型生成实际不同的代码。当然这是最基础的了，一些编程语言还支持更强大的特性，比如在<code>C++</code>中还可以通过模板元编程进行一些高级的代码生成。典型的案例是在编译期打一个函数指针表（跳转表）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> N, <span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(T t, F f)</span> </span>&#123; <span class="built_in">f</span>(std::<span class="built_in">get</span>&lt;N&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tuple, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">access</span><span class="params">(std::<span class="type">size_t</span> index, Tuple&amp;&amp; tuple, Func&amp;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> length = std::tuple_size&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(tuple)&gt;&gt;::value;</span><br><span class="line">    <span class="keyword">using</span> FuncType = <span class="built_in">void</span> (*)(<span class="keyword">decltype</span>(tuple), <span class="keyword">decltype</span>(f));</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> fn_table = []&lt;std::<span class="type">size_t</span>... I&gt;(std::index_sequence&lt;I...&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;FuncType, length&gt; table = &#123; helper&lt;I, <span class="keyword">decltype</span>(tuple), <span class="keyword">decltype</span>(f)&gt;... &#125;;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;(std::make_index_sequence&lt;length&gt;&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> fn_table[index](std::forward&lt;Tuple&gt;(tuple), std::forward&lt;Func&gt;(f));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple a = &#123; <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;123&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; v) &#123; std::cout &lt;&lt; v &lt;&lt; std::endl; &#125;;</span><br><span class="line">    std::<span class="type">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">access</span>(index, a, f); <span class="comment">// =&gt; 1</span></span><br><span class="line">    index = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">access</span>(index, a, f); <span class="comment">// =&gt; 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了根据运行期的<code>index</code>来访问<code>tuple</code>中的元素的效果了，具体原理就是手动打了一个函数指针表，然后根据索引来进行分派。</p>
<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>上面两点说的都是语言内建的特性。然而在很多场景，语言内置的特性，不够灵活，并不能满足我们的需求。比如在<code>C++</code>中想整块整块的生成函数和类型，那么无论是宏还是模板都做不到。</p>
<p>但是代码就是源文件中的字符串而已，基于这一点想法。我们完全可以编写一个专门的程序用来生成这样的字符串。例如写一个<code>python</code>代码来生成上面那个<code>100</code>次<code>Hello World</code>的<code>C</code>程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    s += <span class="string">&#x27;&quot;Hello World &quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;&#123;</span></span><br><span class="line"><span class="string">    const char* str = &quot;<span class="subst">&#123;s&#125;</span>&quot;;</span></span><br><span class="line"><span class="string">&#125;&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.c&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(code)</span><br></pre></td></tr></table></figure>

<p>好了，这样的话就生成了上面那个源文件。当然这只是最简单的应用。亦或者我们可以用<code>Protocol Buffer</code>来进行自动生成序列化和反序列化的代码。又或者我们可以从<code>AST</code>中获取信息，连类型的元信息都由代码生成器生成，这种程序的原理很简单，就是字符串拼接，而它的上限完全取决于你的代码是怎么写的。</p>
<p>但是更多时候还是语言内建的特性使用的更加方便一些，使用外部的代码生成器会让编译流程变得复杂一些。然而也有一些语言，将这个特性作为了语言内置的特性之一，比如<code>C#</code>的<a href="https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview">code generation</a>。</p>
<h1 id="运行期代码生成"><a href="#运行期代码生成" class="headerlink" title="运行期代码生成"></a>运行期代码生成</h1><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>好了，说了很多静态语言的特征。接下来让我们来看看足够动态的代码生成。 首先向我们走来的是<code>Python/JavaScript</code>等语言中的<code>eval</code>和<code>exec</code>等特性，这些特性允许我们在运行期直接把字符串加载为了代码并执行</p>
<ul>
<li><code>eval</code>是一种将字符串解析为可执行代码的机制。在<code>Python</code>中，<code>eval</code>函数可以接受一个字符串作为参数，并执行其中的表达式，返回结果。这为动态计算和代码生成提供了强大的工具。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = <span class="built_in">eval</span>(<span class="string">&quot;2 + 3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>exec</code>与<code>eval</code>不同的是，<code>exec</code>可以执行多个语句，甚至包含函数和类的定义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line">code_block = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def multiply(x, y):</span></span><br><span class="line"><span class="string">    return x * y</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">result = multiply(4, 5)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">exec</span>(code_block)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 20</span></span><br></pre></td></tr></table></figure>

<p>毫无疑问，仅仅通过字符串拼接就能在运行期生成代码，在合适的场景使用它们，可以轻松完成一些比较苛刻的需求。</p>
<h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><p>现在有一个问题，<code>C</code>语言能做到上面的动态编译特性吗？当然你可能会说我们可以实现一个<code>C</code>语言的解释器，那自然不就行了。但其实其实有更简单的办法。</p>
<p>主要有两点：</p>
<ul>
<li><strong>运行期编译代码</strong></li>
</ul>
<p>如果你的电脑上装了<code>gcc</code>，则可以通过下面运行两条命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将源文件编译成目标文件</span></span><br><span class="line">gcc -c source.c source.o </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目标文件中的.text段提取出来，生成二进制文件</span></span><br><span class="line">objcopy -O binary -j .text source.o source.bin</span><br></pre></td></tr></table></figure>

<p>通过这样的方式就能获取<code>source.c</code>文件中代码的二进制形式了，但是光有代码还不行，我们需要执行它。</p>
<ul>
<li>**申请可执行内存 **</li>
</ul>
<p>代码也是二进制数据，只要把刚才得到的代码数据写入一块内存，然后<code>jmp</code>过去执行不就行了？想法很直接，但是很遗憾，大多数操作系统对内存都是有保护的，一般的申请内存是不可执行的。如果尝试写入数据然后执行则会直接段错误。但是我们可以通过<code>VirtualAlloc</code>或者<code>mmap</code>来申请一块有执行权限内存，然后把代码写入进去，再执行就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Windows</span></span><br><span class="line"><span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>结合这两点然后稍作处理，就可以实现从命令行读取代码和输入，然后直接运行输出结果了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Alloc(size) VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Alloc(size) mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">ofstream</span>(<span class="string">&quot;source.c&quot;</span>) &lt;&lt; argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;gcc -c source.c &amp;&amp; objcopy -O binary -j .text source.o source.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;source.bin&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">source</span><span class="params">((std::istreambuf_iterator&lt;<span class="type">char</span>&gt;(file)), &#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">Alloc</span>(source.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">memcpy</span>(p, source.<span class="built_in">c_str</span>(), source.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Fn = <span class="built_in">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;Fn&gt;(p)(std::<span class="built_in">stoi</span>(argv[<span class="number">2</span>]), std::<span class="built_in">stoi</span>(argv[<span class="number">3</span>])) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\main.exe <span class="string">&quot;int f(int a, int b)&#123; return a + b; &#125;&quot;</span> 1 2</span><br><span class="line"><span class="comment">#  output: 3</span></span><br><span class="line"></span><br><span class="line">.\main.exe <span class="string">&quot;int f(int a, int b)&#123; return a - b; &#125;&quot;</span> 1 2</span><br><span class="line"><span class="comment">#  output: -1</span></span><br></pre></td></tr></table></figure>

<p>完美实现</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>本文主要介绍了代码生成的一些基本概念和示例，以及一些简单的应用。代码生成是一种非常强大的技术，如果仅仅把眼光局限在编程语言内建的特性，很多时候我们无法完成一些复杂的需求，如果将眼光放宽广一些，则会意外发现新世界。这是反射系列文章中的一篇，欢迎阅读系列其它文章！</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">YKIKO：写给 C++ 程序员的反射教程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669358870</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>使用 Clang 工具自由的支配 C++ 代码吧</title>
    <url>/669360731/</url>
    <content><![CDATA[<p>Clang 是 LLVM 项目提供的一个 C 语言家族的编译器前端。它最初开发的目的是替代 GNU Compiler Collection (GCC) 的 C 语言前端，目标是提供更快的编译速度、更好的诊断信息和更灵活的架构。Clang 包含一个 C、C++ 和 Objective-C 编译器前端，这些前端设计为可以嵌入到其他项目中。Clang 的一个重要特点是其模块化架构，使开发者能够更轻松地扩展和定制编译器的功能。Clang 被广泛应用于许多项目，包括 LLVM 自身、一些操作系统内核的开发以及一些编程语言的编译器实现。</p>
<p>除了作为编译器使用之外，Clang 还可以作为一个库提供，使开发者能够在其应用程序中利用编译器的功能，例如源代码分析和生成。Clang 可以用来获取 C++ 源文件的抽象语法树 (AST)，以便进一步处理这些信息。本文将介绍如何使用 Clang 工具。</p>
<h1 id="Installation-Usage"><a href="#Installation-Usage" class="headerlink" title="Installation &amp; Usage"></a>Installation &amp; Usage</h1><p>目前，Clang 被划分为以下库和工具：libsupport、libsystem、libbasic、libast、liblex、libparse、libsema、libcodegen、librewrite、libanalysis。由于 Clang 本身是用 C++ 编写的，所以相关的接口都是 C++ 的。然而，由于 C++ 接口本身的复杂性和不稳定性（例如：在 Windows 上由 GCC 编译出来的 DLL 无法给 MSVC 使用，或者 Clang 自身版本升级导致 API 变动，从而出现不兼容性），官方并不推荐优先使用 C++ 接口。</p>
<p>除了 C++ 接口之外，官方还提供了一个叫做 <a href="https://clang.llvm.org/doxygen/group__CINDEX.html">libclang</a> 的 C 语言接口，这个接口不仅使用起来相对简单，而且本身也比较稳定。唯一的缺点是无法获取完整的 C++ 抽象语法树 (AST)，不过鉴于 C++ 完整的语法树本身就极度复杂，很多时候我们只需要其中的一小部分信息，所以这个问题通常可以忽略，除非你真的有这方面的需求。</p>
<p>如果你想要使用 libclang，你需要先安装 LLVM 和 Clang。在 <a href="https://github.com/llvm/llvm-project/releases">LLVM Release</a> 页面，有若干预发布的二进制包可以下载。如果你有定制化需求，请参考 <a href="https://llvm.org/docs/GettingStarted.html#id4">Getting Started</a> 页面进行手动编译。安装完成后，只需将<code>llvm/lib</code>目录下的<code>libclang.dll</code>链接到程序中，并包含<code>llvm/include</code>目录下的<code>clang-c/Index.h</code>头文件即可使用。</p>
<p>然而，由于 C 语言没有一些高级抽象，操作字符串都很麻烦。如果大规模使用，还需要我们自己用 C++ 封装一层。幸好，官方基于这套 C 接口还提供了一个 Python 绑定，即 <a href="https://pypi.org/project/clang/">clang</a> 这个包，这使得使用起来更加方便。然而，官方提供的 Python 绑定并没有打包 libclang 的这个 DLL，因此你仍然需要在电脑上手动配置 LLVM 的环境，这可能会有些麻烦。不过，社区中有人在 PyPI 上提供了打包好的包：<a href="https://pypi.org/project/libclang/">libclang</a>。</p>
<p>于是如果你想使用 libclang 来获取 C++ 语法树，只需要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install libclang</span><br></pre></td></tr></table></figure>

<p>什么额外的事情都不用做。本文就基于这个 python binding 的版本进行介绍。C 版本的 API 和 Python 版本的 API 基本是完全一致的，如果你觉得 Python 性能不够，你也可以参考这个教程对照着写 C 版本的代码。另外官方提供的包并没有 type hint，这样的话用 Python 写就没有代码补全，用起来也不舒服。我自己补了一个类型提示的 <a href="https://github.com/16bit-ykiko/about-me/blob/main/code/cindex.pyi">cindex.pyi</a>，下载下来之后直接和 放在同一文件夹内就能有代码提示了。</p>
<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>示例的 C++ 源文件代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = &#123;<span class="number">1</span>, <span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析它的 Python 代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clang.cindex <span class="keyword">as</span> CX</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: CX.Cursor, prefix=<span class="string">&quot;&quot;</span>, is_last=<span class="literal">True</span></span>):</span><br><span class="line">    branch = <span class="string">&quot;└──&quot;</span> <span class="keyword">if</span> is_last <span class="keyword">else</span> <span class="string">&quot;├──&quot;</span></span><br><span class="line">    text = <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(node.kind).removeprefix(<span class="string">&#x27;CursorKind.&#x27;</span>)&#125;</span>: <span class="subst">&#123;node.spelling&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.kind == CX.CursorKind.INTEGER_LITERAL:</span><br><span class="line">        value = <span class="built_in">list</span>(node.get_tokens())[<span class="number">0</span>].spelling</span><br><span class="line">        text = <span class="string">f&quot;<span class="subst">&#123;text&#125;</span><span class="subst">&#123;value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;branch&#125;</span> <span class="subst">&#123;text&#125;</span>&quot;</span>)</span><br><span class="line">    new_prefix = prefix + (<span class="string">&quot;    &quot;</span> <span class="keyword">if</span> is_last <span class="keyword">else</span> <span class="string">&quot;│   &quot;</span>)</span><br><span class="line">    children = <span class="built_in">list</span>(node.get_children())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> children:</span><br><span class="line">        traverse(child, new_prefix, child <span class="keyword">is</span> children[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = CX.Index.create(excludeDecls=<span class="literal">True</span>)</span><br><span class="line">tu = index.parse(<span class="string">&#x27;main.cpp&#x27;</span>, args=[<span class="string">&#x27;-std=c++20&#x27;</span>])</span><br><span class="line">traverse(tu.cursor)</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TRANSLATION_UNIT: main.cpp</span><br><span class="line">├── STRUCT_DECL: Person</span><br><span class="line">│   ├── FIELD_DECL: age</span><br><span class="line">│   └── FIELD_DECL: name</span><br><span class="line">└── FUNCTION_DECL: main</span><br><span class="line">    └── COMPOUND_STMT:</span><br><span class="line">        ├── DECL_STMT:</span><br><span class="line">        │   └── VAR_DECL: person</span><br><span class="line">        │       ├── TYPE_REF: struct Person</span><br><span class="line">        │       └── INIT_LIST_EXPR:</span><br><span class="line">        │           ├── INTEGER_LITERAL: 1</span><br><span class="line">        │           └── STRING_LITERAL: <span class="string">&quot;John&quot;</span></span><br><span class="line">        └── RETURN_STMT:</span><br><span class="line">            └── INTEGER_LITERAL: 0</span><br></pre></td></tr></table></figure>

<p>前面的是语法树节点类型，后面是节点的内容。可以发现还是非常清晰的，几乎能和源代码一一对应。</p>
<h1 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h1><p>注意，本文假定读者对语法树有一定的认识，不在这里做过多介绍了。如果不知道语法树是什么的话，可以看一下 <a href="https://16bit-ykiko.github.io/about-me/670190357">为什么说 C&#x2F;C++ 编译器不保留元信息</a>。下面对 cindex 中的一些常用类型做一些介绍</p>
<h2 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h2><p>相当于语法树的基本节点，整个语法树都是由<code>Cursor</code>组成的。通过<code>kind</code>属性返回一个<code>CursorKind</code>类型枚举值，就代表了这个节点实际对应的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> kind <span class="keyword">in</span> CursorKind.get_all_kinds():</span><br><span class="line">    <span class="built_in">print</span>(kind)</span><br></pre></td></tr></table></figure>

<p>这样可以打印出所有支持的节点类型，也可以直接去源码查看。<code>Cursor</code>还有一些其它的属性和方法让我们使用，常用的有如下这些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spelling</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">displayname</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mangled_name</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br></pre></td></tr></table></figure>

<p>获取节点的名字，例如一个变量声明的节点，它的<code>spelling</code>就是这个变量的名字。而<code>displayname</code>则是节点的简短名字，大多数时候和<code>spelling</code>是一样的。但是有些时候会有区别，例如一个函数的<code>spelling</code>会带上参数类型，例如<code>func(int)</code>，但是它的<code>displayname</code>就只是<code>func</code>。而<code>mangled_name</code>就是该符号经过 name mangling 之后用于链接的名字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type</span>(<span class="params">self</span>) -&gt; <span class="type">Type</span>:</span><br></pre></td></tr></table></figure>

<p>节点元素的类型，例如一个变量声明的节点，它的<code>type</code>就是这个变量的类型。或者一个字段声明的节点，它的<code>type</code>就是这个字段的类型。返回类型为<code>Type</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">location</span>(<span class="params">self</span>) -&gt; SourceLocation:</span><br></pre></td></tr></table></figure>

<p>节点的位置信息，返回类型为<code>SourceLocation</code>，其中携带了该节点在源码中的行数，列数，文件名等信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extent</span>(<span class="params">self</span>) -&gt; SourceRange:</span><br></pre></td></tr></table></figure>

<p>节点的范围信息，返回类型为<code>SourceRange</code>，由两个<code>SourceLocation</code>组成，其中携带了该节点在源码中的起始位置和结束位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">access_specifier</span>(<span class="params">self</span>) -&gt; AccessSpecifier:</span><br></pre></td></tr></table></figure>

<p>节点的访问权限，返回类型为<code>AccessSpecifier</code>。有<code>PUBLIC</code>, <code>PROTECTED</code>, <code>PRIVATE</code>, <code>NONE</code>, <code>INVALID</code>五种。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_children</span>(<span class="params">self</span>) -&gt; iterable[Cursor]:</span><br></pre></td></tr></table></figure>

<p>获取所有子节点，返回类型为<code>Cursor</code>的<code>iterable</code>。这个函数是最常用的，因为我们可以通过递归的方式遍历整个语法树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_tokens</span>(<span class="params">self</span>) -&gt; iterable[Token]:</span><br></pre></td></tr></table></figure>

<p>获取代表该节点的所有<code>token</code>，返回类型为<code>Token</code>的<code>iterable</code>。<code>token</code>是语法树的最小单位，例如一个变量声明的节点，它的<code>token</code>就是<code>int</code>，<code>a</code>，<code>;</code>这三个。这个函数可以用来获取一些细节信息，例如获取整数字面量和浮点数字面量的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_definition</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_const_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_converting_constructor</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_copy_constructor</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_default_constructor</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_move_constructor</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_default_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_deleted_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_copy_assignment_operator_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_move_assignment_operator_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_mutable_field</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pure_virtual_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_static_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_virtual_method</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_abstract_record</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_scoped_enum</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br></pre></td></tr></table></figure>

<p>这些函数基本就见名知意了，例如<code>is_definition</code>就是判断该节点是否是一个定义，<code>is_const_method</code>就是判断该节点是否是一个<code>const</code>方法。</p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>如果该节点有类型的话，代表该节点的类型。常用的属性有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kind</span>(<span class="params">self</span>) -&gt; TypeKind:</span><br></pre></td></tr></table></figure>

<p>类型的类型，返回类型为<code>TypeKind</code>。例如<code>INT</code>, <code>FLOAT</code>, <code>POINTER</code>, <code>FUNCTIONPROTO</code>等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spelling</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br></pre></td></tr></table></figure>

<p>类型的名字，例如<code>int</code>, <code>float</code>, <code>void</code>等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_align</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_offset</span>(<span class="params">self, fieldname: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br></pre></td></tr></table></figure>

<p>获取类型的对齐，大小，字段偏移量等等。</p>
<p>以及一些<code>is</code>开头的函数，例如<code>is_const_qualified</code>, <code>is_function_variadic</code>, <code>is_pod</code>等等。这里也就不多说了。</p>
<h2 id="TranslationUnit"><a href="#TranslationUnit" class="headerlink" title="TranslationUnit"></a>TranslationUnit</h2><p>一般来说一个 C++ 源文件就代表一个<code>TranslationUnit</code>，也就是我们常说的编译单元。</p>
<p>常用的有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cursor</span>(<span class="params">self</span>) -&gt; Cursor:</span><br></pre></td></tr></table></figure>

<p>获取该<code>TranslationUnit</code>的根节点，也就是<code>TRANSLATION_UNIT</code>类型的<code>Cursor</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spelling</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br></pre></td></tr></table></figure>

<p>获取该<code>TranslationUnit</code>的文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_includes</span>(<span class="params">self, depth: <span class="built_in">int</span> = -<span class="number">1</span></span>) -&gt; iterable[FileInclusion]:</span><br></pre></td></tr></table></figure>

<p>获取该<code>TranslationUnit</code>的所有<code>include</code>，返回类型为<code>FileInclusion</code>的<code>list</code>，注意由于<code>include</code>的文件里面可能还会包含别的文件所以，可以用<code>depth</code>这个参数来限制，比如我只想获取第一层也就是直接包含的头文件可以这么写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = CX.Index.create()</span><br><span class="line">tu = index.parse(<span class="string">&#x27;main.cpp&#x27;</span>, args=[<span class="string">&#x27;-std=c++20&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> tu.get_includes():</span><br><span class="line">    <span class="keyword">if</span> file.depth == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(file.include.name)</span><br></pre></td></tr></table></figure>

<p>这样就会打印出所有直接使用的头文件了。</p>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>一个<code>Index</code>就是一个<code>TranslationUnit</code>的集合，并且最终被链接到一起，形成一个可执行文件或者库。</p>
<p>有一个静态方法<code>create</code>用于创建一个新的<code>Index</code> ，然后成员方法<code>parse</code>可以解析一个<code>C++</code>源文件，返回一个<code>TranslationUnit</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">                args: <span class="built_in">list</span>[<span class="built_in">str</span>] | <span class="literal">None</span> = ...,</span></span><br><span class="line"><span class="params">                unsaved_files: <span class="built_in">list</span>[<span class="built_in">tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]] | <span class="literal">None</span> = ...,</span></span><br><span class="line"><span class="params">                options: <span class="built_in">int</span> = ...</span>) -&gt; TranslationUnit:</span><br></pre></td></tr></table></figure>

<p><code>path</code>是源文件路径，<code>args</code>是编译参数，<code>unsaved_files</code>是未保存的文件，<code>options</code>是一些定义在<code>TranslationUnit.PARSE_XXX</code>中的参数，例如<code>PARSE_SKIP_FUNCTION_BODIES</code>和<code>PARSE_INCOMPLETE</code>。可以用来定制化解析过程，加快解析速度，或者保留宏信息等。</p>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>由于 clang 在解析的时候会把所有的头文件都展开，全部输出内容太多了。但是我们主要可能只是想要我们自己代码的信息，这时候就可以利用命名空间进行筛选了。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> local &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        std::string name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clang.cindex <span class="keyword">as</span> CX</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_my</span>(<span class="params">node: CX.Cursor</span>):</span><br><span class="line">    <span class="keyword">if</span> node.kind == CX.CursorKind.NAMESPACE:</span><br><span class="line">        <span class="keyword">if</span> node.spelling == <span class="string">&quot;local&quot;</span>:</span><br><span class="line">            traverse(node) <span class="comment"># forward to the previous function</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">        traverse_my(child)</span><br><span class="line"></span><br><span class="line">index = CX.Index.create()</span><br><span class="line">tu = index.parse(<span class="string">&#x27;main.cpp&#x27;</span>, args=[<span class="string">&#x27;-std=c++20&#x27;</span>])</span><br><span class="line">traverse_my(tu.cursor)</span><br></pre></td></tr></table></figure>

<p>写一个函数对类型空间名进行筛选，然后转发到我们之前那个函数就行，这样就只会输出我们想要的的命名空间里面的内容了。</p>
<h2 id="Class-Struct"><a href="#Class-Struct" class="headerlink" title="Class &amp; Struct"></a>Class &amp; Struct</h2><p>我们主要是获取它们里面的字段名，类型，方法名，类型等，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_class</span>(<span class="params">node: CX.Cursor</span>):</span><br><span class="line">    <span class="keyword">match</span> node.kind:</span><br><span class="line">        <span class="keyword">case</span> CX.CursorKind.STRUCT_DECL | CX.CursorKind.CLASS_DECL:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Class: <span class="subst">&#123;node.spelling&#125;</span>:&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> CX.CursorKind.FIELD_DECL:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Field: <span class="subst">&#123;node.spelling&#125;</span>: <span class="subst">&#123;node.<span class="built_in">type</span>.spelling&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> CX.CursorKind.CXX_METHOD:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Method: <span class="subst">&#123;node.spelling&#125;</span>: <span class="subst">&#123;node.<span class="built_in">type</span>.spelling&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> arg <span class="keyword">in</span> node.get_arguments():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;        Param: <span class="subst">&#123;arg.spelling&#125;</span>: <span class="subst">&#123;arg.<span class="built_in">type</span>.spelling&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">        traverse_class(child)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Class: Person:</span></span><br><span class="line"><span class="comment">#     Field: age: int</span></span><br><span class="line"><span class="comment">#     Field: name: const char *</span></span><br><span class="line"><span class="comment">#     Method: say_hello: void (int, char)</span></span><br><span class="line"><span class="comment">#         Param: a: int</span></span><br><span class="line"><span class="comment">#         Param: b: char</span></span><br></pre></td></tr></table></figure>

<h2 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h2><p>可以获取 Doxygen 风格的注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">brief_comment</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raw_comment</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br></pre></td></tr></table></figure>

<p><code>brief_comment</code>获取<code>@brief</code>后面的内容，<code>raw_comment</code>获取整个注释的内容。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief func description</span></span><br><span class="line"><span class="comment"> * @param param1</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param1 + <span class="number">10000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_comment</span>(<span class="params">node: CX.Cursor</span>):</span><br><span class="line">    <span class="keyword">if</span> node.brief_comment:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;brief_comment =&gt; <span class="subst">&#123;node.brief_comment&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> node.raw_comment:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;raw_comment =&gt; <span class="subst">&#123;node.raw_comment&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">        traverse_comment(child)</span><br><span class="line"></span><br><span class="line"><span class="comment"># brief_comment =&gt; func description</span></span><br><span class="line"><span class="comment"># raw_comment =&gt; /**</span></span><br><span class="line"><span class="comment">#  * @brief func description</span></span><br><span class="line"><span class="comment">#  * @param param1</span></span><br><span class="line"><span class="comment">#  * @return int</span></span><br><span class="line"><span class="comment">#  */</span></span><br></pre></td></tr></table></figure>

<h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>获取枚举名以及对应的枚举常量值，还有它的底层类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    RED = <span class="number">0</span>,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_enum</span>(<span class="params">node: CX.Cursor</span>):</span><br><span class="line">    <span class="keyword">if</span> node.kind == CX.CursorKind.ENUM_DECL:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;enum: <span class="subst">&#123;node.spelling&#125;</span>, underlying type: <span class="subst">&#123;node.enum_type.spelling&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;is scoped?: <span class="subst">&#123;node.is_scoped_enum()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    enum_value: <span class="subst">&#123;child.spelling&#125;</span>: <span class="subst">&#123;child.enum_value&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">        traverse_enum(child)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enum: Color, underlying type: int</span></span><br><span class="line"><span class="comment"># is scoped?: True</span></span><br><span class="line"><span class="comment">#     enum_value: RED: 0</span></span><br><span class="line"><span class="comment">#     enum_value: GREEN: 1</span></span><br><span class="line"><span class="comment">#     enum_value: BLUE: 2</span></span><br></pre></td></tr></table></figure>

<h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><p>C++11 加入了新的 attribute 语法：<code>[[ ... ]]</code>，可以用来给函数或者变量添加额外的信息。例如<code>[[nodiscard]]</code>和<code>[[deprecated]]</code>。但是我们有时候在自己定义一些标记来给我们的与预处理工具使用，比如标记一个类型需要不需要生成元信息，我们也希望这些标记也能被 libclang 识别出来。但是遗憾的是如果直接写不被标准支持的属性会被 libclang 忽略，也就是最终的 AST 中是没有它的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> [[Reflect]] Person&#123;&#125;; <span class="comment">// ignored</span></span><br></pre></td></tr></table></figure>

<p>一个可行的解决办法是利用<code>get_tokens</code>获取声明中的所有<code>token</code>，然后自己裁剪出来。比如这里获取到的结果就是<code>struct</code>,<code>[</code>,<code>[</code>,<code>Reflect</code>,<code>]</code>,<code>]</code>,<code>Person</code>,<code>&#123;</code>,<code>&#125;</code>，我们可以从中获取出我们想要的信息。</p>
<p>但是 clang 给我们提供了一种更好的办法。那就是利用<code>clang::annotate(...)</code>这个 clang 的扩展属性，例如像下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Reflect clang::annotate(<span class="string">&quot;reflect&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> [[Reflect]] A &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样对于<code>A</code>这个<code>Cursor</code>来说，它的子节点中就会有一个<code>ANNOTATE_ATTR</code>的类型的<code>Cursor</code>，而<code>spelling</code>就是里面存的信息，这里就是<code>reflect</code>。这样我们就可以很方便的获取到我们自定义的属性了。而且 C++ 标准规定了，当编译器遇到一个不认识的 attribute 的时候，它会忽略这个 attribute，而不是报错。这样的话，这个属性它就只作用于我们的预处理器，不会影响到正常编译。</p>
<h2 id="Macro"><a href="#Macro" class="headerlink" title="Macro"></a>Macro</h2><p>clang 在实际解析语法树之前，会把所有的预处理指令都替换成实际的代码。所以最后的语法树信息中就没有它们了。但是有些时候我们的确想要获取到这些信息，比如我们想要获取到<code>#define</code>的信息，这里需要把<code>parse</code>的<code>options</code>参数设为<code>TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD</code>。如果想要获取宏的内容就用<code>get_tokens</code>就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(a, b) a#b</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">CONCAT</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>解析代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_macro</span>(<span class="params">node: CX.Cursor</span>):</span><br><span class="line">    <span class="keyword">if</span> node.kind == CX.CursorKind.MACRO_DEFINITION:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.spelling.startswith(<span class="string">&#x27;_&#x27;</span>):  <span class="comment"># Exclude internal macros</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;MACRO: <span class="subst">&#123;node.spelling&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>([token.spelling <span class="keyword">for</span> token <span class="keyword">in</span> node.get_tokens()])</span><br><span class="line">    <span class="keyword">elif</span> node.kind == CX.CursorKind.MACRO_INSTANTIATION:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;MACRO_INSTANTIATION: <span class="subst">&#123;node.spelling&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>([token.spelling <span class="keyword">for</span> token <span class="keyword">in</span> node.get_tokens()])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">        traverse_macro(child)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MACRO: CONCAT</span></span><br><span class="line"><span class="comment"># [&#x27;CONCAT&#x27;, &#x27;(&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27;b&#x27;, &#x27;)&#x27;, &#x27;a&#x27;, &#x27;#&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment"># MACRO_INSTANTIATION: CONCAT</span></span><br><span class="line"><span class="comment"># [&#x27;CONCAT&#x27;, &#x27;(&#x27;, &#x27;1&#x27;, &#x27;,&#x27;, &#x27;2&#x27;, &#x27;)&#x27;]</span></span><br></pre></td></tr></table></figure>

<h1 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h1><p>有时候我们希望对源代码进行一些简单的修改，在某个位置插入一段代码或者删除一段代码。这时候我们可以使用<code>Rewriter</code>这个类。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下面的代码对源文件进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite</span>(<span class="params">node: CX.Cursor, rewriter: CX.Rewriter</span>):</span><br><span class="line">    <span class="keyword">if</span> node.kind == CX.CursorKind.VAR_DECL:</span><br><span class="line">        <span class="keyword">if</span> node.spelling == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">            rewriter.replace_text(node.extent, <span class="string">&quot;int a = 100&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> node.spelling == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">            rewriter.remove_text(node.extent)</span><br><span class="line">        <span class="keyword">elif</span> node.spelling == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">            rewriter.insert_text_before(node.extent.start, <span class="string">&quot;[[maybe_unused]]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">        rewrite(child, rewriter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = CX.Index.create()</span><br><span class="line">tu = index.parse(<span class="string">&#x27;main.cpp&#x27;</span>, args=[<span class="string">&#x27;-std=c++20&#x27;</span>])</span><br><span class="line">rewriter = CX.Rewriter.create(tu)</span><br><span class="line">rewrite(tu.cursor, rewriter)</span><br><span class="line">rewriter.overwrite_changed_files()</span><br></pre></td></tr></table></figure>

<p>运行之后，<code>main.cpp</code>的内容就变成了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    ;</span><br><span class="line">    [[maybe_unused]] <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>如果要获取类型的<code>size</code>, <code>align</code>, <code>offset</code>等 ABI 相关的内容，需要注意 platform。不同 ABI 的情况下它们的值可能不同，例如 MSVC 和 GCC 一般关于这些内容就不同，可以通过在编译参数中指定<code>-target</code>来指定目标平台。如果需要和 MSVC 一致的结果，可以使用<code>--target=x86_64-pc-windows-msvc</code>。如果是 GCC 的话，可以使用<code>--target=x86_64-pc-linux-gnu</code>。</p>
<p>前文提到，libclang 无法提供完整的 C++ 语法树。例如，它在解析 <code>Expr</code> 方面缺少许多接口。这意味着，如果你需要解析具体的表达式内容，那么使用其 C++ 接口可能更为适合，因为它提供了完整且复杂的语法树。</p>
<p>国内关于 Clang 工具具体使用的文章较少。本文尝试对一些常用功能进行了具体介绍，尽管并不十分完善。若有任何疑问，可直接阅读 <code>Index.h</code> 源码，其中的注释非常详尽。或者也可以在评论区留言，我会尽力解答。此外，若需要获取 libclang 不提供的信息，可使用 <code>get_tokens</code> 函数自行获取。例如，libclang 不支持获取整数和浮点数面值的值，这时可通过 <code>get_tokens</code> 手动获取。</p>
<p>在从语法树中提取这些信息后，你可以进一步处理它们，如生成元信息或直接生成代码等。当然，这些都是后话，具体取决于你的需求。</p>
<hr>
<p>本文到这里就结束了，这是反射系列中的其中一篇，如果对其它的文章感兴趣，可以点击下面的链接进行阅读其它文章。</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">写给 C++ 程序员的反射教程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669358870</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>为什么说 C/C++ 编译器不保留元信息？</title>
    <url>/670190357/</url>
    <content><![CDATA[<h1 id="首先什么是元信息？"><a href="#首先什么是元信息？" class="headerlink" title="首先什么是元信息？"></a>首先什么是元信息？</h1><p>来看下面一段<code>python</code>代码，我们希望能够根据传入的字符串来自动修改对应的字段值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, age, name</span>):</span><br><span class="line">        self.age = age</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">person = Person(<span class="number">10</span>, <span class="string">&quot;xiaohong&quot;</span>)</span><br><span class="line"><span class="built_in">setattr</span>(person, <span class="string">&quot;age&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">setattr</span>(person, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;name: <span class="subst">&#123;person.name&#125;</span>, age: <span class="subst">&#123;person.age&#125;</span>&quot;</span>) <span class="comment"># =&gt; name: xiaoming, age: 12</span></span><br></pre></td></tr></table></figure>

<p><code>setattr</code>是<code>python</code>内置的一个函数，刚好可以实现我们的需求。根据输入的字段名，修改对应值。</p>
<p>如果想要在<code>C++</code>中实现应该怎么办呢？<code>C++</code>可没有内置<code>setattr</code>这种函数。代码示例如下。（暂时就先考虑可以直接<code>memcpy</code>的类型了，也就是<code>trivially copyable</code>的类型）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::string_view name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 名字 -&gt; 字段偏移量，字段大小</span></span><br><span class="line">std::map&lt;std::string_view, std::pair&lt;std::<span class="type">size_t</span>, std::<span class="type">size_t</span>&gt;&gt; fieldInfo = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;age&quot;</span>,  &#123;<span class="built_in">offsetof</span>(Person, age),  <span class="built_in">sizeof</span>(<span class="type">int</span>)&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>, &#123;<span class="built_in">offsetof</span>(Person, name), <span class="built_in">sizeof</span>(std::string_view)&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setattr</span><span class="params">(Person* point, std::string_view name, <span class="type">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fieldInfo.<span class="built_in">contains</span>(name))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Field not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; [offset, size] = fieldInfo[name];</span><br><span class="line">    std::<span class="built_in">memcpy</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(point) + offset, data, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person person = &#123;.age = <span class="number">1</span>, .name = <span class="string">&quot;xiaoming&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">    std::string_view name = <span class="string">&quot;xiaohong&quot;</span>;</span><br><span class="line">    <span class="built_in">setattr</span>(&amp;person, <span class="string">&quot;age&quot;</span>, &amp;age);</span><br><span class="line">    <span class="built_in">setattr</span>(&amp;person, <span class="string">&quot;name&quot;</span>, &amp;name);</span><br><span class="line">    std::cout &lt;&lt; person.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; person.name &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// =&gt; 10 xiaohong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现我们基本上自己实现了<code>setattr</code>这个函数，而且这样的实现似乎可以是通用的。只要为特定的类型提供属于它的<code>fieldInfo</code>就行了。这个<code>fieldInfo</code>里面存了字段名，字段的偏移量，字段的类型大小。它就可以被看做<strong>元信息</strong>,除此之外可能还有变量名，函数名，等等。<strong>这些信息不直接参与程序的运行，而是提供关于程序结构、数据、类型等方面的附加信息</strong>。元信息里面存的东西似乎也都是死套路，对于我们都是已知信息。因为它们就存在程序的源代码里面。那<code>C/C++</code>编译器提供这种功能吗？答案是：对于<code>debug</code>模式下的程序可能会保留一部分用于程序调试，而在<code>release</code>模式下什么都不会存。这样做的好处是很显然的，因为这些信息并不是程序运行起来必须要的信息，不保留它们可以显著减少二进制可执行文件的大小。</p>
<h1 id="为什么这些信息是不必要的，什么时候需要？"><a href="#为什么这些信息是不必要的，什么时候需要？" class="headerlink" title="为什么这些信息是不必要的，什么时候需要？"></a>为什么这些信息是不必要的，什么时候需要？</h1><p>接下来我会以<code>C</code>语言为例，将它的源码与二进制表示对应起来。看看执行代码究竟需要哪些信息？</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>事实上变量声明并没有直接对应的二进制表示，它仅仅是告诉编译器需要分配一块空间来存储名为<code>value</code>的变量，究竟分配多大的内存则由它的类型决定。所以如果变量声明的时候类型大小是未知的，则会编译错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line">A x; <span class="comment">// error: storage size of &#x27;x&#x27; isn&#x27;t known</span></span><br><span class="line">A* y; <span class="comment">// ok the size of pointer is always konwn </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;; <span class="comment">// error Node is not a complete type</span></span><br><span class="line"><span class="comment">// 其实意思就是定义 Node 类型的时候它的大小还是未知的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>相信你想到了这和<code>malloc</code>似乎有点像，的确如此。区别在于，<code>malloc</code>是在运行时的堆上分配内存。而直接的变量声明一般是在数据区或者栈上分配内存。编译器可能在内部会维护一个符号表，将变量名与它的地址映射起来，在你后续对这个变量进行操作的时候，实际上是对这块内存区域进行操作。</p>
<h2 id="内置运算符"><a href="#内置运算符" class="headerlink" title="内置运算符"></a>内置运算符</h2><p><code>C</code>语言内置的运算符一般直接和<code>CPU</code>指令直接对应，至于<code>CPU</code>是如何实现这些运算的，可以学习下数电相关知识。以<code>x86_64</code>为例，可能的对应如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">| Operator | Meaning | Operator | Meaning |</span><br><span class="line">|----------|---------|----------|---------|</span><br><span class="line">| +        | add     | *        | mul     |</span><br><span class="line">| -        | sub     | /        | div     |</span><br><span class="line">| %        | div     | &amp;        | and     |</span><br><span class="line">| \|       | or      | ^        | xor     |</span><br><span class="line">| ~        | not     | &lt;&lt;       | shl     |</span><br><span class="line">| &gt;&gt;       | shr     | &amp;&amp;       | and     |</span><br><span class="line">| ||       | or      | !        | not     |</span><br><span class="line">| ==       | cmp     | !=       | cmp     |</span><br><span class="line">| &gt;        | cmp     | &gt;=       | cmp     |</span><br><span class="line">| &lt;        | cmp     | &lt;=       | cmp     |</span><br><span class="line">| ++       | inc     | --       | dec     |</span><br></pre></td></tr></table></figure>

<p>赋值则可能是通过<code>mov</code>指令来完成的，比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span>; <span class="comment">// mov [addressof(a)] 3</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    point.x = <span class="number">1</span>;</span><br><span class="line">    point.y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的大小一般可以由特定规则算出从它的成员算出，往往要考虑内存对齐，而且是编译器决定的。例如 <a href="https://learn.microsoft.com/en-us/cpp/c-language/storage-and-alignment-of-structures?view=msvc-170">msvc</a>。但总之在编译的时候结构体的大小就是已知的了，我们也可以通过<code>sizeof</code>获取类型或者变量的大小。那么这里的<code>Point point</code>变量定义就很好理解，类型大小已知，相对于在栈上分配了一块内存。</p>
<p>下面来关注一下结构体成员访问，事实上<code>C</code>语言有一个宏可以获取结构体成员相对于结构体起始地址的偏移量，叫做<code>offsetof</code>（就算我们获取不到，编译器里面也是会计算字段偏移量的，所以偏移量信息对编译器总是已知的）。例如在这里<code>offsetof(Point, x)</code>就是<code>0</code>，<code>offsetof(Point, y)</code>就是<code>4</code>。所以上面的代码可以理解为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> point[<span class="keyword">sizeof</span>(Point)]; <span class="comment">// 8 = sizeof(Point)</span></span><br><span class="line">    *(<span class="type">int</span>*)(point + offsetof(Point, x)) = <span class="number">1</span>; <span class="comment">// point.x = 1</span></span><br><span class="line">    *(<span class="type">int</span>*)(point + offsetof(Point, y)) = <span class="number">2</span>; <span class="comment">// point.y = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器同样可能会维护一个字段名-&gt;偏移量的符号表，字段名最终会替换为<code>offset</code>。也没有必要在程序中保留了。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>一般通过函数调用栈实现，这个太常见了，就不仔细说了。函数名最后会直接被替换为函数地址。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，相信你已经发现了，<code>C</code>语言中的符号名，类型名，变量名，函数名，结构体字段名等等信息都被替换成了数字，地址，偏移量等等。缺少了它们对程序运行并没有什么影响。所以选择把它们抛弃掉，减少二进制文件的大小。对于<code>C++</code>来说情况基本也是类似的，<code>C++</code>只会在一些特殊的情况下保留部分元信息，比如<code>type_info</code>，而且可以手动选择关闭掉<code>RTTI</code>从而确保不会产生这种信息。</p>
<p>那什么时候我们需要使用这些信息？显然最开始介绍的<code>setattr</code>是需要的。在程序调试的时候，我们得知道一个地址对应的变量名，函数名，成员名等等，方便我们调试，这时候我们也是需要的。当把结构体序列化为<code>json</code>的时候，我们需要知道它的字段名，我们也需要这些信息。把类型擦除成<code>void*</code>了之后，我们还是需要知道它实际对应的类型是什么，这时候我们也是需要的。总之，为了在运行期区分这串二进制内容倒是原本是什么东西的时候，我们就需要这些信息（当然在编译期想要利用这些信息进行代码生成，也是需要的）。</p>
<h1 id="如何获取这些信息？"><a href="#如何获取这些信息？" class="headerlink" title="如何获取这些信息？"></a>如何获取这些信息？</h1><p><code>C/C++</code>编译器并没有提供给我们接口让我们获取这些信息，但是前面已经说了，这些信息显然就在源代码里面啊。变量名，函数名，类型名，字段名。我们可以选择通过人工理解代码，然后手动去存储元信息。几千个类，几十个成员函数，可能写个几个月就好了吧。开玩笑的，或者我们可以写一些程序，比如正则表达式匹配之类的帮我们获取到这些信息？不过，其实我们有更好的选择来获取这些信息，那就是通过<code>AST</code>。</p>
<h1 id="AST-Abstract-Syntax-Tree"><a href="#AST-Abstract-Syntax-Tree" class="headerlink" title="AST(Abstract Syntax Tree)"></a>AST(Abstract Syntax Tree)</h1><p><code>AST</code>是抽象语法树（<code>Abstract Syntax Tree</code>）的缩写。它是编程语言处理中的一种数据结构，用于表示源代码的抽象语法结构。<code>AST</code>是源代码经过解析器（<code>parser</code>）处理后的结果，它捕捉了代码中的语法结构，但不包含所有细节，比如空白字符或注释。在<code>AST</code>中，每个节点代表源代码中的一个语法结构，例如变量声明、函数调用、循环等。这些节点之间通过父子关系和兄弟关系连接，形成了一棵树状结构，这样的结构更容易被计算机程序理解和处理。如果你的电脑里面装了<code>clang</code>编译器，可以使用下面这个命令查看一个源文件的语法树</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -Xclang -ast-dump -fsyntax-only &lt;your.cpp&gt;</span><br></pre></td></tr></table></figure>

<p>输出如下，我筛选出了重要的信息，无关的已经被删除了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">|-CXXRecordDecl <span class="number">0x2103cd9c318</span> &lt;col:<span class="number">1</span>, col:<span class="number">8</span>&gt; col:<span class="number">8</span> implicit <span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">|-FieldDecl <span class="number">0x2103cd9c3c0</span> &lt;line:<span class="number">4</span>:<span class="number">5</span>, col:<span class="number">9</span>&gt; col:<span class="number">9</span> referenced x <span class="string">&#x27;int&#x27;</span></span><br><span class="line">|-FieldDecl <span class="number">0x2103e8661f0</span> &lt;line:<span class="number">5</span>:<span class="number">5</span>, col:<span class="number">9</span>&gt; col:<span class="number">9</span> referenced y <span class="string">&#x27;int&#x27;</span></span><br><span class="line">`-FunctionDecl <span class="number">0x2103e8662b0</span> &lt;line:<span class="number">8</span>:<span class="number">1</span>, line:<span class="number">13</span>:<span class="number">1</span>&gt; line:<span class="number">8</span>:<span class="number">5</span> main <span class="string">&#x27;int ()&#x27;</span></span><br><span class="line">  `-CompoundStmt <span class="number">0x2103e866c68</span> &lt;line:<span class="number">9</span>:<span class="number">1</span>, line:<span class="number">13</span>:<span class="number">1</span>&gt;</span><br><span class="line">    |-DeclStmt <span class="number">0x2103e866b30</span> &lt;line:<span class="number">10</span>:<span class="number">5</span>, col:<span class="number">16</span>&gt;</span><br><span class="line">    | `-VarDecl <span class="number">0x2103e866410</span> &lt;col:<span class="number">5</span>, col:<span class="number">11</span>&gt; col:<span class="number">11</span> used point <span class="string">&#x27;Point&#x27;</span>:<span class="string">&#x27;Point&#x27;</span> callinit</span><br><span class="line">    |   `-CXXConstructExpr <span class="number">0x2103e866b08</span> &lt;col:<span class="number">11</span>&gt; <span class="string">&#x27;Point&#x27;</span>:<span class="string">&#x27;Point&#x27;</span> <span class="string">&#x27;void () noexcept&#x27;</span></span><br><span class="line">    |-BinaryOperator <span class="number">0x2103e866bb8</span> &lt;line:<span class="number">11</span>:<span class="number">5</span>, col:<span class="number">15</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    | |-MemberExpr <span class="number">0x2103e866b68</span> &lt;col:<span class="number">5</span>, col:<span class="number">11</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue .x <span class="number">0x2103cd9c3c0</span></span><br><span class="line">    | | `-DeclRefExpr <span class="number">0x2103e866b48</span> &lt;col:<span class="number">5</span>&gt; <span class="string">&#x27;Point&#x27;</span>:<span class="string">&#x27;Point&#x27;</span> lvalue Var <span class="number">0x2103e866410</span> <span class="string">&#x27;point&#x27;</span> <span class="string">&#x27;Point&#x27;</span>:<span class="string">&#x27;Point&#x27;</span></span><br><span class="line">    | `-IntegerLiteral <span class="number">0x2103e866b98</span> &lt;col:<span class="number">15</span>&gt; <span class="string">&#x27;int&#x27;</span> <span class="number">1</span></span><br><span class="line">    `-BinaryOperator <span class="number">0x2103e866c48</span> &lt;line:<span class="number">12</span>:<span class="number">5</span>, col:<span class="number">15</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue <span class="string">&#x27;=&#x27;</span></span><br><span class="line">      |-MemberExpr <span class="number">0x2103e866bf8</span> &lt;col:<span class="number">5</span>, col:<span class="number">11</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue .y <span class="number">0x2103e8661f0</span></span><br><span class="line">      | `-DeclRefExpr <span class="number">0x2103e866bd8</span> &lt;col:<span class="number">5</span>&gt; <span class="string">&#x27;Point&#x27;</span>:<span class="string">&#x27;Point&#x27;</span> lvalue Var <span class="number">0x2103e866410</span> <span class="string">&#x27;point&#x27;</span> <span class="string">&#x27;Point&#x27;</span>:<span class="string">&#x27;Point&#x27;</span></span><br><span class="line">      `-IntegerLiteral <span class="number">0x2103e866c28</span> &lt;col:<span class="number">15</span>&gt; <span class="string">&#x27;int&#x27;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>或者如果你的<code>vscode</code>装了<code>clangd</code>这个插件，可以右键选择一块代码，然后右键<code>show AST</code>来看这块代码片段的<code>ast</code>。可以发现上面的确是把源码内容以树的方式呈现给我们了，既然是一颗树，我们就可以自由的遍历树的节点，然后筛选获取我们想要的信息。上面两例都是可视化的输出，通常情况下也会有直接的代码接口来直接获取。比如<code>python</code>内置就有<code>ast</code>模块来获取，<code>C++</code>一般是通过<code>clang</code>相关的工具来获取这些内容。如果想知道具体该如何使用<code>clang</code>工具，可以参考这篇文章</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669360731" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">使用 clang 工具自由的支配 C++ 代码吧！</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669360731</span></span></span></a></p>
<p>如果你好奇编译器究竟是如何把源代码变成<code>ast</code>的，你可以去学习一下编译原理前端的内容。</p>
<h1 id="以何种方式存储这些信息？"><a href="#以何种方式存储这些信息？" class="headerlink" title="以何种方式存储这些信息？"></a>以何种方式存储这些信息？</h1><p>这个问题听起来让人有些困惑，实际上这个问题可能只有<code>C++</code>程序员需要考虑</p>
<p>其实一切原因都是<code>constexpr</code>引起的。把信息下面这样存储起来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FieldInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string_view name;</span><br><span class="line">    std::<span class="type">size_t</span> offset;</span><br><span class="line">    std::<span class="type">size_t</span> size;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> std::array&lt;FieldInfo, 2&gt; fieldInfos =</span><br><span class="line">&#123;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;x&quot;</span>, <span class="built_in">offsetof</span>(Point, x), <span class="built_in">sizeof</span>(<span class="type">int</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;y&quot;</span>, <span class="built_in">offsetof</span>(Point, y), <span class="built_in">sizeof</span>(<span class="type">int</span>)&#125;,</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>就意味着我们不仅仅能在运行期查询这些信息，还能在编译期查询这些信息</p>
<p>更有甚者，还可以存到模板参数里面去，这样的话连类型也能存了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;fixed_string name, std::<span class="type">size_t</span> offset, <span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Field</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FieldInfos = std::tuple</span><br><span class="line">&lt;</span><br><span class="line">    Field&lt;<span class="string">&quot;x&quot;</span>, <span class="built_in">offsetof</span>(Point, x), <span class="type">int</span>&gt;,</span><br><span class="line">    Field&lt;<span class="string">&quot;y&quot;</span>, <span class="built_in">offsetof</span>(Point, y), <span class="type">int</span>&gt;</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure>

<p>这样无疑给了我们更大的操作空间，那么有了这些信息之后，下一步该做些什么？事实上我们可以选择基于这部分信息进行代码生成，相关的内容可以浏览系列文章中的其它小节。总目录的链接在下方：</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">写给 C++ 程序员的反射教程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669358870</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>在 C++ 中实现 Object!</title>
    <url>/670191053/</url>
    <content><![CDATA[<h1 id="静态与动态"><a href="#静态与动态" class="headerlink" title="静态与动态"></a>静态与动态</h1><p>静态类型和动态类型这两个词语相信大家都不陌生了，区分二者的关键在于类型检查的时机。什么意思呢？</p>
<p>假设我们有如下的 C++ 代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = s + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>那我们知道，<code>string</code>是不能和<code>int</code>直接相加的，所以这里应该有一个 TypeError。C++ 在编译期检查类型错误，所以这段代码会触发一个 <strong>compile time error（编译时错误）</strong>。</p>
<p>考虑对应的 Python 代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;123&quot;</span></span><br><span class="line">a = s + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>而 Python 则是在运行期检查错误，上述代码实际上会产生一个 <strong>runtime error（运行时错误）</strong>。</p>
<p>有必要强调一下这里的编译期 <strong>compile time</strong> 和 <strong>runtime</strong> 指代的含义。这些词可能经常会见到，但是在不同的上下文中可以含义不太一样，在我们这里：</p>
<ul>
<li><strong>compile time</strong>：泛指将一种代码编译为目标代码的时候，这时候程序还没有运行起来<ul>
<li>对于 AOT 编译的语言，例如 C++，就是把 C++ 编译成机器码的过程</li>
<li>对于 JIT 编译的语言，例如如 C#&#x2F;Java，一般是指把源码编译成 IR 的过程</li>
<li>对于转译语言来说，例如 TypeScript，则是把 TypeScript 编译成 JavaScript 的过程</li>
</ul>
</li>
<li><strong>runtime</strong>：泛指程序实际运行的时候，比如机器码在 CPU 上执行的时候，或者字节码在虚拟机上执行的时候</li>
</ul>
<p>因此 C++，Java，C#，TypeScript 被称作静态类型的语言。而 Python 虽然也有把源码编译到字节码这个阶段，但是这个阶段不进行类型检查，所以 Python 被称作动态类型的语言。</p>
<p>然而这并不绝对，静态语言和动态语言之间的界限并没有那么清晰，虽然 C++，Java，C#，TypeScript 是静态类型的语言，但是都提供了若干方法来绕过静态类型检查，比如 C++ 的<code>pointer</code>，Java&#x2F;C# 的<code>Object</code>， TypeScript 的<code>Any</code>。而动态类型语言也逐渐在引入静态类型检查，比如 Python 的<code>type hint</code>，JavaScript 的<code>TypeScript</code>等等，二者都在相互借鉴对方的特性。</p>
<p>目前 C++ 只提供了<code>std::any</code>来进行类型擦除，但是很多时候它不够灵活。我们想要一些更加高级的功能，比如通过<strong>字段名访问成员</strong>，通过<strong>函数名调用函数</strong>，通过<strong>类型名创造类实例</strong>。 本文的目标就是在 C++ 中构建出类似 Java&#x2F;C# 中的<code>Object</code>那样的动态的类型。</p>
<h1 id="元类型"><a href="#元类型" class="headerlink" title="元类型"></a>元类型</h1><p>我们这里不采用类似 Java&#x2F;C# 中<code>Object</code>那种侵入式设计（继承），而是采用被叫做 fat pointer 非侵入式设计。所谓 fat pointer 其实就是一个结构体，包含了一个指向实际数据的指针，以及一个指向类型信息的指针。如果是继承的话，则是这个虚表指针存在对象头部。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span> &#123;</span><br><span class="line">    Type* type;    <span class="comment">// type info, similar to vtable</span></span><br><span class="line">    <span class="type">void</span>* data;    <span class="comment">// pointer to the data</span></span><br><span class="line">    <span class="type">uint8_t</span> flag;  <span class="comment">// special flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() : <span class="built_in">type</span>(<span class="literal">nullptr</span>), <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">flag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Any</span>(Type* type, <span class="type">void</span>* data) : <span class="built_in">type</span>(type), <span class="built_in">data</span>(data), <span class="built_in">flag</span>(<span class="number">0B</span>00000001) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Any</span>(<span class="type">const</span> Any&amp; other);</span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp; other);</span><br><span class="line">    ~<span class="built_in">Any</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Any</span>(T&amp;&amp; value);  <span class="comment">// box value to Any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">T&amp; <span class="title">cast</span><span class="params">()</span></span>;  <span class="comment">// unbox Any to value</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Type* <span class="title">GetType</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> type; &#125;  <span class="comment">// get type info</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Any <span class="title">invoke</span><span class="params">(std::string_view name, std::span&lt;Any&gt; args)</span></span>;  <span class="comment">// call method</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foreach</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>(std::string_view, Any&amp;)&gt;&amp; fn)</span></span>;  <span class="comment">// iterate fields</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的成员函数将会在后面的章节逐步实现，接下来我们先来考虑这个<code>Type</code>类型里面存的是什么。</p>
<h1 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    std::string_view name;       <span class="comment">// type name</span></span><br><span class="line">    <span class="built_in">void</span> (*destroy)(<span class="type">void</span>*);      <span class="comment">// destructor</span></span><br><span class="line">    <span class="type">void</span>* (*copy)(<span class="type">const</span> <span class="type">void</span>*);  <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="type">void</span>* (*move)(<span class="type">void</span>*);        <span class="comment">// move constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Field = std::pair&lt;Type*, std::<span class="type">size_t</span>&gt;;           <span class="comment">// type and offset</span></span><br><span class="line">    <span class="keyword">using</span> Method = <span class="built_in">Any</span> (*)(<span class="type">void</span>*, std::span&lt;Any&gt;);         <span class="comment">// method</span></span><br><span class="line">    std::unordered_map&lt;std::string_view, Field&gt; fields;    <span class="comment">// field info</span></span><br><span class="line">    std::unordered_map&lt;std::string_view, Method&gt; methods;  <span class="comment">// method info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的内容很简单，我们在<code>Type</code>里面中存了类型名，析构函数，移动构造，拷贝构造，字段信息和方法信息。字段信息里面存的是字段类型和字段名，方法信息里面存的是方法名和函数地址。如果希望进一步扩展的话，还可以把父类的信息和重载函数的信息也存进来。由于这里只是做一个示例，就暂时不考虑它们了。</p>
<h1 id="函数类型擦除"><a href="#函数类型擦除" class="headerlink" title="函数类型擦除"></a>函数类型擦除</h1><p>为了把不同类型的成员函数存在同一个容器里面，我们必须要对函数类型进行擦除。所有类型的函数都被擦除成了 <code>Any(*)(void*, std::span&lt;Any&gt;)</code>这个类型。这里的<code>Any</code>类型就是我们上面定义的<code>Any</code>类型，这里的<code>void*</code>其实代表就是<code>this</code>指针，而<code>std::span&lt;Any&gt;</code>则是函数的参数列表。现在我们要考虑如何进行这种函数类型擦除。</p>
<p>以下面给定的成员函数<code>say</code>为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string_view name;</span><br><span class="line">    std::<span class="type">size_t</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">(std::string_view msg)</span> </span>&#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; say: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先为了方便书写，我们把<code>Any</code>的<code>cast</code>实现一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Type* <span class="title">type_of</span><span class="params">()</span></span>;  <span class="comment">// type_of&lt;T&gt; returns type info of T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">Any::cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type != <span class="built_in">type_of</span>&lt;T&gt;()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::runtime_error&#123;<span class="string">&quot;type mismatch&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;T*&gt;(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 C++ 中无捕获的<code>lambda</code>能隐式转换成函数指针这个特性，可以轻松实现这种擦除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = +[](<span class="type">void</span>* object, std::span&lt;Any&gt; args) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; self = *<span class="built_in">static_cast</span>&lt;Person*&gt;(object);</span><br><span class="line">    self.<span class="built_in">say</span>(args[<span class="number">0</span>].<span class="built_in">cast</span>&lt;std::string_view&gt;());</span><br><span class="line">    <span class="keyword">return</span> Any&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实原理很简单，只要写一个 wrapper 函数进行一下类型转换，然后转发调用就行了。但是如果每个成员函数都要手写这么一大段转发代码还是很麻烦的。我们可以考虑通过模板元进行代码生成，自动生成上面的代码，简化类型擦除的这个过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_fn_traits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_fn_traits</span>&lt;<span class="built_in">R</span> (C::*)(Args...)&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = R;</span><br><span class="line">    <span class="keyword">using</span> class_type = C;</span><br><span class="line">    <span class="keyword">using</span> args_type = std::tuple&lt;Args...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> ptr&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span>* <span class="title">type_ensure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> traits = member_fn_traits&lt;<span class="keyword">decltype</span>(ptr)&gt;;</span><br><span class="line">    <span class="keyword">using</span> class_type = <span class="keyword">typename</span> traits::class_type;</span><br><span class="line">    <span class="keyword">using</span> result_type = <span class="keyword">typename</span> traits::return_type;</span><br><span class="line">    <span class="keyword">using</span> args_type = <span class="keyword">typename</span> traits::args_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> +[](<span class="type">void</span>* object, std::span&lt;Any&gt; args) -&gt; Any &#123;</span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">static_cast</span>&lt;class_type*&gt;(object);</span><br><span class="line">        <span class="keyword">return</span> [=]&lt;std::<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_void_v&lt;result_type&gt;) &#123;</span><br><span class="line">                (self-&gt;*ptr)(args[Is].cast&lt;std::<span class="type">tuple_element_t</span>&lt;Is, args_type&gt;&gt;()...);</span><br><span class="line">                <span class="keyword">return</span> Any&#123;&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Any&#123;(self-&gt;*ptr)(args[Is].cast&lt;std::<span class="type">tuple_element_t</span>&lt;Is, args_type&gt;&gt;()...)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;args_type&gt;&gt;&#123;&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码我就不解释了，如果看不懂也没关系。其实就是通过模板元，把成员函数类型擦除的这个过程自动化了一下。只要知道如何使用就行了，使用起来是非常简单的。这里的<code>&amp;Person::say</code>是 pointer to member 的写法，不太熟悉的可以参考 <a href="https://16bit-ykiko.github.io/about-me/659510753">C++ 成员指针完全解析</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="built_in">type_ensure</span>&lt;&amp;Person::say&gt;();</span><br><span class="line"><span class="comment">// decltype(f) =&gt; Any (*)(void*, std::span&lt;Any&gt;)</span></span><br></pre></td></tr></table></figure>

<h1 id="类型信息注册"><a href="#类型信息注册" class="headerlink" title="类型信息注册"></a>类型信息注册</h1><p>事实上我们需要给每个类型都生成一个对应的<code>Type</code>结构来保存它的信息，这样的话才能正确访问。而这个功能就由上文提到的<code>type_of</code>函数负责。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Type* <span class="title">type_of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Type type;</span><br><span class="line">    type.name = <span class="built_in">typeid</span>(T).<span class="built_in">name</span>();</span><br><span class="line">    type.destroy = [](<span class="type">void</span>* obj) &#123; <span class="keyword">delete</span> <span class="built_in">static_cast</span>&lt;T*&gt;(obj); &#125;;</span><br><span class="line">    type.copy = [](<span class="type">const</span> <span class="type">void</span>* obj) &#123; <span class="built_in">return</span> (<span class="type">void</span>*)(<span class="keyword">new</span> <span class="built_in">T</span>(*<span class="built_in">static_cast</span>&lt;<span class="type">const</span> T*&gt;(obj))); &#125;;</span><br><span class="line">    type.move = [](<span class="type">void</span>* obj) &#123; <span class="built_in">return</span> (<span class="type">void</span>*)(<span class="keyword">new</span> <span class="built_in">T</span>(std::<span class="built_in">move</span>(*<span class="built_in">static_cast</span>&lt;T*&gt;(obj)))); &#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Type* <span class="built_in">type_of</span>&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="type">static</span> Type type;</span><br><span class="line">    type.name = <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    type.destroy = [](<span class="type">void</span>* obj) &#123; <span class="keyword">delete</span> <span class="built_in">static_cast</span>&lt;Person*&gt;(obj); &#125;;</span><br><span class="line">    type.copy = [](<span class="type">const</span> <span class="type">void</span>* obj) &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="type">void</span>*)(<span class="keyword">new</span> <span class="built_in">Person</span>(*<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Person*&gt;(obj)));</span><br><span class="line">    &#125;;</span><br><span class="line">    type.move = [](<span class="type">void</span>* obj) &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="type">void</span>*)(<span class="keyword">new</span> <span class="built_in">Person</span>(std::<span class="built_in">move</span>(*<span class="built_in">static_cast</span>&lt;Person*&gt;(obj))));</span><br><span class="line">    &#125;;</span><br><span class="line">    type.fields.<span class="built_in">insert</span>(&#123;<span class="string">&quot;name&quot;</span>, &#123;<span class="built_in">type_of</span>&lt;std::string_view&gt;(), <span class="built_in">offsetof</span>(Person, name)&#125;&#125;);</span><br><span class="line">    type.fields.<span class="built_in">insert</span>(&#123;<span class="string">&quot;age&quot;</span>, &#123;<span class="built_in">type_of</span>&lt;std::<span class="type">size_t</span>&gt;(), <span class="built_in">offsetof</span>(Person, age)&#125;&#125;);</span><br><span class="line">    type.methods.<span class="built_in">insert</span>(&#123;<span class="string">&quot;say&quot;</span>, <span class="built_in">type_ensure</span>&lt;&amp;Person::say&gt;()&#125;);</span><br><span class="line">    <span class="keyword">return</span> &amp;type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们提供一个默认实现，这样的话如果用到了内置的基础类型可以自动注册一些信息。然后可以通过特化给自定义的类型提供实现，好了，现在有了这些元信息我们可以把<code>Any</code>的成员函数实现补充完整了。</p>
<h1 id="Any-完整实现"><a href="#Any-完整实现" class="headerlink" title="Any 完整实现"></a>Any 完整实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Any::<span class="built_in">Any</span>(<span class="type">const</span> Any&amp; other) &#123;</span><br><span class="line">    type = other.type;</span><br><span class="line">    data = type-&gt;<span class="built_in">copy</span>(other.data);</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Any::<span class="built_in">Any</span>(Any&amp;&amp; other) &#123;</span><br><span class="line">    type = other.type;</span><br><span class="line">    data = type-&gt;<span class="built_in">move</span>(other.data);</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Any::<span class="built_in">Any</span>(T&amp;&amp; value) &#123;</span><br><span class="line">    type = type_of&lt;std::<span class="type">decay_t</span>&lt;T&gt;&gt;();</span><br><span class="line">    data = <span class="keyword">new</span> std::<span class="built_in">decay_t</span>&lt;T&gt;(std::forward&lt;T&gt;(value));</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Any::~<span class="built_in">Any</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(flag &amp; <span class="number">0B</span>00000001) &amp;&amp; data &amp;&amp; type) &#123;</span><br><span class="line">        type-&gt;<span class="built_in">destroy</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Any::foreach</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>(std::string_view, Any&amp;)&gt;&amp; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [name, field]: type-&gt;fields) &#123;</span><br><span class="line">        Any any = Any&#123;field.first, <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(data) + field.second&#125;;</span><br><span class="line">        <span class="built_in">fn</span>(name, any);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Any <span class="title">Any::invoke</span><span class="params">(std::string_view name, std::span&lt;Any&gt; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = type-&gt;methods.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span>(it == type-&gt;methods.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::runtime_error&#123;<span class="string">&quot;method not found&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;<span class="built_in">second</span>(data, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foreach</code>的实现就是遍历所有的<code>Field</code>然后获取偏移量和类型，然后把它包装成<code>Any</code>类型。注意这里只是简单包装一下，实际上由于我们设置了<code>flag</code>，这个包装并不会导致多次析构。<code>invoke</code>就是从成员函数列表里面找出对应的函数，然后调用。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Any person = Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    std::vector&lt;Any&gt; args = &#123;std::string_view&#123;<span class="string">&quot;Hello&quot;</span>&#125;&#125;;</span><br><span class="line">    person.<span class="built_in">invoke</span>(<span class="string">&quot;say&quot;</span>, args);</span><br><span class="line">    <span class="comment">// =&gt; Tom say: Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [](std::string_view name, Any&amp; value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value.<span class="built_in">GetType</span>() == <span class="built_in">type_of</span>&lt;std::string_view&gt;()) &#123;</span><br><span class="line">            std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value.<span class="built_in">cast</span>&lt;std::string_view&gt;() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value.<span class="built_in">GetType</span>() == <span class="built_in">type_of</span>&lt;std::<span class="type">size_t</span>&gt;()) &#123;</span><br><span class="line">            std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value.<span class="built_in">cast</span>&lt;std::<span class="type">size_t</span>&gt;() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    person.foreach(f);</span><br><span class="line">    <span class="comment">// name = Tom</span></span><br><span class="line">    <span class="comment">// age = 18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码放在 <a href="https://github.com/16bit-ykiko/blog/blob/main/code/dynamic-type-demo.cpp">Github</a> 上了，至此我们就已经实现了一个极度动态，非侵入式的<code>Any</code>了。</p>
<h1 id="扩展和优化"><a href="#扩展和优化" class="headerlink" title="扩展和优化"></a>扩展和优化</h1><p>本文给出的只是非常简单的原理介绍，考虑的情况也十分简单。比如这里没有考虑继承和函数重载，在运行效率上也有若干可以优化的地方。尽管如此，可能我写的功能对你来说仍然是过多的。本文想主要表达的意思是，对于 C++ 这种非常注重性能的语言来说，有时候的确会在一些场景需要这些比较动态的特性。然而高效性和通用性往往是矛盾的，语言层面因为要考虑通用性，所以效率往往不尽如人意。例如<code>RTTI</code>和<code>dynamic_cast</code>常常被人抱怨，不过好在编译器提供选项来关闭它们。同样的，我的实现也不一定完全符合你的场景，但是懂得这并不困难的原理之后你完全可以根据你的场景来实现一个更加适合你的版本。</p>
<p>可以扩展的点：</p>
<ul>
<li>支持根据<code>name</code>来修改成员</li>
<li>添加一个全局的<code>map</code>用于记录所有类型的信息，从而支持根据类名创造类的实例</li>
<li><code>...</code></li>
</ul>
<p>可以优化的点：</p>
<ul>
<li>减少<code>new</code>的次数，或者自己实现一个对象池</li>
<li>或者目前储存的元信息过多，根据你自己的需求进行裁剪</li>
</ul>
<p>除此之外，现在还有一个痛点是，这些元信息我们都要手写，很难维护。如果要修改类内的定义还得把这些注册代码一并修改，否则就会出错。这里一个实际可行的方案是使用代码生成器来自动生成这些机械的代码。关于如何进行这些操作，可以参考本系列的其它文章</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">写给 C++ 程序员的反射教程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669358870</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>手动优化C++代码来加快编译速度？！</title>
    <url>/673852429/</url>
    <content><![CDATA[<p>事情的起因是我最近在编写的一个库  <a href="https://github.com/16bit-ykiko/magic-cpp">magic cpp</a> ，正在编写其中<code>enum</code>的相关部分。打算参考一下<code>magic enum</code>的相关实现，在翻 <code>issue</code>的时候翻到这么一个神奇的<code>PR</code> </p>
<p><a target="_blank" href="https://github.com/Neargye/magic_enum/pull/227" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">​pull request</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://github.com/Neargye/magic_enum&#x2F;pull&#x2F;227</span></span></span></a></p>
<p>我们都知道<code>C++</code>的<code>constexpr/consteval</code>函数可以在编译期执行，目前编译器对此的实现大概是内部实现了一个小型的解释器，用来直接执行代码。然而这个解释器具体是什么表现我们无从得知，但是这个 pr 的作者仅仅改了几行代码就让编译速度提升了不少。</p>
<p><strong>原代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="type">const</span>* str = name.<span class="built_in">data</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::<span class="type">size_t</span> i = name.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!((name[i - <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; name[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) ||</span><br><span class="line">          (name[i - <span class="number">1</span>] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; name[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">          (name[i - <span class="number">1</span>] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; name[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>** 优化代码**</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="type">const</span>* str = name.<span class="built_in">data</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::<span class="type">size_t</span> i = name.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="type">char</span> c = str[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!((c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) ||</span><br><span class="line">          (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">          (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这两份代码唯一的区别在于第二份代码对数组的元素<code>str[i - 1]</code>做了一次缓存。如果编译器在编译期解释执行这个函数的时候不执行任何优化，那么第一种写法每次判断都得额外寻一次址，相比之下第二种做了缓存的效果明显会快很多。这也和作者的测试结果相符合，优化后的写法编译更快。</p>
<p>作者还提到了，<code>STL</code>实现的许多容器有越界检测，但是在编译期这实际上是不必要的，编译期越界（读取未初始化的内存）的话会直接编译错误，例如下面这段代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">char</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> c = <span class="built_in">f</span>(); <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure>

<p>直接编译错误，所以这些检测其实并没有任何实际的作用，反倒是无用的检查拖慢了<code>constexpr</code>函数的编译期执行速度，更好的办法是自己实现一份不带检查的编译期使用的数据结构。另外一个有关编译速度优化相关的<code>PR</code>是 这个 <a href="https://github.com/Neargye/magic_enum/issues/219">compile-time optimization · Issue #219</a> </p>
<hr>
<p>实际上，如果对于运行期代码，编译器完全会把这两种代码优化成一种形式，我们是不用考虑这个问题的。但是这个<code>PR</code>的确表现出来一个问题，那就是C++编译器对于<code>constexpr expression</code>求值的效率问题，在以后<code>C++</code>引入静态反射之后，<code>constexpr</code>函数的使用会更加泛滥，如果编译器不能通过有效的手段加快它的执行速度，恐怕会更进一步加剧<code>C++</code>编译速度慢的问题。</br></br>后来我在<code>clang</code>的社区提出了这个 <a href="https://discourse.llvm.org/t/will-clang-do-some-optimization-when-evaluate-the-constexpr-expression-for-faster-compile-speed/75900">问题</a> 。他们回复表示，目前（即<code>clang18</code>以及之前），<code>clang</code>的<code>constexpr expression</code>的求值效率的确是有问题的，现在的<code>tree evaluator</code>效率低下，并且在将来会有有一个新的 <a href="https://clang.llvm.org/docs/ConstantInterpreter.html">Interpreter</a> 来解决这个问题，现在在<code>clang18</code>中可以用<code>-fexperimental-new-constant-interpreter</code>来开启这个实验性的功能。</p>
<p>这里有其主要贡献者 <a href="https://www.redhat.com/en/authors/timm-baeder">Timm Baeder</a> 的两篇相关介绍文章：</p>
<ul>
<li><a href="https://www.redhat.com/en/blog/new-constant-expression-interpreter-clang">A new constant expression interpreter for Clang</a></li>
<li><a href="https://www.redhat.com/en/blog/new-constant-expression-interpreter-clang-part-2">A new constant expression interpreter for Clang, Part 2</a></li>
</ul>
<p>如果这个新的解释器被正式加入了，有关的情况应该会得到比较大的改善。<strong>但是在那之前如果你的项目中大量使用了常量求值相关的代码，可能需要你手动进行优化编译期求值的代码来换取更快的编译速度</strong></br></p>
<hr>
<p>还剩下<code>gcc</code>和<code>msvc</code>的相关实现未调查，未完待续<code>......</code> </p>
]]></content>
  </entry>
  <entry>
    <title>全新的构造函数，C++ 中的 relocate 构造函数</title>
    <url>/679782886/</url>
    <content><![CDATA[<p>众所周知，现在 C++ 里面有两种特殊的构造函数，即 copy constructor 和 move constructor</p>
<p>copy constructor 早在 C++98 的时候就加入了，用来拷贝一个对象，像<code>vector</code>这种拥有资源的类型，拷贝的时候会把它拥有的资源也拷贝一份</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = v1; <span class="comment">// copy</span></span><br></pre></td></tr></table></figure>

<p>当然了，拷贝的开销有些时候非常大，而且完全没必要。于是在 C++11 加入了 move constructor，用来把一个对象的资源转移到另一个对象上。这样相对于直接拷贝，开销是小得多的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1); <span class="comment">// move</span></span><br></pre></td></tr></table></figure>

<p>注意 C++ 中的 move 被叫做 C++ 标准规定了，被移动过后的对象状态是一种 ，实现需要保证它能够正常调用析构函数。<strong>被移动的对象仍然可能被再次使用</strong>（具体能否使用取决于实现）。</p>
<h1 id="结束了？"><a href="#结束了？" class="headerlink" title="结束了？"></a>结束了？</h1><p>有这两个构造函数就足够了吗？当然没有。事实上还有另一种广泛使用的操作，可以把它叫做 <strong>relocate</strong> 操作。考虑如下场景</p>
<p>假设你正在实现一个<code>vector</code>，扩容是必要的，于是你写了一个私有成员函数<code>grow</code>用来进行扩容（下面的代码示例暂时忽略异常安全）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">grow</span><span class="params">(std::<span class="type">size_t</span> new_capacity)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> new_data = <span class="built_in">malloc</span>(new_capacity * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_Size; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> (new_data + i) <span class="built_in">T</span>(std::<span class="built_in">move</span>(m_Data[i]));</span><br><span class="line">        m_Data[i].~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(m_Data); </span><br><span class="line">    m_Data = new_data;</span><br><span class="line">    m_Capacity = new_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很简单，先通过<code>malloc</code>分配新的内存，然后通过 <a href="https://en.cppreference.com/w/cpp/language/new#Placement_new">placement new</a> 在新分配的内存上调用移动构造进行初始化。注意，正如前文提到的： C++ 中的 move 是 non-destructive 的，所以需要在调用完移动构造之后，原对象还需要调用析构函数，来正确的结束生存期。最后释放原来的内存，更新成员变量的值就行了。</p>
<p>但是这样的实现并不高效，在 C++ 中有一个 <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">trivially copyable</a> 的概念，可以通过<code>is_trivially_copyable</code>这个 triat 来进行判断。满足这个约束的类型，可以直接使用<code>memcpy</code>或者<code>memmove</code>来进行拷贝得到一个新的对象。考虑下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_trivially_copyable_v&lt;Point&gt;);</span><br><span class="line"></span><br><span class="line">Point points[<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">Point new_points[<span class="number">3</span>];</span><br><span class="line">std::<span class="built_in">memcpy</span>(new_points, points, <span class="built_in">sizeof</span>(points));</span><br></pre></td></tr></table></figure>

<p>不仅仅省去了多次函数调用，而且<code>memcpy</code>和<code>memmove</code>本身就是高度优化的 builtin 函数（可以通过 SIMD 进行向量化）。所以效率相比于直接调用拷贝构造进行复制效率会高很多。</p>
<p>为了让我们的<code>vector</code>更快，我们也可以做一下这种优化，利用 C++17 加入的<code>if constexpr</code>来做编译期判断，很轻松的写出下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">grow</span><span class="params">(std::<span class="type">size_t</span> new_capacity)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> new_data = <span class="built_in">malloc</span>(new_capacity * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_trivially_copyable_v&lt;T&gt;)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(new_data, m_Data, m_Size * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_move_constructible_v&lt;T&gt;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_Size; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">construct_at</span>(new_data + i, std::<span class="built_in">move</span>(m_Data[i]));</span><br><span class="line">            std::<span class="built_in">destroy_at</span>(m_Data + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_copy_constructible_v&lt;T&gt;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_Size; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">construct_at</span>(new_data + i, m_Data[i]);</span><br><span class="line">            std::<span class="built_in">destroy_at</span>(m_Data + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">free</span>(m_Data); </span><br><span class="line">    m_Data = new_data;</span><br><span class="line">    m_Capacity = new_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="大材小用"><a href="#大材小用" class="headerlink" title="大材小用"></a>大材小用</h1><p>这样总感觉怪怪的，我们主要的目的是把就旧内存上的对象全部移动到新内存上，但是用的居然是 <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">trivially copyable</a> 这个 trait，似乎约束过强了。完全创建一个新对象和把原来的对象放置到新的位置，感觉差别还挺大的。考虑下面这个例子。似乎直接对<code>std::string</code>这样的类型进行<code>memcpy</code>也是可以的。由于内存都是我们手动管理，析构函数也是我们手动调用，并不会出现多次调用析构函数的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::byte buffer[<span class="built_in">sizeof</span>(std::string)];</span><br><span class="line"><span class="keyword">auto</span>&amp; str1 = *std::<span class="built_in">construct_at</span>((std::string*) buffer, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::byte new_buffer[<span class="built_in">sizeof</span>(std::string)];</span><br><span class="line">std::<span class="built_in">memcpy</span>(new_buffer, buffer, <span class="built_in">sizeof</span>(std::string));</span><br><span class="line"><span class="keyword">auto</span>&amp; str2 = *(std::string*) new_buffer;</span><br><span class="line"></span><br><span class="line">str2.~<span class="built_in">basic_string</span>();</span><br></pre></td></tr></table></figure>

<p>仔细思考一下数据的流向和析构函数的调用，发现没有任何不妥。似乎我们应该寻找一种叫做 trivially moveable 的概念，用来放宽松条件，从而使更多的类型得到优化。很可惜，目前 C++ 标准中并没有这样的概念。为了和 C++ 已经存在的 move 操作区分开来，我们把这种操作叫做 relocate，即把原本的对象放置在一个全新的位置。</p>
<p>事实上有很多著名的开源组件也都通过模板特化来实现了类似的功能，例如 </p>
<ul>
<li><a href="https://github.com/bloomberg/bde/blob/962f7aa/groups/bsl/bslmf/bslmf_isbitwisemoveable.h#L8-L48">BSL</a> 的<code>bslmf::IsBitwiseMoveable&lt;T&gt;</code> </li>
<li><a href="https://github.com/facebook/folly/blob/main/folly/docs/FBVector.md#object-relocation">Folly</a> 的<code>folly::IsRelocatable&lt;T&gt; </code> </li>
<li><a href="https://github.com/qt/qtbase/">QT</a> 的<code>QTypeInfo&lt;T&gt;::isRelocatable</code></li>
</ul>
<p>通过对特定的类型进行标记，使得它们可以拥有这种优化。但是，上面的优化只是在我们逻辑上认为相等，严格来说目前这样写在 C++ 中算是 undefined behavior。那怎么办？只能想办法通过新提案，修改标准措辞，来支持上面的优化。</p>
<h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>首先这个问题早就被发现了，例如知乎上很久之前就有相关的讨论：</p>
<ul>
<li><a href="https://www.zhihu.com/question/316026652/answer/623722536">比起 malloc new &#x2F; free old，realloc 在性能上有多少的优势?</a></li>
<li><a href="https://www.zhihu.com/question/384869006/answer/1130101522">C++ vector 的 push_back 扩容机制为什么不考虑在尾元素后面的空间申请内存?</a></li>
</ul>
<p>类似的问题还有挺多的。<code>realloc</code>会尝试在原地扩容，如果失败。就会尝试分配一块新的内存，然后用<code>memcpy</code>把原来的数据拷贝到新的内存上。所以在目前的 C++ 标准中，如果你想要直接使用<code>realloc</code>进行扩容的话，必须要保证对象是 trivially copyable 的。当然，前面已经说了，这个条件是比较苛刻的，需要引入新的概念来放宽条件。</p>
<p>相关的提案最早在 2015 年就被提出了，在 2023 年仍然活跃的提案主要有下面四个（目标都是 C++26）：</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r9.html">std::is_trivially_relocatable</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r4.pdf">Trivial Relocatability For C++26</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r3.html">Relocating prvalues</a></li>
<li><a href="https://isocpp.org/files/papers/D2839R1.html#part-i-owning-references-and-defaulted-relocation-constructors">Nontrivial Relocation via a New owning reference Type</a></li>
</ul>
<p>大概可以分为两派，保守派和激进派</p>
<h2 id="保守派"><a href="#保守派" class="headerlink" title="保守派"></a>保守派</h2><p>保守派的解决方案是添加 relocatable 和 trivally-relocatable 的概念，以及用来判断的相关 trait。</p>
<p>如果一个类型是 move-constructible 且 destructible 的，那么它就是 relocatable 的</p>
<p>如果一个类型满足下列条件之一，那么它就是 trivally-relocatable 的</p>
<ul>
<li>是一个 trivially-copyable 的类型</li>
<li>是一个 trivally-relocatable 类型的数组</li>
<li>是一个用具有值为 true 的<code>trivially_relocatable</code>属性声明的类类型</li>
<li>是一个类类型，满足以下条件：<ul>
<li>没有用户提供的移动构造函数或移动赋值运算符</li>
<li>没有用户提供的复制构造函数或复制赋值运算符</li>
<li>没有用户提供的析构函数</li>
<li>没有虚拟成员函数</li>
<li>没有虚基类</li>
<li>每个成员都是引用或者 trivally-relocatable 类型，并且所有基类都是 trivally-relocatable 类型</li>
</ul>
</li>
</ul>
<p>可以通过新的 attribute ——<code>trivially_relocatable</code> 来显式标记一个类型为 trivally-relocatable，它可以用常量表达式作为参数，来支持泛型类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> [[<span class="built_in">trivially_relocatable</span>(std::std::is_trivially_relocatable_v&lt;T&gt;)]] X &#123; T t; &#125;;</span><br></pre></td></tr></table></figure>

<p>还增加了一些新的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T *<span class="title">relocate_at</span><span class="params">(T* source, T* dest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">remove_cv_t</span>&lt;T&gt; <span class="title">relocate</span><span class="params">(T* source)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> NoThrowForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">uninitialized_relocate_n</span><span class="params">(InputIterator first, Size n, NoThrowForwardIterator result)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些函数都是由编译器实现的，效果上等同于 move + destroy 原对象。并且允许编译器在满足 as-if 规则的前提下，把对 trivially_relocatable 的类型的操作优化成<code>memcpy</code>或者<code>memmove</code>。对于那些不能优化的结构，比如含有自引用的结构，就正常调用移动构造 + 析构函数就行了。这样在实现<code>vector</code>的时候，直接使用这些标准库提供的函数就可以享受优化了。</p>
<p>该提案之所以被称作保守派，最大的原因就是它既不影响原来的 API，也不影响原来的 ABI，具有较强的兼容性，引入进来十分方便。</p>
<h2 id="激进派"><a href="#激进派" class="headerlink" title="激进派"></a>激进派</h2><p>更为激进的就是今天的主角了，它主张引入 relocate constructor，并且引入了新的关键字<code>reloc</code></p>
<p><code>reloc</code>是一个一员运算符，可以用于函数非静态局部变量，<code>reloc</code>用于执行如下操作</p>
<ul>
<li>如果变量是引用类型，则进行完美转发</li>
<li>如果不是则把源对象变成纯右值并返回</li>
</ul>
<p>并且被<code>reloc</code>过后的对象，如果再次使用被认为是编译错误（实际判定的规则会更加详细，详见提案里面的相关小节）</p>
<p>然后引入了一个新的构造函数，即 relocate constructor（重定位构造函数），具有如下形式<code>T(T)</code>，函数参数是<code>T</code>类型的纯右值。选择这个作为函数签名是为了完善 C++ value category 体系。目前（C++17）及以后，C++ 的拷贝构造函数从 lvalue 创建对象，移动构造函数从 xvalue 创建对象，而重定位构造函数则是从 prvalue 创建对象。这样就完整的覆盖了所有的 value category，对于重载决议来说是十分友好的，语义上也十分和谐融洽。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="built_in">X</span>(X x): <span class="built_in">s</span>(std::<span class="built_in">move</span>(x.s)) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一个好处是，目前这种<code>T(T)</code>声明的构造函数是不允许的，所以不会和现有的代码冲突。有一点需要注意，相信之前大家可能听人这样解释过，为什么拷贝构造函数的参数必须是引用？因为如果不是引用的话，函数传参也需要拷贝，就会导致无限递归。</p>
<p>事实上这种解释已经过时了，由于 C++17 引入的强制性的 <a href="https://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a>。即使一个类型没有拷贝构造函数和移动构造函数，它也可以直接从纯右值构造，并且没有任何拷贝&#x2F;移动构造函数的调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">X</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">X</span>(X&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">f</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> X&#123;&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">X x = <span class="built_in">f</span>();</span><br></pre></td></tr></table></figure>

<p>上述的代码在开启 C++17 之后各大编译器都能编译通过。所以这里<code>T(T)</code>的这种构造函数的形式并不会导致无限递归。该提案也引入了重定位赋值函数，具有如下形式<code>T&amp; operator=(T)</code>，函数参数是<code>T</code>类型的纯右值。当然，也还有 trivially-relocatable 的概念，允许满足这个条件的重定位构造函数被优化为<code>memcpy</code>。但是，这是通过重定位构造函数等规则来进行判断的，用户不能显式通过 attribute 进行标记。我觉得这一点并不好，应该允许用户手动标记一个类型为 trivially-relocatable。<code>tuple</code>就是由于目前的实现限制，必须要写一个构造函数，从而导致永远不能是 trivially-copyable 的了，pair 居然也不是 trivially-copyable 的，显然这不合理。所以希望该提案以后能支持通过 attribute 来标记一个类型为 trivially-relocatable。</p>
<p>我个人是比较喜欢这个提案的，有了它以后，我甚至感觉 C++ 的 value category 系统能够和优雅挂钩了。在这之前，我一直觉得 value category 这个系统是混乱邪恶的，是为了兼容以前的旧代码打的烂补丁。但是如果该提案通过以后</p>
<ul>
<li>左值 —— 拷贝构造</li>
<li>亡值 —— 移动构造</li>
<li>纯右值 —— 重定位构造</li>
</ul>
<p>有一种逻辑完全自洽的美感。提案中其它的细节，就比较琐碎了，这里就省略了。感兴趣的读者可以自己阅读。</p>
<h1 id="为什么过多这么久还没进入标准"><a href="#为什么过多这么久还没进入标准" class="headerlink" title="为什么过多这么久还没进入标准"></a>为什么过多这么久还没进入标准</h1><p>关于为什么过了这么多年这个问题仍然没有解决，其实这是一段相当长的历史，是 C++ 的对象模型存在缺陷导致的。直到 C++20 的 <a href="https://en.cppreference.com/w/cpp/language/lifetime">隐式生存期提案</a> 被接受之前，在最开始的扩容函数实现中，连把 trivially-copyable 的类型优化为 memcpy 都是 undefined behavior。</p>
<p>当然，不要听到 undefined behavior 就害怕，觉得心里面有道坎一样。事实上这一直被认为是标准的缺陷，这种优化早已经广泛实践各大代码库之中了，可靠性已经得到验证。只是 C++ 标准一直没有合适的措辞来描述这种情况，完全认为是 UB 肯定是不对的，不加限制的使用也是不对的，所以问题的关键就是如何在这两者之间如何找出一个合适的边界了。最近我会专门写一篇文章来介绍 C++ 对象模型相关的内容，这里就不展开了。</p>
<h1 id="其它语言"><a href="#其它语言" class="headerlink" title="其它语言"></a>其它语言</h1><p>C++ 固然有各种不足，考虑到历史兼容性等因素，导致设计放不开手脚。那新语言呢？它们是如何解决这些问题的？</p>
<h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><p>首先先看最近比较火热的 Rust。其实，只要结构中不含有自引用的成员，那么使用<code>memcpy</code>把旧的对象移动到新的内存上，几乎总是可行的。另外，Rust 并没有什么多继承虚函数（虚表结构复杂）啦，虚继承啦，这种比较奇怪的东西（并且实际用到的地方很少），所以几乎所有的类型都可以直接使用<code>memcpy</code>来从旧对象创建一个新对象。刚好 Safe Rust 中的 move 语义还是 destructive move，所以它的 move 的默认实现就是直接<code>memcpy</code>，是清爽很多。</p>
<p>但是默认的移动只能移动局部非静态变量，如果一个变量是引用，那么你就没法移动它。不过还好 Safe Rust 提供了一个 <a href="https://doc.rust-lang.org/std/mem/fn.take.html">std::mem::take</a> 函数用来解决这个问题：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">old_v</span> = mem::<span class="title function_ invoke__">take</span>(&amp;<span class="keyword">mut</span> v);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>], old_v);</span><br><span class="line"><span class="built_in">assert!</span>(v.<span class="title function_ invoke__">is_empty</span>());</span><br></pre></td></tr></table></figure>

<p>效果是，移动 + 原对象置空，比较类似于 C++ 中的 move。还有 <a href="https://doc.rust-lang.org/std/mem/fn.swap.html">std::mem::swap</a> 和 <a href="https://doc.rust-lang.org/std/mem/fn.replace.html">std::mem::replace</a> 用于其它需要从引用处进行移动的场景。</p>
<p>虽然可能情况不多，但是如果一个类型含有自引用的结构怎么办？事实上，允许用户自定义构造函数是一个比较简单的解决办法，但是 Rust 社区对此似乎比较反感。目前的解决方案是通过 Pin，不过 Rust 社区似乎对这个解决方案也不是很满意，它很难理解且很难使用。未来全新的设计应该和 linear type 有关，相关的讨论详见 <a href="https://without.boats/blog/changing-the-rules-of-rust/">Changing the rules of Rust</a>。</p>
<h2 id="Mojo"><a href="#Mojo" class="headerlink" title="Mojo"></a>Mojo</h2><p>这个语言前些日子也在知乎上也宣传过一波，但是目前还处于完全早期的状态，不过一开始人家就考虑提供四种构造函数</p>
<ul>
<li><code>__init__()</code></li>
<li><code>__copy__()</code></li>
<li><code>__move__()</code></li>
<li><code>__take__()</code></li>
</ul>
<p>其中 copy 就类似于 拷贝构造函数，move 类似于重定位构造函数，take 则类似于现在的移动构造函数。更多的细节就无从得知了。</p>
]]></content>
  </entry>
  <entry>
    <title>跨越 7 年的接力赛：获取 C++ 结构体字段数量</title>
    <url>/674157958/</url>
    <content><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在<code>C++17</code>中引入了叫做「<strong>结构化绑定</strong>」的特性也就是<code>Struct Bind</code>，这一特性类似于别的语言中的模式匹配，可以让我们方便的对结构体的成员进行访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line"></span><br><span class="line">Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = p;</span><br><span class="line"><span class="comment">// x = 1, y = 2</span></span><br></pre></td></tr></table></figure>

<p>利用它我们能实现一些有趣的功能，包括对结构体的反射功能，比如实现一个<code>for_each</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(<span class="keyword">auto</span>&amp;&amp; object, <span class="keyword">auto</span>&amp;&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">remove_cvref_t</span>&lt;<span class="keyword">decltype</span>(object)&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_aggregate_v&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; [x, y] = object;</span><br><span class="line">        for_each(x, func);</span><br><span class="line">        for_each(y, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func</span>(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话对于任意的含有两个成员的聚合类型，我们都可以对其进行遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123; Point start; Point end; &#125;;</span><br><span class="line"></span><br><span class="line">Line line = &#123;&#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span> &#125;&#125;;</span><br><span class="line">for_each(line, [](<span class="keyword">auto</span>&amp;&amp; object)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; object &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是这样有一个问题那就是，只能递归的支持结构体字段数量为<code>2</code>的情况，如果你尝试填入一个字段数量为<code>3</code>的结构体，那么编译器就会抛出一个<code>hard error</code>。即结构化绑定数量错误，它不能被<code>SFINAE</code>或者<code>requires</code>处理，会直接导致编译中止</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec3</span> &#123; <span class="type">float</span> x; <span class="type">float</span> y; <span class="type">float</span> z; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里面是个 lambda</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> value = <span class="keyword">requires</span>&#123; []()&#123; <span class="keyword">auto</span> [x, y] = Vec3&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; &#125;; &#125;;</span><br><span class="line"><span class="comment">// hard error</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过手动分发的方式来解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(N == <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [x] = object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(N == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [x, y] = object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(N == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [x, y, z] = object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>你可以自由枚举到你想要支持的数量，这里面的<code>N</code>就是结构体字段数量了，你可能需要把它作为模板参数显式传入，或者给每个类型都特化一个模板，里面存上它的字段数量。但是这仍然很麻烦，那么有没有一种方法可以让编译器自动的帮我们计算出结构体的字段数量呢？</p>
<h1 id="第一棒-Antony-Polukhin"><a href="#第一棒-Antony-Polukhin" class="headerlink" title="第一棒 Antony Polukhin"></a>第一棒 Antony Polukhin</h1><p>初步解决方案在 <a href="https://www.boost.org/doc/libs/1_75_0/doc/html/boost_pfr.html">boost&#x2F;pfr</a> 中就已经给出了，其作者 Antony Polukhin 在 <a href="https://www.youtube.com/watch?v=abdeAew3gmQ">CppCon2016</a> 和 <a href="https://www.youtube.com/watch?v=UlNUNxLtBI0">CppCon2018</a> 中对此做了详细的介绍，不过作者采用的版本是<code>C++14/17</code>，其中的代码较为晦涩难懂，在我使用<code>C++20</code>进行重写之后可读性提高了不少。</p>
<p>首先在<code>C++</code>中我们可以写一个<code>Any</code>类型，它支持向任意类型进行转换，其实就是把它的 <a href="https://en.cppreference.com/w/cpp/language/cast_operator">类型转换函数</a> 写成模板函数就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Any</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;; <span class="comment">// 支持从 int 构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_convertible_v&lt;Any, <span class="type">int</span>&gt;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_convertible_v&lt;Any, std::string&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>之后我们可以利用聚合初始化的特性，那就是对于超出聚合初始化最大数量的表达式，<code>requires</code>语句会返回<code>false</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用 make_index_sequence 构造 N 个参数</span></span><br><span class="line">    <span class="keyword">return</span> []&lt;std::<span class="type">size_t</span>... I&gt;(std::index_sequence&lt;I...&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">requires</span>&#123; T&#123; <span class="built_in">Any</span>(I)... &#125;; &#125;; </span><br><span class="line">    &#125;(std::make_index_sequence&lt;N&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">test</span>&lt;Point, <span class="number">0</span>&gt;()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">test</span>&lt;Point, <span class="number">1</span>&gt;()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">test</span>&lt;Point, <span class="number">2</span>&gt;()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">static_assert</span>(!<span class="built_in">test</span>&lt;Point, <span class="number">3</span>&gt;()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>注意到这里<code>Point</code>只有两个成员，当我们传入了三个参数给初始化列表的时候，<code>requires</code>就会返回<code>false</code>。利用这个特性，我们可以把上面的尝试过程改成递归的，也就是线性查找这个序列直到找到<code>false</code>为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N </span>= <span class="number">0</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">member_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!test&lt;T, N&gt;())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">member_count</span>&lt;T, N + <span class="number">1</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>test&lt;T, N&gt;</code>为真说明<code>N</code>个参数可以成功构造<code>T</code>，那么我们就递归的尝试<code>N + 1</code>个参数，直到<code>test&lt;T, N&gt;</code>为假，那么<code>N - 1</code>就是<code>T</code>的成员数量了。这样我们就可以通过<code>member_count&lt;T&gt;()</code>来获取<code>T</code>的成员数量了。测试一下效果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123; std::string a; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">member_count</span>&lt;A&gt;() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123; std::string a; <span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">member_count</span>&lt;B&gt;() == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>很好啊，大获成功！事情到这里就结束了吗？</p>
<h1 id="第二棒-Joao-Baptista"><a href="#第二棒-Joao-Baptista" class="headerlink" title="第二棒 João Baptista"></a>第二棒 João Baptista</h1><p>考虑下面这三个例子 </p>
<ul>
<li>左值引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123; <span class="type">int</span>&amp; x; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">member_count</span>&lt;A&gt;() == <span class="number">1</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认构造函数被删除</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="built_in">X</span>() = <span class="keyword">delete</span>; &#125; <span class="comment">// 默认构造函数被删除</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123; X x; X y; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">member_count</span>&lt;B&gt;() == <span class="number">2</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123; <span class="type">int</span> x[<span class="number">2</span>]; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">member_count</span>&lt;C&gt;() == <span class="number">1</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p><strong>遇到这三种情况，原来的方法完全失效了，为什么会这样？</strong></p>
<p>这一小节的主要内容参考自 João Baptista 的两篇博客</p>
<ul>
<li><a href="https://towardsdev.com/counting-the-number-of-fields-in-an-aggregate-in-c-20-c81aecfd725c">Counting the number of fields in an aggregate in C++20</a> </li>
<li><a href="https://towardsdev.com/counting-the-number-of-fields-in-an-aggregate-in-c-20-part-2-d3103dec734f">Counting the number of fields in an aggregate in C++20 — part 2</a></li>
</ul>
<p>他总结了<code>boost/pfr</code>中的问题，并提出了解决方案，解决了上述提到的三个问题</p>
<h2 id="左值引用的问题"><a href="#左值引用的问题" class="headerlink" title="左值引用的问题"></a>左值引用的问题</h2><p>第一个问题相对比较好理解，主要就是因为<code>T()</code>类型产生的转换产生的都是纯右值，左值引用没法绑定到纯右值，如果是右值引用就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(!std::is_constructible_v&lt;<span class="type">int</span>&amp;, Any&gt;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_constructible_v&lt;<span class="type">int</span>&amp;&amp;, Any&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>怎么办呢？其实有一种很巧妙的写法，可以解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Any</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;; <span class="comment">// 支持从 int 构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">operator</span> T&amp;() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">operator</span> T&amp;&amp;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个转换成左值引用，一个转换成右值引用。如果它们俩只有一个能匹配，那就会选择那一个能匹配的。如果两个都能匹配，左值引用转换的优先级比右值引用高，会被优先选择，不会有重载决议的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(std::is_constructible_v&lt;<span class="type">int</span>, Any&gt;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_constructible_v&lt;<span class="type">int</span>&amp;, Any&gt;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_constructible_v&lt;<span class="type">int</span>&amp;&amp;, Any&gt;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_constructible_v&lt;<span class="type">const</span> <span class="type">int</span>&amp;, Any&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>很好，这样的话第一个问题，解决！</p>
<h2 id="默认构造函数的问题"><a href="#默认构造函数的问题" class="headerlink" title="默认构造函数的问题"></a>默认构造函数的问题</h2><p>为什么把默认构造函数删了就不行了呢？还记得我们最开始的那个<code>Point</code>类型吗？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br></pre></td></tr></table></figure>

<p>我们尝试的结果是<code>0</code>,<code>1</code>,<code>2</code>都可以，<code>3</code>不行。可是，如果说，<code>&#123; &#125;</code>里面的数量多于<code>Point</code>的成员数量导致失败我能理解，为啥少于里面的成员数量可以成功呢？其实原因很简单，那就是你没有<strong>显式初始化的成员</strong>会被<strong>值初始化</strong>。于是<code>&#123; &#125;</code>里面的参数，可以少于实际的字段数量。但是如果字段禁止了默认构造函数，就没法进行值初始化，就会编译错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="built_in">X</span>() = <span class="keyword">delete</span>; &#125; <span class="comment">// 默认构造函数被删除</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;  </span><br><span class="line">    X x; </span><br><span class="line">    X y; </span><br><span class="line">    <span class="type">int</span> z; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于下面这个类型，我们如果用<code>Any</code>尝试的话，应该是<code>0</code>,<code>1</code>不行,<code>2</code>,<code>3</code>可以,<code>4</code>,<code>5</code>,<code>...</code>以及往后的都不行。也就是说至少要让所有<strong>不能默认初始化</strong>的成员都初始化之后才行。 如果一个类型支持默认初始化，那么搜索它的有效区间是<code>[0, N]</code>其中<code>N</code>就是它的<strong>最大字段数量</strong>。如果不支持默认初始化，那其实搜索区间就变成了<code>[M, N]</code>，<code>M</code>是保证其不能默认初始化的成员全都初始化的最小数量。</p>
<p>我们之前的搜索策略是从<code>0</code>开始搜索，如果当前这个是<code>true</code>，那就求下一个，直到<code>false</code>停止。显然这种搜索策略不适合现在这种情况了，因为在<code>[0, M)</code>之间，也符合之前的搜索策略搜索失败的情况。我们现在要改成，如果当前这个是<code>ture</code>并且下一个是<code>false</code>才停止搜索，这样刚好能搜到这个<strong>区间的上界</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N </span>= <span class="number">0</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">member_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(test&lt;T, N&gt;() &amp;&amp; !test&lt;T, N + <span class="number">1</span>&gt;())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">member_count</span>&lt;T, N + <span class="number">1</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123; <span class="type">int</span>&amp; x; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">member_count</span>&lt;A&gt;() == <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="built_in">X</span>() = <span class="keyword">delete</span>; &#125;; <span class="comment">// 默认构造函数被删除</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123; X x; X y; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">member_count</span>&lt;B&gt;() == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>OK</code>，第二个问题也解决了，实在是太酷了！</p>
<h2 id="数组的问题"><a href="#数组的问题" class="headerlink" title="数组的问题"></a>数组的问题</h2><p>如果在结构体的成员里面有数组，那么计算的时候最终得到的结果就是把数组的每一个成员都当成一个字段来计算，其实就是因为对标准数组的聚合初始化开了后门</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span> &#123; <span class="type">int</span> x[<span class="number">2</span>]; &#125;;</span><br><span class="line">Array&#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>注意到没有，只有一个字段却可以填两个值。但是对数组开洞就导致了这样的困境，如果结构体里面含有数组就会最终得到错误的计数。那有没有什么办法能解决这个问题？</p>
<p>考虑下面这个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例子，来看一下它初始化的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 0 个位置</span></span><br><span class="line">D&#123; &#123;<span class="number">1</span>&#125;, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125; <span class="comment">// OK, 0号位置最多放置 1 个元素</span></span><br><span class="line">D&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125; <span class="comment">// Error </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 个位置</span></span><br><span class="line">D&#123; <span class="number">1</span>, &#123;<span class="number">2</span>&#125;, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125; <span class="comment">// Error</span></span><br><span class="line">D&#123; <span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">4</span>, <span class="number">5</span> &#125; <span class="comment">// OK, 1号位置最多放置 2 个元素</span></span><br><span class="line">D&#123; <span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, <span class="number">5</span> &#125; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 个位置</span></span><br><span class="line">D&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>&#125;, <span class="number">5</span>&#125; <span class="comment">// Error</span></span><br><span class="line">D&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>, <span class="number">5</span>&#125; &#125; <span class="comment">// OK, 3号位置最多放置 2 个元素</span></span><br></pre></td></tr></table></figure>

<p>没错，我们可以利用嵌套初始化，来解决这个问题！我们先用原本的方法求出最大的可能的结构体字段数量（包含数组展开的，这里就是5个），然后再在每个位置尝试把原本的序列塞到这个嵌套初始化里面去，通过不停尝试就能找到这个位置所能放置的元素的最大数量，如果最大数量超过<code>1</code>的话，说明这个位置是个数组。这个最大数量就是数组的元素数量，我们在最后的结果中，把多余数量减掉就行了。</p>
<p><strong>听起来简单，实现起来还是有点复杂的哦。</strong></p>
<p>先写一个函数用来辅助，通过填不同的<code>N1</code>,<code>N2</code>,<code>N3</code>就能对应到上面不同情况了，注意<code>I2</code>那里的<code>Any</code>那里是嵌套初始化，多了一层括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N1, std::<span class="type">size_t</span> N2, std::<span class="type">size_t</span> N3&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test_three_parts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> []&lt;std::<span class="type">size_t</span>... I1, std::<span class="type">size_t</span>... I2, std::<span class="type">size_t</span>... I3&gt;</span><br><span class="line">    (std::index_sequence&lt;I1...&gt;, std::index_sequence&lt;I2...&gt;, std::index_sequence&lt;I3...&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">requires</span>&#123; T&#123; <span class="built_in">Any</span>(I1)..., &#123; <span class="built_in">Any</span>(I2)... &#125;, <span class="built_in">Any</span>(I3)... &#125;; &#125;;</span><br><span class="line">    &#125;(std::make_index_sequence&lt;N1&gt;&#123;&#125;, std::make_index_sequence&lt;N2&gt;&#123;&#125;, std::make_index_sequence&lt;N3&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要写一个函数，用来测试在指定位置用二层<code>&#123; &#125;</code> 放置<code>N</code>个元素是不是可行的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> position, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">try_place_n_in_pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> Total = <span class="built_in">member_count</span>&lt;T&gt;(); <span class="comment">// 可能的最大字段数量</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(N == <span class="number">0</span>)</span> <span class="comment">// 放置 0 个和原本的效果是一样的肯定可行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (position + N &lt;= Total) <span class="comment">// 元素数量之和的肯定不能超过总共的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">test_three_parts</span>&lt;T, position, N, Total - position - N&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于内容有点多，可能有点难以理解，我们这里先展示一下这个函数的测试结果，方便理解，这样如果你看不懂函数实现也没问题。 还是以之前那个结构体<code>D</code>为例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">try_place_n_in_pos</span>&lt;D, <span class="number">0</span>, <span class="number">1</span>&gt;(); </span><br><span class="line"><span class="comment">// 这其实就是在测试 D&#123; &#123;1&#125;, 2, 3, 4, 5 &#125; 这种情况</span></span><br><span class="line"><span class="comment">// 在 0 号位置放置 1个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">try_place_n_in_pos</span>&lt;D, <span class="number">1</span>, <span class="number">2</span>&gt;();</span><br><span class="line"><span class="comment">// 这其实就是在测试 D&#123; 1, &#123;2, 3&#125;, 4, 5 &#125; 这种情况</span></span><br><span class="line"><span class="comment">// 在 1 号位置放置 2 个元素</span></span><br></pre></td></tr></table></figure>

<p>好了，看懂这个函数是在做什么事情就行了，在某一个位置不停地尝试就行了，然后就能找到这个位置能放置的最大的元素数量了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> pos, std::<span class="type">size_t</span> N </span>= <span class="number">0</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">search_max_in_pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> Total = <span class="built_in">member_count</span>&lt;T&gt;();</span><br><span class="line">    std::<span class="type">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">    [&amp;]&lt;std::<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;)</span><br><span class="line">    &#123; ((<span class="built_in">try_place_n_in_pos</span>&lt;T, pos, Is&gt;() ? result = Is : <span class="number">0</span>), ...); &#125;(std::<span class="built_in">make_index_sequence</span>&lt;Total + <span class="number">1</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是在这个位置搜索能放置的元素最大数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">search_max_in_pos</span>&lt;D, <span class="number">0</span>&gt;() == <span class="number">1</span>); <span class="comment">// 1, 0号位置最多放置 1 个元素</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">search_max_in_pos</span>&lt;D, <span class="number">1</span>&gt;() == <span class="number">2</span>); <span class="comment">// 2, 1号位置最多放置 2 个元素</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">search_max_in_pos</span>&lt;D, <span class="number">3</span>&gt;() == <span class="number">2</span>); <span class="comment">// 2, 3号位置最多放置 2 个元素</span></span><br></pre></td></tr></table></figure>

<p>这与我们最开始的手动测试结果一致，接下来就是遍历所有位置，找出所有的额外的数组元素数量，然后从一开始的那个最大数量里面减掉这些多余的就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="built_in">search_all_extra_index</span>(<span class="keyword">auto</span>&amp;&amp; array)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> total = <span class="built_in">member_count</span>&lt;T&gt;();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> num = <span class="built_in">search_max_in_pos</span>&lt;T, N&gt;();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = num &gt; <span class="number">1</span> ? num : <span class="number">1</span>;</span><br><span class="line">    array[N] = value;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(N + value &lt; total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">search_all_extra_index</span>&lt;T, N + value&gt;(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是递归的找，结果储存在数组里面。注意这里<code>N + value</code>，如果这里找到两个元素了，我们可以直接往后挑两个位置。例如<code>1</code>号位置可以放置<code>2</code>个元素，那我直接找<code>3</code>号位置就行了，不用找<code>2</code>号位置了。</p>
<p>接下来就是把结果都存到数组里面然后，把多余的减掉就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">true_member_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> Total = <span class="built_in">member_count</span>&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Total == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::<span class="type">size_t</span>, Total&gt; indices = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="built_in">search_all_extra_index</span>&lt;T&gt;(indices);</span><br><span class="line">        std::<span class="type">size_t</span> result = Total;</span><br><span class="line">        std::<span class="type">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; Total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = indices[index];</span><br><span class="line">            result -= n - <span class="number">1</span>;</span><br><span class="line">            index += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">true_member_count</span>&lt;D&gt;() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>&amp; x;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>&amp;&amp; w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">true_member_count</span>&lt;E&gt;() == <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>拿这里的<code>E</code>类型最后生成的数组举一下例子吧，可以都<code>print</code>出来看看</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">index: <span class="number">0</span> num: <span class="number">1</span>  <span class="comment">// 0 号位置对应 x， 数量是 1 合理</span></span><br><span class="line">index: <span class="number">1</span> num: <span class="number">4</span>  <span class="comment">// 1 号位置对应 y， 数量是 4 合理</span></span><br><span class="line">index: <span class="number">5</span> num: <span class="number">2</span>  <span class="comment">// 5 号位置对应 z， 数量是 2 合理</span></span><br><span class="line">index: <span class="number">7</span> num: <span class="number">1</span>  <span class="comment">// 7 号位置对应 w， 数量是 1 合理</span></span><br></pre></td></tr></table></figure>

<p>完美谢幕！我很佩服这个作者的想法，真的是太巧妙了，让人叹为观止。然而，在文章的末尾他却说道，</p>
<blockquote>
<p> As it could be seen, I ran into some inconsistencies between gcc and clang (and for some reason I haven’t managed to make it work on MSVC at all, but that is another story).</p>
</blockquote>
<p>他说，他遇到了<code>clang</code>和<code>gcc</code>的行为不一致的情况，而且完全没法让这种方法在<code>msvc</code>上工作。</p>
<p><strong>看来事情远远没有结束！</strong></p>
<h1 id="第三棒-YKIKO"><a href="#第三棒-YKIKO" class="headerlink" title="第三棒 YKIKO"></a>第三棒 YKIKO</h1><p>我花了一些时间读懂了刚才这位作者的文章，说实话他的模板写的我很难读懂，他不喜欢用<code>if constexpr</code>来做分支选择，用了很多特化来做选择，给可读性造成了很大影响。所以刚才那些代码并不完全是原作者中的代码，是我用我认为的，更好阅读的形式进行转译的。</p>
<p>哪些情况会<code>break</code>第二位作者的代码呢？ </p>
<ul>
<li>移动构造被删除</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="built_in">X</span>(X&amp;&amp;) = <span class="keyword">delete</span>; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">F</span>&#123; X x; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">true_member_count</span>&lt;F&gt;() == <span class="number">1</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结构体中含有其它结构体成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span>&#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">G</span>&#123; Y x; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">true_member_count</span>&lt;G&gt;() == <span class="number">2</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>MSVC</code>的<code>bug</code>和<code>GCC</code>的<code>bug</code></li>
</ul>
<h2 id="移动构造被删除的问题"><a href="#移动构造被删除的问题" class="headerlink" title="移动构造被删除的问题"></a>移动构造被删除的问题</h2><p>这一切都源于<code>C++17</code>加入的一条新规则，是关于 <a href="https://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a> 的。</p>
<blockquote>
<p> Since C++17, a prvalue is not materialized until needed, and then it is constructed directly into the storage of its final destination. This sometimes means that even when the language syntax visually suggests a copy&#x2F;move (e.g. copy initialization), no copy&#x2F;move is performed — which means the type need not have an accessible copy&#x2F;move constructor at all. </p>
</blockquote>
<p>什么意思呢，举例子说明最清晰</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">M</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">M</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">M</span>(M&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">M m1 = <span class="built_in">M</span>(); <span class="comment">// ok in C++17, error in C++14</span></span><br><span class="line">M m2 = std::<span class="built_in">move</span>(<span class="built_in">M</span>()); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>啊？为什么会这样，第一个可以编译通过，第二个不行，难道我写<code>std::move</code>还多余了吗？</p>
<p>其实第二个编译不通过的原因是很好理解的，因为移动构造函数被删除了，所以没法调用移动构造函数了，于是就编译失败了。注意到第一种情况在<code>C++14</code>和<code>C++17</code>中的行为是不一样的，<code>C++14</code>是先产生临时对象，然后调用移动构造函数，初始化<code>m1</code>，但是这样的行为其实是多余的，所以编译器可能会优化掉这步多余的步骤。但是这里还是有调用移动构造函数的可能性，所以删除构造函数了就<code>GG</code>了，编译失败。<strong>到了C++17这个优化直接变成语言强制性的要求了</strong>，所以完全没有<strong>移动构造</strong>这一步了，自然也不需要可访问的构造函数了，所以在<code>C++17</code>可以编译通过。</p>
<p><strong>这也就意味着，右值之间亦有差距</strong>。<code>prvalue</code>即纯右值可以直接复制消除构造对象（比如这里的<strong>非引用类型</strong>的函数返回值就是纯右值），但是<code>xvalue</code>也即亡值必须得有可调用的移动构造函数才行，也不行进行复制消除（<strong>右值引用类型</strong>的函数返回值就是亡值）。所以这里<code>std::move</code>反倒起了负面效果。</p>
<p>回到我们的问题，注意到<code>Any</code>有一个转化成右值引用类型的转换函数，所以如果遇到了这种情况就没办法了。但是再次通过巧妙地修改，又能解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Any</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">requires</span> std::is_copy_constructible_v&lt;T&gt;</span><br><span class="line">    <span class="keyword">operator</span> T&amp;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">requires</span> std::is_move_constructible_v&lt;T&gt;</span><br><span class="line">    <span class="keyword">operator</span> T&amp;&amp;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">requires</span><span class="params">(!std::is_copy_constructible_v&lt;T&gt; &amp;&amp; !std::is_move_constructible_v&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到我们这里对类型做了约束，如果是不可移动的类型（移动构造被删除），那就对应到了最后一个类型转换函数。直接产生<code>prvalue</code>构造对象，这样就巧妙地解决了这个问题了。写拷贝构造的约束是为了防止重载决议歧义（同时在最后可以顺便修复<code>MSVC</code>的<code>bug</code>）。</p>
<h2 id="结构体中含有其它结构体成员"><a href="#结构体中含有其它结构体成员" class="headerlink" title="结构体中含有其它结构体成员"></a>结构体中含有其它结构体成员</h2><p>事实上作者原本的思路很好，但是忽略了一个问题，那就是<strong>不只有数组类型在可以使用二重</strong><code>&#123;&#123; &#125;&#125;</code>初始化，结构体也是可以的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123; A x; <span class="type">int</span> y; &#125;;</span><br><span class="line">B&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">3</span> &#125;; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>所以如果这个位置有是结构体成员的话，就会导致错误的计数。所以我们需要先判断一个下这个位置是不是结构体，如果是的话，就不用对这个位置尝试求最大放置数量了，直接去求下一个位置就行了</p>
<p>那怎么判断当前位置成员是不是结构体呢？考虑下面这个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123; </span><br><span class="line">    A x; </span><br><span class="line">    <span class="type">int</span> y[<span class="number">2</span>]; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>手动枚举一下测试情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Any <span class="title">any</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">B&#123; any, any, any &#125;; <span class="comment">// ok</span></span><br><span class="line">B&#123; &#123;any&#125;, any, any &#125;; <span class="comment">// ok</span></span><br><span class="line">B&#123; &#123;any, any&#125;, any, any &#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">B&#123; any, &#123;any&#125;, any &#125;; <span class="comment">// error</span></span><br><span class="line">B&#123; any, &#123;any, any&#125;, any &#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p><code>OK</code>其实答案很显然了，那就是如果当前位置是结构体的话，可以往这个位置额外添加元素。注意到原本的<code>Total</code>即最大可能的元素数量是<code>3</code>，但是如果当前位置是结构体的话，放<code>4</code>个元素也是可以，但是如果是数组就不行了。我们利用这个特性来判断当前位置的是不是结构体，如果是的话，就跳去下一个位置，如果不是就在这个位置搜索最大能放置的元素。</p>
<p>其实就是在这个位置递归尝试放置元素，但是这里有一个问题是，当前位置的结构体成员中仍然可能含有不能默认初始化的成员。所以究竟放几个才能确定这个位置能被初始化呢？这还是不确定的，我这里设置的最大上线是<code>10</code>个，如果子结构体中不能默认初始化的成员位置在<code>10</code>之后的话这个方法就失败了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> pos, std::<span class="type">size_t</span> N = <span class="number">0</span>, std::<span class="type">size_t</span> Max = <span class="number">10</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="built_in">has_extra_elements</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> Total = <span class="built_in">member_count</span>&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(test_three_parts&lt;T, pos, N, Total - pos - <span class="number">1</span>&gt;())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (N + <span class="number">1</span> &lt;= Max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">has_extra_elements</span>&lt;T, pos, N + <span class="number">1</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个函数之后在把原来那个<code>serach</code>函数逻辑稍微改一下就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> pos, std::<span class="type">size_t</span> N </span>= <span class="number">0</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">search_max_in_pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> Total = <span class="built_in">member_count</span>&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!has_extra_elements&lt;T, pos&gt;())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... 原本的代码不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是加一个分支判断，如果当前位置没有额外的元素就直接返回<code>1</code>，如果有的就去搜索（数组的）最大边界。这样的话就解决了原作者的代码中中的问题了</p>
<p>仍然测试一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span>&#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">G</span>&#123; Y x; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">true_member_count</span>&lt;G&gt;() == <span class="number">2</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p><code>Nice</code>！！！太好了。</p>
<h2 id="MSVC-的-bug-和-GCC-的-bug"><a href="#MSVC-的-bug-和-GCC-的-bug" class="headerlink" title="MSVC 的 bug 和 GCC 的 bug"></a>MSVC 的 bug 和 GCC 的 bug</h2><p>作者在原文中提到的<code>GCC</code>和<code>MSVC</code>的问题我也一并找出来了，<code>MSVC</code>目前有一个<a href="https://developercommunity.visualstudio.com/t/MSVC-accepts-invalid-initialization-of-a/10541811">缺陷</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// requires std::is_copy_constructible_v&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">operator</span> T&amp;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x[<span class="number">2</span>]; &#125;;</span><br><span class="line">    A a&#123; Any&#123;&#125; &#125;; <span class="comment">// 这里 Any 转化成 int(&amp;)[2]类型了，即数组的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码可以正常编译，这意味着<code>MSVC</code>允许直接从数组的引用聚合初始化数组成员。但是这是<code>C++</code>标准所不允许的，这个<code>Bug</code>会导致在<code>MSVC</code>上对成员计数错误，解决办法其实很简单，前面我们已经顺便解决过这个问题了，只要把注释的那行加上就行了。因为数组是不可拷贝构造的类型，所以约束会把这个重载函数排除掉，这样就不会出现这个问题了。</p>
<p><code>GCC 13</code>也有一个严重的 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=113141">缺陷</a>，直接会导致<code>ice</code>，这个<code>bug</code>用下面几行代码就能复现出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">int</span>&amp;()&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">int</span>&amp; x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> F = <span class="keyword">requires</span>&#123; T&#123; &#123; Number&#123;&#125; &#125; &#125;; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!F&lt;X&gt;); <span class="comment">// internal compiler error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个显然是不应该导致<code>ice</code>的，而且只在<code>GCC 13</code>才有这个<code>bug</code>实在是很奇怪。测试代码在 <a href="https://godbolt.org/z/jW4YWYf1P">godbolt</a> 。<code>clang</code>没任何问题，但是<code>GCC 13</code>就直接内部编译器错误了。而<code>GCC 12</code>和<code>clang</code>的编译结果不一样<code>...</code>但是其实<code>clang</code>是对的。这也就是原作者文章里面说的<code>clang</code>和<code>gcc</code>不一致的地方。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>后来又和评论区的各位讨论了一番，上面的处理仍然有些欠缺考虑。一个典型的例子是，当成员变量的构造函数是模板函数的时候就会出错，例如<code>std::any</code>，原因是不知道调用类型转换函数和模板构造函数中的哪一个（重载决议失败）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::any any = <span class="built_in">Any</span>(<span class="number">0</span>); <span class="comment">// conversion from &#x27;Any&#x27; to &#x27;std::any&#x27; is ambiguous</span></span><br><span class="line"><span class="comment">// candidate: &#x27;Any::operator T&amp;() [with T = std::any]&#x27;</span></span><br><span class="line"><span class="comment">// candidate: &#x27;std::any::any(_Tp&amp;&amp;)</span></span><br></pre></td></tr></table></figure>

<p>但是目前还没有一个完美的解决办法能解决这个问题，不能直接检测<code>T</code>能不能由<code>Any</code>构造来解决这个问题，这会涉及到递归的约束，最后导致无法求解，从而编译错误。这里用了一个比较取巧的办法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Any</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">requires</span>(std::is_copy_constructible_v&lt;T&gt;)</span><br><span class="line">    <span class="keyword">operator</span> T&amp;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">requires</span>(std::is_move_constructible_v&lt;T&gt; &amp;&amp; !std::is_copy_constructible_v&lt;T&gt;)</span><br><span class="line">    <span class="keyword">operator</span> T&amp;&amp;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">requires</span>(!std::is_copy_constructible_v&lt;T&gt; &amp;&amp; !std::is_move_constructible_v&lt;T&gt; &amp;&amp; !std::is_constructible_v&lt;T, Empty&gt;)</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>就是声明了一个空类，然后尝试用这个空类能不能转换成类型<code>T</code>，如果不行就能说明<code>T</code>的构造函数应该不是模板函数，于是类型转换可以生效。如果可以，则说明<code>T</code>的构造函数是模板函数，要排除这个类型转换函数。当然了，如果<code>T</code>的构造函数有一些奇怪的约束，比如直接把<code>Empty</code>排掉，但是接受<code>Any</code>。这样话还是会导致错误，但是这属于刻意为之了，正常情况下基本是不会遇到这个问题的，这个问题可以算是解决了 </p>
<p>除此之外还有一个和引用相关的问题，如果结构体中含有不可拷贝&#x2F;复制类型的引用成员，那么也会失败，下面就拿左值引用举例子吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CanNotCopy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CanNotCopy</span>(<span class="type">const</span> CanNotCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; CanNotCopy&amp; x; &#125;;</span><br><span class="line"></span><br><span class="line">X x&#123; <span class="built_in">Any</span>(<span class="number">0</span>) &#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>这里<code>T</code>就会实例化成<code>CanNotCopy</code>类型。显然因为它不可拷贝，导致重载决议选到了<code>operator T()</code>上，然后实际产生的是右值没法绑定到左值引用，就编译错误了。那这个问题可能解决吗？非常困难。事实上，我们无法让下面两个表达式同时成立</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; CanNotCopy&amp; x; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123; CanNotCopy x; &#125;;</span><br><span class="line"></span><br><span class="line">X x&#123; <span class="built_in">Any</span>(<span class="number">0</span>) &#125;;</span><br><span class="line">Y y&#123; <span class="built_in">Any</span>(<span class="number">0</span>) &#125;; </span><br></pre></td></tr></table></figure>

<p>在这两个聚合初始化里面，类型转换函数实例化的<code>T</code>都是<code>CanNotCopy</code>类型，但是如果想让<code>x</code>，<code>y</code>都良构，那么就意味对于同一个<code>T</code>要选择两个不同的重载函数，第一个选<code>operator T&amp;()</code>，第二个选<code>operator T()</code>，但是这两个函数之间并没有哪个更优先，<code>C++</code>也没法对返回值进行重载，所以这是做不到的。一个可能的解决方案是写三种<code>Any</code>,分别转化成<code>T&amp;</code>，<code>T&amp;&amp;</code>，<code>T</code>然后在每个位置使用这三种进行尝试，这样的话倒是可以解决这个问题，<strong>但是可能会导致模板实例化个数以3 ^ N次方的速度增长</strong>。这种实现比之前的遍历方式加起来开销都要大，所以这里我就不做展示了，理论可行，实践上会累跨编译器</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文的全部代码都在 <a href="https://godbolt.org/z/scPP6WxbT">Compiler Explorer - C++</a> 上，三大编译器均通过（gcc版本是12），有很多测试代码，如果你找到其它的<code>concer case</code>欢迎留言讨论 </p>
<p>好了，这篇文章到这里就结束了。如果你耐心看完了全文，相比你也是和我一样，喜欢这些好玩的东西。这种东西最有趣的地方就在于，利用<code>C++</code>暴露的一点点接口，去一步步扩展它，最后实现非常漂亮的接口出来。当然对于作者来说其实并不漂亮<code>OvO</code>。总之这种东西就像是游戏一样，是日常的消遣，没事给<code>C++</code>编译器找找<code>bug</code>，钻研这些犄角旮旯的特性，也是一份乐趣。如果非要谈实际价值，<strong>其实这种东西几乎不可能在实际的代码生产环境中使用</strong>。首先通过实例化大量模板来寻找结构体的字段数量，会大大拖慢编译速度，而且即使花费如此大的功夫，也只是实现了对聚合类型的遍历，还不支持其的非聚合类型。不仅副作用强，而且主要功能也不强。权衡一下考虑也是非常不值当了，对于这种需要类似反射的需求的时候，在<code>C++</code>加入静态反射之前（真正用上也许还得过十年！？），目前真正可行的自动化方案是采用代码生成来做这个事情。</p>
<p>我也有相关的文章详细介绍了相关的原理，不依赖于这些奇淫巧技，真正可用于实际项目中的方案： </p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">写给 C++ 程序员的反射教程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669358870</span></span></span></a></p>
<p><strong>当然如果用这些功能仅仅是为了log，debug或者study的话</strong>，而不是用于任何核心的代码部分，又不想引入很重的依赖，那这些东西用一用也未尝不可。我专门写了一个<code>C++20</code>的库，把这些有用的奇淫巧技都合并起来了，方便进行<code>log</code>，<code>debug</code>之类的。目前还在更新中，欢迎<code>star</code>和报告问题呐</p>
<p><a target="_blank" href="https://github.com/16bit-ykiko/magic-cpp" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">magic-cpp</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://github.com/16bit-ykiko/magic-cpp</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>C++ 中如何优雅进行 enum 到 string 的转换 ？</title>
    <url>/680412313/</url>
    <content><![CDATA[<h1 id="拒绝硬编码"><a href="#拒绝硬编码" class="headerlink" title="拒绝硬编码"></a>拒绝硬编码</h1><p>定义一个<code>enum</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尝试打印</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Color color = RED;</span><br><span class="line">std::cout &lt;&lt; color &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// output =&gt; 0</span></span><br></pre></td></tr></table></figure>

<p>如果需要枚举作为日志输出，我们不希望在查看日志的时候，还要人工去根据枚举值去查找对应的字符串，麻烦并且不直观。我们希望直接输出枚举值对应的字符串，比如<code>RED</code>，<code>GREEN</code>，<code>BLUE</code>。</p>
<p>考虑使用一个数组当<code>map</code>，将枚举值作为<code>key</code>，将字符串作为<code>value</code>，这样就可以通过枚举值直接查找到对应的字符串了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string_view color_map[] = &#123;</span><br><span class="line">    <span class="string">&quot;RED&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GREEN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;BLUE&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是当枚举数量很多的时候，手写并不方便，非常繁琐。<strong>具体表现为，如果我们想增加若干枚举定义，那字符串映射表相应的内容也需要修改，当数量达到上百个的时候，很可以会有疏漏。或者接手一个别人的项目，发现他有一大堆枚举，内容太多，手写非常耗时间。</strong></p>
<p>需要寻找解决办法，能自动的进行相关的修改。在别的语言中，如 Java，C#，Python，可以轻松的通过反射实现这个功能。但是 C++ 目前并没有反射，故此路不通。目前这个问题主要有三种解决方案。</p>
<h1 id="模板打表"><a href="#模板打表" class="headerlink" title="模板打表"></a>模板打表</h1><p>这一小节介绍的内容已经有人提前封装好了，可以直接使用 <a href="https://github.com/Neargye/magic_enum">magic enum</a> 这个库。下面主要是对这个库的原理进行解析，为了方便展示，将用 C++20 实现，实际上 C++17 就可以。</p>
<p>在三大主流编译器中，有一些特殊<strong>宏变量</strong>。GCC 和 Clang 中的<code>__PRETTY_FUNCTION__</code>，MSVC 中的<code>__FUNCSIG__</code>。这几个宏变量会在<strong>编译期间被替换成函数的签名</strong>，如果该函数是模板函数则会将模板实例化的信息也输出（也可以使用 C++20 加入标准的 <a href="https://en.cppreference.com/w/cpp/utility/source_location/function_name">source_location</a>，它具有和这些宏类似的效果）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_fn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ || __clang__</span></span><br><span class="line">    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _MSC_VER</span></span><br><span class="line">    std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_fn</span>&lt;<span class="type">int</span>&gt;(); </span><br><span class="line"><span class="comment">// gcc and clang =&gt; void print_fn() [with T = int]</span></span><br><span class="line"><span class="comment">// msvc =&gt; void __cdecl print_fn&lt;int&gt;(void)</span></span><br></pre></td></tr></table></figure>

<p>特别的，当模板参数是枚举常量的时候，会输出枚举常量的名称</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_fn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ || __clang__</span></span><br><span class="line">    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _MSC_VER</span></span><br><span class="line">    std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_fn</span>&lt;RED&gt;();</span><br><span class="line"><span class="comment">// gcc and clang =&gt; void print_fn() [with auto T = RED]</span></span><br><span class="line"><span class="comment">// msvc =&gt; void __cdecl print_fn&lt;RED&gt;(void)</span></span><br></pre></td></tr></table></figure>

<p>可以发现，在特定的位置出现了枚举名。通过简单的字符串裁剪，便能得到我们想要的内容了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> value&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">enum_name</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string_view name;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ || __clang__</span></span><br><span class="line">    name = __PRETTY_FUNCTION__;</span><br><span class="line">    std::<span class="type">size_t</span> start = name.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>) + <span class="number">2</span>;</span><br><span class="line">    std::<span class="type">size_t</span> end = name.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    name = std::string_view&#123; name.<span class="built_in">data</span>() + start, end - start &#125;;</span><br><span class="line">    start = name.<span class="built_in">rfind</span>(<span class="string">&quot;::&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _MSC_VER</span></span><br><span class="line">    name = __FUNCSIG__;</span><br><span class="line">    std::<span class="type">size_t</span> start = name.<span class="built_in">find</span>(<span class="string">&#x27;&lt;&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    std::<span class="type">size_t</span> end = name.<span class="built_in">rfind</span>(<span class="string">&quot;&gt;(&quot;</span>);</span><br><span class="line">    name = std::string_view&#123; name.<span class="built_in">data</span>() + start, end - start &#125;;</span><br><span class="line">    start = name.<span class="built_in">rfind</span>(<span class="string">&quot;::&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> start == std::string_view::npos ? name : std::string_view&#123;</span><br><span class="line">            name.<span class="built_in">data</span>() + start + <span class="number">2</span>, name.<span class="built_in">size</span>() - start - <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">enum_name</span>&lt;RED&gt;() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// output =&gt; RED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功满足我们的需求。但是事情并没有结束，这种形式要求枚举是模板参数，那就只支持编译期常量。但是其实绝大部分时候，我们用的枚举都是运行期变量，怎么办呢？静态转动态，只要打个表就行了，考虑通过模板元编程生成一个<code>array</code>，其中每个元素就是<code>index</code>对应枚举的字符串表示。一个问题是，这个数组应该多大，这就需要我们来获取枚举项的数量了。<strong>一种比较直接的办法是，直接在枚举中定义一对用来标记的首尾项，这样直接相减就能获取到枚举的最大数量了</strong>。但是很多时候，我们并不能修改枚举定义，还好这里有一个小 trick 能解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> Color color = <span class="built_in">static_cast</span>&lt;Color&gt;(<span class="number">-1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">enum_name</span>&lt;color&gt;() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// output =&gt; (Color)2</span></span><br></pre></td></tr></table></figure>

<p>可以发现，如果这个整数没有对应的枚举项，那么最后就不会输出对应的枚举名，而是带有括号的强制转换表达式。这样只需要判断下得到的字符串中有没有<code>)</code>就知道对应的枚举项是否存在了。递归判断就可以找出最大的枚举值了（这样查找适用范围有限，如分散枚举值，可能相对困难一点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N </span>= <span class="number">0</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">enum_max</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = <span class="built_in">static_cast</span>&lt;T&gt;(N);</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(enum_name&lt;value&gt;().find(<span class="string">&quot;)&quot;</span>) == std::string_view::npos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> enum_max&lt;T, N + 1&gt;<span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过<code>make_index_sequence</code>生成一个对应的长度数组就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">requires</span> std::is_enum_v&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">enum_name</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> num = <span class="built_in">enum_max</span>&lt;T&gt;();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> names = []&lt;std::<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;)&#123;</span><br><span class="line">        <span class="keyword">return</span> std::array&lt;std::string_view, num&gt;&#123; </span><br><span class="line">            enum_name&lt;<span class="built_in">static_cast</span>&lt;T&gt;(Is)&gt;()... </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;(std::make_index_sequence&lt;num&gt;&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> names[<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(value)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Color color = RED;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">enum_name</span>(color) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// output =&gt; RED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步可以考虑支持 bitwidth enum，也就是<code>RED | BLUE</code>这种形式的枚举，这里就不继续展开了。</p>
<p>这种方法的缺点很明显，通过模板实例化来打表，其实会很大的拖慢编译速度。如果<code>enum</code>中的数量较多，在一些对常量求值效率较低的编译器上，如 MSVC，可能会增加<strong>几十秒甚至更长</strong>的编译时间。所以一般只适用于小型枚举。优点是轻量级，开箱即用，其它的什么也不用做。</p>
<h1 id="外部代码生成"><a href="#外部代码生成" class="headerlink" title="外部代码生成"></a>外部代码生成</h1><p>既然手写字符串转枚举很麻烦，那么写个脚本生成代码不就行了？的确如此，我们可以使用 libclang 的 python bind 轻松的完成这项工作。具体如何使用这个工具，可以参考 <a href="https://16bit-ykiko.github.io/about-me/669360731">使用 clang 工具自由的支配 C++ 代码吧</a>，下面只展示实现效果的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clang.cindex <span class="keyword">as</span> CX</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_enum_to_string</span>(<span class="params">enum: CX.Cursor</span>):</span><br><span class="line">    branchs = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> enum.get_children():</span><br><span class="line">        branchs += <span class="string">f&#x27;case <span class="subst">&#123;child.enum_value&#125;</span>: return &quot;<span class="subst">&#123;child.spelling&#125;</span>&quot;;\n&#x27;</span></span><br><span class="line">    code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">std::string_view <span class="subst">&#123;enum.spelling&#125;</span>_to_string(<span class="subst">&#123;enum.spelling&#125;</span> value) &#123;&#123;</span></span><br><span class="line"><span class="string">    switch(value) &#123;&#123;</span></span><br><span class="line"><span class="string"><span class="subst">&#123;branchs&#125;</span>&#125;&#125;&#125;&#125;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: CX.Cursor</span>):</span><br><span class="line">    <span class="keyword">if</span> node.kind == CX.CursorKind.ENUM_DECL:</span><br><span class="line">        <span class="built_in">print</span>(generate_enum_to_string(node))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.get_children():</span><br><span class="line">        traverse(child)</span><br><span class="line"></span><br><span class="line">index = CX.Index.create()</span><br><span class="line">tu = index.parse(<span class="string">&#x27;main.cpp&#x27;</span>)</span><br><span class="line">traverse(tu.cursor)</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是最后生成的代码，可以直接生成<code>.cpp</code>文件，放在固定目录下面，然后构建之前运行一下这个脚本就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string_view <span class="title">enum_to_string</span><span class="params">(Color value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(value) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;RED&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="string">&quot;BLUE&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="string">&quot;GREEN&quot;</span>;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>优点，非侵入式，可以用于大数量的枚举。缺点，有外部依赖，需要将代码生成加入到编译流程里面。可能会使编译流程变得很复杂。</p>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>上面的两种方式都是非侵入式的。也就是说，可能你拿到了一个别人的库，不能修改它的代码，只好这么做了。如果是完全由自己定义枚举呢？其实可以在定义阶段就特殊处理，以方便后续的使用。比如（代码开头的注释表示当前文件名）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color.def</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COLOR_ENUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_ENUM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">COLOR_ENUM</span>(RED)</span><br><span class="line"><span class="built_in">COLOR_ENUM</span>(GREEN)</span><br><span class="line"><span class="built_in">COLOR_ENUM</span>(BLUE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COLOR_ENUM</span></span><br></pre></td></tr></table></figure>

<p>然后在要使用的地方，通过修改宏定义来生成代码就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_ENUM(x) x,</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Color.def&quot;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string_view <span class="title">color_to_string</span><span class="params">(Color value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(value)&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_ENUM(x) case x: return #x;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Color.def&quot;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，只要在<code>def</code>文件里面进行相关的增加和修改就行了。之后如果要遍历<code>enum</code>什么的，也可以直接定义一个宏来生成代码就行了，非常方便。事实上，对于大数量的枚举，有很多开源项目都采取这种方案。例如 clang 在定义<code>TokenKind</code>的时候，就是这么做的，相关的代码请参考  <a href="https://github.com/stuartcarnie/clang/blob/master/include/clang/Basic/TokenKinds.def">Token.def</a>。由于 clang 要适配多种语言前端，最后总计的<code>TokenKind</code>有几百个之多。如果不这样做，进行<code>Token</code>的增加和修改会十分困难。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>非侵入式且枚举数量较少，编译速度不是很重要，那就使用模板打表（至少要求 C++17）</li>
<li>非侵入式且枚举数量较多，编译速度很重要，那就使用外部代码生成</li>
<li>侵入式，可以直接使用宏</li>
</ul>
<p>年年月月盼反射，还是不知道什么时候才能进入标准呢。想要提前了解 C++ 静态反射的小伙伴，可以看</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/661692275" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++26 静态反射提案解析</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/661692275</span></span></span></a></p>
<p>或者还不知道反射是什么的小伙伴，可以参考这篇文章的内容</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/669358870" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">写给 C++ 程序员的反射教程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/669358870</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>C++ 中 constexpr 的发展史!（上）</title>
    <url>/682031684/</url>
    <content><![CDATA[<p>几个月前，我写了一篇介绍 C++ 模板的文章</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/655902377" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">雾里看花：真正意义上的理解 C++ 模板</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/655902377</span></span></span></a></p>
<p>理清了现代 C++ 中模板的地位。其中用 constexpr function 替代模板进行编译期计算可以说是现代 C++ 最重要的改进之一了。 constexpr 本身其实并不难以理解，非常直观。但是由于几乎每个 C++ 版本都在改进它，所以不同的 C++ 版本可以使用的内容差别很大，有时候可能给人一种<code>inconsistency</code>的感觉。</p>
<p>刚好最近我偶然间读到了这篇文章：<a href="https://pvs-studio.com/en/blog/posts/cpp/0909/">Design and evolution of constexpr in C++</a>，全面介绍了 C++ 中 constexpr 的发展史，写的非常好。于是便想将其翻译到中文社区。</p>
<p>但是有趣的是，这篇文章其实也是翻译的。文章的原作者是一位俄罗斯人，文章最初也是发表在俄罗斯的论坛上。这是作者的邮箱：<code>izaronplatz@gmail.com</code>，我已经和他联系过了，他回复到：</p>
<blockquote>
<p> It’s always good to spread knowledge in more languages.</p>
</blockquote>
<p>也就是允许翻译了。但是我并不懂俄文，所以主要参考了原文结构，而主体部分，基本都是我重新叙述的。</p>
<p>原文内容较长，故分为上下两篇，这是上篇</p>
<h1 id="很神奇吗？"><a href="#很神奇吗？" class="headerlink" title="很神奇吗？"></a>很神奇吗？</h1><p>constexpr 是当代 C++ 中最神奇的关键字之一。它使得某些代码可以在编译期执行。</p>
<p>随着时间的推移，constexpr 的功能越来越强大。现在几乎可以在编译时计算中使用标准库的所有功能。</p>
<p>constexpr 的发展历史可以追溯到早期版本的 C++。通过研究标准提案和编译器源代码，我们可以了解这一语言特性是如何一步步地构建起来的，为什么会以这样的形式存在，实际上 constexpr 表达式是如何计算的，未来有哪些可能的功能，以及哪些功能可能会存在但没有被纳入标准。</p>
<p>本文适合于任何人，无论你是否了解 constexpr ！</p>
<h1 id="C-98-03：我比你更-const"><a href="#C-98-03：我比你更-const" class="headerlink" title="C++98&#x2F;03：我比你更 const"></a>C++98&#x2F;03：我比你更 const</h1><p>在 C++ 中，有些地方需要整数常量（比如内建数组类型的长度），这些值必须在编译期就确定。C++ 标准允许通过简单的表达式来构造常量，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EPlants</span>&#123;</span><br><span class="line">    APRICOT = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    LIME = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    PAPAYA = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    TOMATO = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    PEPPER = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    FRUIT = APRICOT | LIME | PAPAYA,</span><br><span class="line">    VEGETABLE = TOMATO | PEPPER,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> V&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> v = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(v)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> + <span class="number">4</span> + <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> &lt;&lt; (<span class="number">5</span> | <span class="built_in">sizeof</span>(<span class="type">int</span>)):</span><br><span class="line">        <span class="built_in">case</span> (<span class="number">12</span> &amp; <span class="number">15</span>) + PEPPER: <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f1 = <span class="built_in">foo</span>&lt;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&gt;();</span><br><span class="line"><span class="type">int</span> f2 = foo&lt;((<span class="number">1</span> &lt; <span class="number">2</span>) ? <span class="number">10</span> * <span class="number">11</span> : VEGETABLE)&gt;();</span><br></pre></td></tr></table></figure>

<p>这些表达式在<code>[expr.const]</code>小节中被定义，并且被叫做。它们只能包含： </p>
<ul>
<li>字面量：<code>1</code>,<code>&#39;A&#39;</code>,<code>true</code>,<code>...</code> </li>
<li>枚举值 </li>
<li>整数或枚举类型的模板参数（例如<code>template&lt;int v&gt;</code>中的<code>v</code>）</li>
<li><code>sizeof</code>表达式</li>
<li>由常量表达式初始化的<code>const</code>变量</li>
</ul>
<p>前几项都很好理解的，对于最后一项稍微有点复杂。如果一个变量具有 <a href="https://en.cppreference.com/w/cpp/language/storage_duration">静态储存期</a>，那么在常规情况下，它的内存会被填充为<code>0</code>，之后在程序开始执行的时候改变。但是对于上述的变量来说，这太晚了，需要在编译结束之前就计算出它们的值。</p>
<p>在 C++98&#x2F;03 当中有两种类型的 <a href="https://en.cppreference.com/w/cpp/language/initialization#Static_initialization">静态初始化</a>： </p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/zero_initialization">零初始化</a> 内存被填充为<code>0</code>，然后在程序执行期间改变 </li>
<li><a href="https://en.cppreference.com/w/cpp/language/constant_initialization">常量初始化</a> 使用常量表达式进行初始化，内存（如果需要的话）立即填充为计算出来的值</li>
</ul>
<blockquote>
<p>所有其它的初始化都被叫做 <a href="https://en.cppreference.com/w/cpp/language/initialization#Dynamic_initialization">动态初始化</a>，这里我们不考虑它们。</p>
</blockquote>
<p>让我们看一个包含两种静态初始化的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">13</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v1 = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span>;              <span class="comment">// const initialization</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v2 = <span class="number">15</span> * v1 + <span class="number">8</span>;                <span class="comment">// const initialization</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v3 = <span class="built_in">foo</span>() + <span class="number">5</span>;                  <span class="comment">// zero initialization</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v4 = (<span class="number">1</span> &lt; <span class="number">2</span>) ? <span class="number">10</span> * v3 : <span class="number">12345</span>;  <span class="comment">// zero initialization</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v5 = (<span class="number">1</span> &gt; <span class="number">2</span>) ? <span class="number">10</span> * v3 : <span class="number">12345</span>;  <span class="comment">// const initialization</span></span><br></pre></td></tr></table></figure>

<p>变量<code>v1</code>, <code>v2</code>和<code>v5</code>都可以作为常量表达式，可以用作模板参数，<code>switch</code>的<code>case</code>，<code>enum</code>的值，等等。而<code>v3</code>和<code>v4</code>则不行。即使我们能明显看出<code>foo() + 5</code>的值是<code>18</code>，但在那时还没有合适的语义来表达这一点。</p>
<p>由于常量表达式是递归定义的，如果一个表达式的某一部分不是常量表达式，那么整个表达式就不是常量表达式。在这个判断过程中，只考虑实际计算的表达式，所以<code>v5</code>是常量表达式，但<code>v4</code>不是。</p>
<p>如果没有获取常量初始化的变量的地址，编译器就可以不为它分配内存。所以我们可以通过取地址的方式，来强制编译器给常量初始化的变量预留内存（其实如果没有显式取地址的话，普通的局部变量也可能被优化掉，任何不违背 <a href="https://en.cppreference.com/w/cpp/language/as_if">as-if</a> 原则的优化都是允许的。可以考虑使用<code>[[gnu::used]]</code>这个 attribute 标记避免变量被优化掉）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; v1 &lt;&lt; &amp;v1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v2 &lt;&lt; &amp;v2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v3 &lt;&lt; &amp;v3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v4 &lt;&lt; &amp;v4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v5 &lt;&lt; &amp;v5 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译上述代码并查看符号表（环境是 windows x86-64）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ --std=c++98  -c main.cpp </span><br><span class="line">$ objdump -t -C main.o</span><br><span class="line"></span><br><span class="line">(sec  6)(fl 0x00)(ty    0)(scl   3) (nx 0) 0x0000000000000000 v1</span><br><span class="line">(sec  6)(fl 0x00)(ty    0)(scl   3) (nx 0) 0x0000000000000004 v2</span><br><span class="line">(sec  3)(fl 0x00)(ty    0)(scl   3) (nx 0) 0x0000000000000000 v3</span><br><span class="line">(sec  3)(fl 0x00)(ty    0)(scl   3) (nx 0) 0x0000000000000004 v4</span><br><span class="line">(sec  6)(fl 0x00)(ty    0)(scl   3) (nx 0) 0x0000000000000008 v5</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">(sec  3)(fl 0x00)(ty    0)(scl   3) (nx 1) 0x0000000000000000 .bss</span><br><span class="line">(sec  4)(fl 0x00)(ty    0)(scl   3) (nx 1) 0x0000000000000000 .xdata</span><br><span class="line">(sec  5)(fl 0x00)(ty    0)(scl   3) (nx 1) 0x0000000000000000 .pdata</span><br><span class="line">(sec  6)(fl 0x00)(ty    0)(scl   3) (nx 1) 0x0000000000000000 .rdata</span><br></pre></td></tr></table></figure>

<p>可以发现在我的 GCC 14 上，零初始化的变量<code>v3</code>和<code>v4</code>被放在<code>.bss</code>段，而常量初始化的变量<code>v1</code>, <code>v2</code>,<code>v5</code>被放在<code>.rdata</code>段。操作系统会对<code>.rdata</code>段进行保护，使其处于只读模式，尝试写入会导致段错误。</p>
<p>从上述的差异可以看出，一些<code>const</code>变量比其它的更加<code>const</code>。但是在当时我们并没有办法检测出这种差异（后来的 C++20 引入了 <a href="https://en.cppreference.com/w/cpp/language/constinit">constinit</a> 来确保一个变量进行常量初始化）。</p>
<h1 id="0-∞：编译器中的常量求值器"><a href="#0-∞：编译器中的常量求值器" class="headerlink" title="0-∞：编译器中的常量求值器"></a>0-∞：编译器中的常量求值器</h1><p>为了理解常量表达式是如何求值的，我们需要简单了解编译器的构造。不同编译器的处理方法大致相同，接下来将以 Clang&#x2F;LLVM 为例</p>
<p>总的来说，编译器可以看做由以下三个部分组成：</p>
<ul>
<li><strong>前端（Front-end）</strong>：将 C&#x2F;C++&#x2F;Rust 等源代码转换为 LLVM IR（一种特殊的中间表示）。Clang 是 C 语言家族的编译器前端</li>
<li><strong>中端（Middle-end）</strong>：根据相关的设置对 LLVM IR 进行优化</li>
<li><strong>后端（Back-end）</strong>：将 LLVM IR 转换为特定平台的机器码： x86&#x2F;Arm&#x2F;PowerPC 等等</li>
</ul>
<p>对于一个简单的编程语言，通过调用 LLVM，<code>1000</code>行就能实现一个编译器。你只需要负责实现语言前端就行了，后端交给 LLVM 即可。甚至前端也可以考虑使用 lex&#x2F;yacc 这样的现成的语法解析器。</p>
<p>具体到编译器前端的工作，例如这里提到的 Clang，可以分为以下三个阶段：</p>
<ul>
<li><strong>词法分析</strong>：将源文件转换为 Token Stream，例如 <code>[]() &#123; return 13 + 37; &#125;</code> 被转换为 <code>[</code>, <code>]</code>, <code>(</code>, <code>)</code>, <code>&#123;</code>, <code>return</code>, <code>13</code>, <code>+</code>, <code>37</code>, <code>;</code>, <code>&#125;</code></li>
<li><strong>语法分析</strong>：产生 Abstract Syntax Tree（抽象语法树），就是将上一步中的 Token Stream 转换为类似于下面这样的递归的树状结构</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lambda-expr </span><br><span class="line">└── body </span><br><span class="line">    └── return-expr </span><br><span class="line">        └── plus-expr </span><br><span class="line">            ├── number 13</span><br><span class="line">            └── number 37</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码生成</strong>：根据给定的 AST 生成 LLVM IR</li>
</ul>
<p>因此，常量表达式的计算（以及相关的事情，如模板实例化）严格发生在 C++ 编译器的前端，而 LLVM 不涉及此类工作。这种处理常量表达式（从 C++98 的简单表达式到 C++23 的复杂表达式）的工具被称为。</p>
<p>多年来，对常量表达式的限制一直在不断放宽，而 Clang 的常量求值器相应地变得越来越复杂，直到管理 memory model（内存模型）。有一份旧的 <a href="https://clang.llvm.org/docs/InternalsManual.html#constant-folding-in-the-clang-ast">文档</a>，描述 C++98&#x2F;03 的常量求值。由于当时的常量表达式非常简单，它们是通过分析语法树进行 （常量折叠）来进行的。由于在语法树中，所有的算术表达式都已经被解析为子树的形式，因此计算常量就是简单地遍历子树。</p>
<p>常量计算器的源代码位于 <a href="https://clang.llvm.org/doxygen/ExprConstant_8cpp_source.html">lib&#x2F;AST&#x2F;ExprConstant.cpp</a>，在撰写本文时已经扩展到将近 17000 行。随着时间的推移，它学会了解释许多内容，例如循环（<code>EvaluateLoopBody</code>），所有这些都是在语法树上进行的。</p>
<p>常量表达式与运行时代码有一个重要的区别：它们必须不引发 undefined behavior（未定义行为）。如果常量计算器遇到未定义行为，编译将失败。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">error: <span class="keyword">constexpr</span> variable <span class="string">&#x27;foo&#x27;</span> must be initialized by a constant expression</span><br><span class="line">    <span class="number">2</span> | <span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="number">13</span> + <span class="number">2147483647</span>;               </span><br><span class="line">      |               ^     ~~~~~~~~~~~~~~~</span><br><span class="line">note: value <span class="number">2147483660</span> is outside the range of representable values of type <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    <span class="number">2</span> | <span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="number">13</span> + <span class="number">2147483647</span>;</span><br></pre></td></tr></table></figure>

<p>因此在有些时候可以用它们来检测程序中的潜在错误。</p>
<h1 id="2003：真的能-macro-free-吗？"><a href="#2003：真的能-macro-free-吗？" class="headerlink" title="2003：真的能 macro free 吗？"></a>2003：真的能 macro free 吗？</h1><p><strong>标准的改变是通过 proposals（提案）进行的</strong></p>
<blockquote>
<p>在哪里可以找到提案？它们是由什么组成的？</br></br>所有的有关 C++ 标准的提案都可以在 <a href="https://open-std.org/JTC1/SC22/WG21/">open-std.org</a> 上找到。它们中的大多数都有详细的描述并且易于阅读。通常由如下部分组成： </br></br>-  当前遇到的问题 </br>-  标准中相关措辞的的链接 </br>-  上述问题的解决方案 </br>-  建议对标准措辞进行的修改 </br>-  相关提案的链接（提案可能有多个版本或者需要和其它提案进行对比） </br>-  在高级提案中，往往还会附带上实验性实现的链接</br></br>可以通过这些提案来了解 C++ 的每个部分是如何演变的。并非存档中的所有提案最终都被接受，但是它们都对 C++ 的发展有着重要的影响。</br></br>通过提交新提案，任何人都可以参与到 C++ 的演变过程中来。</p>
</blockquote>
<p><code>2003</code>年的提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1521.pdf">N1521 Generalized Constant Expressions</a> 指出一个问题。如果一个表达式中的某个部分含有函数调用，那么整个表达式就不能是常量表达式，即使这个函数最终能够被常量折叠。这迫使人们在处理复杂常量表达式的时候使用宏，甚至一定程度上导致了宏的滥用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">square</span>(<span class="number">9</span>)</span><br><span class="line">std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() </span><br><span class="line"><span class="comment">// 理论上可用于常量表达式, 但是实际上不能</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SQUARE</span>(<span class="number">9</span>)</span><br><span class="line">INT_MAX</span><br><span class="line"><span class="comment">// 被迫使用宏代替</span></span><br></pre></td></tr></table></figure>

<p>因此，建议引入 函数的概念，允许在常量表达式中使用这些函数。如果希望一个函数是常值函数，那么它必须满足</p>
<ul>
<li>inline ，non-recursive，并且返回类型不是 void</li>
<li>仅由单一的 return expr 语句组成，并且在把 expr 里面的函数参数替换为常量表达式之后，得到的仍然是一个常量表达式</li>
</ul>
<p>如果这样的函数被调用，并且参数是常量表达式，那么函数调用表达式也是常量表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;         <span class="comment">// constant-valued</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">long_max</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2147483647</span>; &#125; <span class="comment">// constant-valued</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x; &#125;   <span class="comment">// constant-valued</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ++x; &#125;             <span class="comment">// non constant-valued</span></span><br></pre></td></tr></table></figure>

<p>这样的话，不需要修改任何代码，最开始的例子中的<code>v3</code>和<code>v4</code>也可以被用作常量表达式了，因为<code>foo</code>被认为是常值函数。</p>
<p>该提案认为，可以考虑进一步支持下面这种情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cayley</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">cayley</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">value</span>(<span class="built_in">square</span>(a) + <span class="built_in">square</span>(b)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;cayley(98, -23)&gt; s; <span class="comment">// same as bitset&lt;10133&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为成员<code>value</code>是<code>totally constant</code>的，在构造函数中通过两次调用常值函数进行初始化。换句话说，根据该提案的一般逻辑，此代码可以大致转换为以下形式（将变量和函数移到结构体之外）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 cayley::cayley(98, -23)的构造函数调用和 operator int()</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cayley_98_m23_value = <span class="built_in">square</span>(<span class="number">98</span>) + <span class="built_in">square</span>(<span class="number">-23</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cayley_98_m23_operator_int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cayley_98_m23_value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 bitset</span></span><br><span class="line">std::bitset&lt;cayley_98_m23_operator_int()&gt; s; <span class="comment">// same as bitset&lt;10133&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是和变量一样，程序员无法确定一个函数是否为常值函数，只有编译器知道。</p>
<blockquote>
<p>提案通常不会深入到编译器实现它们的细节。上述提案表示，实现它不应该有任何困难，只需要稍微改变大多数编译器中存在的常量折叠即可。然而，提案与编译器实现密切相关。如果提案无法在合理时间内实现，很可能不会被采纳。从后来的视角来看，许多大的提案最后被分成了多个小的提案逐步实现</p>
</blockquote>
<h1 id="2006-2007：当一切浮出水面"><a href="#2006-2007：当一切浮出水面" class="headerlink" title="2006-2007：当一切浮出水面"></a>2006-2007：当一切浮出水面</h1><p>幸运的是，三年后，这个提案的后续修订版 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a> 认识到了过多的隐式特性是不好的，程序员应该有办法确保一个变量可以被用作常量，如果不满足相应的条件应该导致编译错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = <span class="number">2</span> * S::size;                 <span class="comment">// dynamic initialization</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S::size = <span class="number">256</span>;                       <span class="comment">// const initialization</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>(); <span class="comment">// dynamic initialization</span></span><br></pre></td></tr></table></figure>

<p>根据程序员的设想，<code>limit</code>应该被常量初始化，但事实并非如此，因为<code>S::size</code>被定义在<code>limit</code>之后，定义的太晚了。可以通过 C++20 加入的 <a href="https://en.cppreference.com/w/cpp/language/constinit">constinit</a> 来验证这一点，<code>constinit</code>保证一个变量进行常量初始化，如果不能进行常量初始化，则会编译错误。</p>
<p>在新的提案中，常值函数被<strong>重命名</strong>为 ，对它们的要求保持不变。但现在，为了能够在常量表达式中使用它们，<strong>必须</strong>使用 constexpr 关键字进行声明。此外，如果函数体不符合相关的要求，将会编译失败。同时建议将一些标准库的函数（如<code>std::numeric_limits</code>中的函数）标记为 constexpr，因为它们符合相关的要求。<strong>变量</strong>或类成员也可以声明为 constexpr，这样的话，如果变量不是通过常量表达式进行初始化，将会编译失败。</p>
<p>用户自定义<code>class</code>的 constexpr 构造函数也合法化了。该构造函数必须具有空函数体，并用常量表达式初始化成员。隐式生成的构造函数将尽可能的被标记为 constexpr。对于 constexpr 的对象，析构函数必须是平凡的，因为非平凡的析构函数通常会在正在执行的程序上下文中做一些改变，而在 constexpr 计算中不存在这样的上下文。</p>
<p>以下是包含 constexpr 的示例类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">complex</span><span class="params">(<span class="type">double</span> r, <span class="type">double</span> i)</span> : re(r), im(i) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">real</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">imag</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> re;</span><br><span class="line">    <span class="type">double</span> im;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> complex <span class="title">I</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>在提案中，像<code>I</code>这样的对象被称为用户自定义字面量。”字面量” 是 C++ 中的基本实体。就像 “简单” 字面量（数字、字符等）立即被嵌入到汇编指令中，字符串字面量存储在类似<code>.rodata</code>的段中那样，用户定义的字面量也在其中占有一席之地。</p>
<p>现在 constexpr 变量不仅可以是数字和枚举，还可以是 <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">literal type</a>，在此提案中引入了（尚不支持引用类型）。literal type 是可以传递给 constexpr 函数的类型，这些类型足够简单，以至于编译器可以在常量计算中支持它们。</p>
<p>constexpr 关键字最后成为了一个 ），类似于 这样仅用作标记。在讨论后，决定不创建新的 <a href="https://en.cppreference.com/w/cpp/language/storage_duration">储存期类型</a> 和新的类型限定符，并且也决定不允许将其用于函数参数，以免使得函数的<a href="https://en.cppreference.com/w/cpp/language/overload_resolution">overload resolution</a>规则变得过于复杂。</p>
<h1 id="2007：试着让标准库更加-constexpr？"><a href="#2007：试着让标准库更加-constexpr？" class="headerlink" title="2007：试着让标准库更加 constexpr？"></a>2007：试着让标准库更加 constexpr？</h1><p>在这一年，提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2349.pdf">N2349 Constant Expressions in the Standard Library</a> 被提出，其中标记了一些函数和常量为   constexpr，还有一些容器的函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitset</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">bitset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">bitset</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>[](<span class="type">size_t</span>) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造函数通过 constant-expression 初始化类的成员，其他函数内部含有单个 return 语句，符合当前的规定。</p>
<p>所有关于 constexpr 的提案中，超过一半是建议将标准库中的某些函数标记为 constexpr。就内容而言，其实并不是十分有趣，因为它们并没有导致核心语言规则的改变。</p>
<h1 id="2008年：停停…机问题？我才不管！"><a href="#2008年：停停…机问题？我才不管！" class="headerlink" title="2008年：停停…机问题？我才不管！"></a>2008年：停停…机问题？我才不管！</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最初，提案提出者希望允许在 constexpr 函数中进行递归调用，但出于谨慎起见，这一做法被禁止了。然而，在审查过程中，由于措辞的变化，意外地允许了这种做法。CWG 认为递归具有足够的使用情景，因此应该允许它们。如果允许函数之间相互递归调用，还需要允许 constexpr 函数的 。在 constexpr 函数中调用未定义的 constexpr 函数时，应该在需要常量求值的上下文中进行诊断。这一点在 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2826.html">N2826</a> 被澄清</p>
<p>既然有递归，那就可能出现无穷递归。一个函数究竟会不会无穷递归？在一些简单的情况下，静态分析工具可以分析无穷递归是否会发生。而在一般情况下，这其实是个 <a href="https://en.wikipedia.org/wiki/Halting_problem">停机问题</a>，无法解决。</p>
<p>一般来说，编译器会设置一个默认递归层数。如果递归层数超过这个默认的层数，则会编译错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>() + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>

<p>上述代码编译错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: <span class="string">&#x27;constexpr&#x27;</span> evaluation depth exceeds maximum of 512 </span><br><span class="line">    (use <span class="string">&#x27;-fconstexpr-depth=&#x27;</span> to increase the maximum)</span><br><span class="line">   24 |     constexpr int x = foo();</span><br></pre></td></tr></table></figure>

<p>在 Clang 中默认的层数是 512，可以通过<code>-fconstexpr-depth</code>来修改，其实模板实例化也会有类似的层数限制。从效果上而言，这个限制可以看成类似运行时函数调用的栈大小，超过这个大小就会“爆栈”了，其实也是挺合理的。</p>
<h1 id="2010：引用还是指针？"><a href="#2010：引用还是指针？" class="headerlink" title="2010：引用还是指针？"></a>2010：引用还是指针？</h1><p>当时，许多函数都无法被标记为 constexpr，因为它们的参数中含有引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">pair</span><span class="params">()</span></span>;               <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">pair</span>(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3039.pdf">N3039 Constexpr functions with const reference parameters</a> 希望允许函数参数和返回值出现常量引用。</p>
<p>事实上，这是个非常巨大的改变。在此之前，常量求值中只有<strong>值</strong>，没有引用（指针）。只需要简单的对值进行运算就行了，引用的引入让常量求值器不得不建立一个内存模型。如果要支持<code>const T&amp;</code>，编译器需要在编译期创建一个临时对象，然后将引用绑定到它上面。任何对该对象不合法的访问都应该导致编译错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">self</span><span class="params">(<span class="type">const</span> T&amp; a)</span> </span>&#123; <span class="keyword">return</span> *(&amp;a); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> T* <span class="title">self_ptr</span><span class="params">(<span class="type">const</span> T&amp; a)</span> </span>&#123; <span class="keyword">return</span> &amp;a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> T&amp; <span class="title">self_ref</span><span class="params">(<span class="type">const</span> T&amp; a)</span> </span>&#123; <span class="keyword">return</span> *(&amp;a); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> T&amp; <span class="title">near_ref</span><span class="params">(<span class="type">const</span> T&amp; a)</span> </span>&#123; <span class="keyword">return</span> *(&amp;a + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> test1 = <span class="built_in">self</span>(<span class="number">123</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> test2 = <span class="built_in">self_ptr</span>(<span class="number">123</span>); <span class="comment">// 失败，指向临时对象的指针不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> test3 = <span class="built_in">self_ref</span>(<span class="number">123</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tets4 = <span class="built_in">near_ref</span>(<span class="number">123</span>); <span class="comment">// 失败，指针越界访问</span></span><br></pre></td></tr></table></figure>

<h1 id="2011：为什么不能有声明？"><a href="#2011：为什么不能有声明？" class="headerlink" title="2011：为什么不能有声明？"></a>2011：为什么不能有声明？</h1><p>前文提到过，constexpr 函数只能由单个 return 语句构成。这就意味着，里面甚至不允许任何不影响求值的声明。但是至少有三种声明有助于编写此类函数：静态断言，类型别名和常量表达式初始化的局部变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> magic = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> x + magic; <span class="comment">// should be ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3268.htm">N3268 static_assert and list-initialization in constexpr functions</a> 希望在 constexpr 函数中支持这些静态声明。</p>
<h1 id="2012：我需要分支！"><a href="#2012：我需要分支！" class="headerlink" title="2012：我需要分支！"></a>2012：我需要分支！</h1><p>有许多简单的函数，希望能够在编译时计算，例如计算<code>a</code>的<code>n</code>次方：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">range_error</span>(<span class="string">&quot;negative exponent for integer power&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sqrt = <span class="built_in">pow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> result = sqrt * sqrt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> result * a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，在当时（C++11），为了它能够变成 constexpr 的，程序员需要按照纯函数式风格（没有局部变量和循环）写一份全新的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow_helper</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n, <span class="type">int</span> sqrt)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sqrt * sqrt * ((n % <span class="number">2</span>) ? a : <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">               ? <span class="keyword">throw</span> std::<span class="built_in">range_error</span>(<span class="string">&quot;negative exponent for integer power&quot;</span>)</span><br><span class="line">               : (n == <span class="number">0</span>)</span><br><span class="line">                     ? <span class="number">1</span></span><br><span class="line">                     : <span class="built_in">pow_helper</span>(a, n, <span class="built_in">pow</span>(a, n / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3444.html">N3444 Relaxing syntactic constraints on constexpr functions</a> 希望进一步放宽 constexpr 函数的限制，以便能够编写任意的代码 </p>
<ul>
<li>允许声明具有 <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">literal type</a> 类型的局部变量，如果它们是通过构造函数进行初始化的，则该构造函数也必须被标记为 constexpr。这样，常量求值器可以缓存这些变量，避免重复求值相同的表达式，提高常量求值器的执行效率，但是不允许修改这些变量 </li>
<li>允许局部类型声明 </li>
<li>允许使用<code>if</code>和多个<code>return</code>语句，并且要求每个分支至少有一个<code>return</code>语句</li>
<li>允许 expression statement（仅由表达式构成的语句） </li>
<li>允许静态变量的地址或引用作为常量表达式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> mutex&amp; <span class="title">get_mutex</span><span class="params">(<span class="type">bool</span> which)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> mutex m1, m2;</span><br><span class="line">    <span class="keyword">if</span> (which)</span><br><span class="line">        <span class="keyword">return</span> m1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> m2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> mutex&amp; m = <span class="built_in">get_mutex</span>(<span class="literal">true</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>但是，不允许<code>for/while</code>循环，<code>goto</code>，<code>switch</code>，<code>try</code>，这些可能产生复杂控制流，甚至产生无穷循环的语句。</p>
<h1 id="2013：小孩子才做选择，循环我也要！"><a href="#2013：小孩子才做选择，循环我也要！" class="headerlink" title="2013：小孩子才做选择，循环我也要！"></a>2013：小孩子才做选择，循环我也要！</h1><p>然而，CWG 认为在 constexpr 函数中支持循环（至少支持<code>for</code>）是必须的。<code>2013</code>年提案  <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3597.html">Relaxing constraints on constexpr functions</a> 发布了修订版本。</p>
<p>实现 constexpr for 考虑了四种选项。</p>
<ul>
<li>添加全新的循环语法，新语法与 constexpr 所需的函数式编程风格良好交互。虽然解决了缺乏循环的问题，但并未消除程序员对现有语言的不满（为了支持 constexpr，需要将原有的代码重新改写）</li>
<li>仅支持传统 C 语言风格的 for 循环，为此，至少需要支持 constexpr 函数中对变量进行更改</li>
<li>仅支持 <a href="https://en.cppreference.com/w/cpp/language/range-for">range-based for loop</a>，这样的循环不能与用户定义的迭代器类型一起使用，除非进一步放宽语言规则</li>
<li>允许在 constexpr 函数中使用 C++ 的一致和广泛的子集，可能包括所有 C++</li>
</ul>
<p>最后选择的是最后一个选项，这极大的影响了 constexpr 在 C++ 中的后续发展。</p>
<p>为了支持这个选项，我们不得不在 constexpr 函数中引入变量的可变性，即支持修改变量的值。根据该提案，现在可以更改在常量求值过程中创建的对象，直到求值过程或对象的 <a href="https://en.cppreference.com/w/cpp/language/lifetime">lifetime</a> 结束。这些求值过程将在类似虚拟机的沙箱中进行，不会影响外部的代码。因此理论上，输出相同的 constexpr 参数将会输出相同的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a;</span><br><span class="line">    ++n; <span class="comment">// ++n 不是一个常量表达式</span></span><br><span class="line">    <span class="keyword">return</span> n * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">f</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// OK，这是一个常量表达式</span></span><br><span class="line"><span class="comment">// f 中的 n 可以被修改，因为其生存期</span></span><br><span class="line"><span class="comment">// 在表达式求值期间开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k2 = ++k;</span><br><span class="line"><span class="comment">// 错误，不是一个常量表达式，不能修改 k</span></span><br><span class="line"><span class="comment">// 因为其生存期没有在，这个表达式内开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">X</span><span class="params">()</span> : n(<span class="number">5</span>)&#123;</span></span><br><span class="line">        n *= <span class="number">2</span>; <span class="comment">// 不是一个常量表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x; <span class="comment">// x 的初始化是一个常量表达式</span></span><br><span class="line">    <span class="keyword">return</span> x.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k3 = <span class="built_in">g</span>();</span><br><span class="line"><span class="comment">//  OK，这是一个常量表达式</span></span><br><span class="line"><span class="comment">//  x.n 可以被修改，因为</span></span><br><span class="line"><span class="comment">//  x 的生存期在 g() 的求值期间开始</span></span><br></pre></td></tr></table></figure>

<p>另外，我想指出现在这样的代码也能编译通过：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">add</span><span class="params">(X&amp; x)</span> </span>&#123; x.n++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="built_in">add</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x.n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量求值中，局部的副作用也是允许的！</p>
<h1 id="2013：constexpr-不是-const-的子集！"><a href="#2013：constexpr-不是-const-的子集！" class="headerlink" title="2013：constexpr 不是 const 的子集！"></a>2013：constexpr 不是 const 的子集！</h1><p>目前，类的 constexpr 函数会自动标记为 const </p>
<p>在提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3598.html">constexpr member functions and implicit const</a> 中指出：如果一个成员函数是 constexpr 的，它不一定一定要是 const 的。随着 constexpr 计算中的可变性变得越来越重要，这一点变得更加突出。但即使在此之前，它也妨碍了在 constexpr 和非 constexpr 代码中使用相同的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">B</span><span class="params">()</span> : a() &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> A&amp; <span class="title">getA</span><span class="params">()</span> <span class="type">const</span> <span class="comment">/*implicit*/</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="function">A&amp; <span class="title">getA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125; <span class="comment">// 代码重复</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有趣的是，提案提供了三个选项，其中选择了第二个：</p>
<ul>
<li>维持现状 -&gt; 导致代码重复</li>
<li>被 constexpr 标记的函数不是隐式 const 的 -&gt; 破坏 ABI，成员函数的 const 签名是函数类型的一部分</li>
<li>使用<code>mutable</code>进行标记<code>constexpr A &amp;getA() mutable &#123; return a; &#125;;</code>  -&gt; 更加不协调了</li>
</ul>
<p>最终，方案<code>2</code>被接受了，现在如果一个成员函数被 constexpr 标记，不代表它是隐式 const 的成员函数了。 </p>
<hr>
<p>下篇在这里</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/683463723" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++ 中 constexpr 的发展史（下）</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/683463723</span></span></span></a></p>
]]></content>
  </entry>
  <entry>
    <title>C++ 中 constexpr 的发展史（下）</title>
    <url>/683463723/</url>
    <content><![CDATA[<h1 id="前情提要："><a href="#前情提要：" class="headerlink" title="前情提要："></a>前情提要：</h1><p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/682031684" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">C++ 中 constexpr 的发展史!（上） | ykiko’s blog</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/682031684</span></span></span></a></p>
<h1 id="2015-2016：模板的语法糖"><a href="#2015-2016：模板的语法糖" class="headerlink" title="2015-2016：模板的语法糖"></a>2015-2016：模板的语法糖</h1><p>在 C++ 中支持 <a href="https://en.cppreference.com/w/cpp/language/template_specialization">全特化 (full specialization)</a> 的模板很多，但是支持 <a href="https://en.cppreference.com/w/cpp/language/partial_specialization">偏特化 (partial specialization)</a> 的模板并不多，事实上其实只有类模板 (class template) 和变量模板 (variable template) 两种支持，而变量模板其实可以看做类模板的语法糖，四舍五入一下其实只有类模板支持偏特化。不支持偏特化会导致有些代码十分难写</p>
<p>假设我们想实现一个<code>destroy_at</code>函数，效果就是调用对象的析构函数。特别的，如果析构函数是 trivial 的，那我们就省去这次无意义的析构函数调用。</p>
<p>直觉上我们能写出下面这样的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">bool</span> value = std::is_trivially_destructible_v&lt;T&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">destroy_at</span>(T* p) &#123; p-&gt;~<span class="built_in">T</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">destroy_at</span>&lt;T, <span class="literal">true</span>&gt;(T* p) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>很可惜，clangd 已经可以智慧的提醒你：<strong>Function template partial specialization is not allowed</strong>。函数模板不能偏特化，那咋办呢？当然了，可以包一层类模板解决，但是每次遇到这种情况都额外包一层实在是让人难以接受。</p>
<p>旧时代的做法是利用 SFINAE 来解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;(!std::is_trivially_destructible_v&lt;T&gt;)&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">destroy_at</span>(T* p) &#123; p-&gt;~<span class="built_in">T</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;std::is_trivially_destructible_v&lt;T&gt;&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">destroy_at</span>(T* p) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>具体的原理这里就不叙述了，虽然少了一层包装，但是仍然有很多与代码逻辑无关的东西出现。这里的<code>std::enable_if_t</code>就是典型例子，严重影响了代码的可读性。</p>
<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4461.html">N4461</a> 希望引入<code>static_if</code>（借鉴自 D 语言）可以用来编译期控制代码生成，只会把实际用到的分支编译进最终的二进制代码。这样就可以写出下面这样的代码，其中<code>static_if</code>的条件必须是常量表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_at</span><span class="params">(T* p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">static_if</span>(!std::is_trivially_destructible_v&lt;T&gt;)&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现逻辑非常清晰，但是委员会一般对于加新的关键字比较谨慎。后来<code>static_if</code>被重命名为<code>constexpr_if</code>，再后来变成了我们今天熟悉的这种形式并且进入 <a href="https://en.cppreference.com/w/cpp/language/if#Constexpr_if">C++17</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (...)&#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>巧妙地避免了加新的关键字，C++ 委员会还真是喜欢关键字复用呢。</p>
<h1 id="2015：constexpr-lambda"><a href="#2015：constexpr-lambda" class="headerlink" title="2015：constexpr lambda"></a>2015：constexpr lambda</h1><p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4487.pdf">N4487</a> 讨论了支持 constexpr lambda 可能性，尤其希望能在 constexpr 计算中能够使用 lambda 表达式，并附带了一个实验性实现。</p>
<p>其实支持 constexpr 的 lambda 表达式并不困难，我们都知道 lambda 在 C++ 里面是很透明的，基本上完全就是一个匿名的函数对象。函数对象都能是 constexpr 的，那么支持 constexpr 的 lambda 也就是理所当然的事情了。</p>
<p>唯一需要注意的就是，lambda 是可以进行捕获的，捕获 constexpr 的变量会怎么样呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> foo = [=]() &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(foo) == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从直觉上来说，由于<code>x</code>是常量表达式，没有必要给它分配空间来储存。那么<code>f</code>其实里面没有任何成员，在 C++ 中空类的 size 至少是<code>1</code>。上面的代码挺合理的，但是在文章的上篇也说到了，constexpr 变量其实也是可以占用内存的，我们可以显式取它的地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> foo = [=]() &#123; <span class="keyword">return</span> &amp;x + <span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(foo) == <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现这种情况下，编译器不得不给<code>x</code>分配内存。实际上的判断规则更复杂一些，感兴趣的可以自行参考 <a href="https://en.cppreference.com/w/cpp/language/lambda#Lambda_capture">lambda capture</a>。最终这个提案被接受，进入了 <a href="https://en.cppreference.com/w/cpp/language/lambda#Lambda_capture:~:text=This%20function%20is%20constexpr%20if%20the%20function%20call%20operator%20(or%20specialization%2C%20for%20generic%20lambdas)%20is%20constexpr.">C++17</a>。</p>
<h1 id="2017-2019：编译期和运行期…不同"><a href="#2017-2019：编译期和运行期…不同" class="headerlink" title="2017-2019：编译期和运行期…不同?"></a>2017-2019：编译期和运行期…不同?</h1><p>通过不断放宽 constexpr 的限制，越来越多的函数可以在编译期执行。但是具有外部链接（也就是被<code>extern</code>的函数）无论如何是无法在编译期执行的。绝大部分从 C 继承过来的函数都是这样的，例如<code>memcpy</code>, <code>memmove</code>等等。</p>
<p>假设我写了一个 constexpr 的<code>memcpy</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T* <span class="title">memcpy</span><span class="params">(T* dest, <span class="type">const</span> T* src, std::<span class="type">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然能在编译期用了，编译期执行效率倒是无所谓，但是运行期效率肯定不如标准库的实现。如果能在编译期使用我的实现，运行期使用外部链接的标准库函数就好了。</p>
<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0595r0.html">P0595</a> 希望加入一个新的 magic function 也就是 <code>constexpr()</code> 用来判断当前的函数是否在编译期执行，后来被更名为<code>is_constant_evaluated</code>并且进入 C++20。使用起来就像下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">is_constant_evaluated</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话编译期和运行期就可以采用不同的逻辑实现了，我们可以对外部链接的函数进行一层封装，使得它们在内部暴露为 constexpr 的函数接口，既可以代码复用又可以保证运行期效率，两全其美。</p>
<p>唯一的问题是，假设上面的<code>foo</code>在运行期运行，你会发现第一个分支仍然被编译了，虽然可能编译器最终应该会把<code>if(false)</code>这个分支优化掉。但是这个分支里面仍然会进行语法检查之类的工作，如果里面用到了模板，那么模板实例化仍然会被触发（甚至产生预料外的实例化导致编译错误），显然这不是我们想要的结果。尝试使用<code>if constexpr</code>改写上面的代码呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_constant_evaluated())</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法被认为是 <strong>obviously incorrect</strong>，因为<code>if constexpr</code>的条件只能在编译期执行，所以这里<code>is_constant_evaluated</code>永远会返回<code>true</code>，这与我们最开始的目的相悖了。 所以提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1938r3.html">P1938R3</a> 提议加入新的语法来解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">consteval</span> <span class="comment">/* !consteval */</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看上去是一目了然的，两个分支一个编译期一个运行期。这个升级过后的版本最终被接受并加入 C++23。</p>
<h1 id="2017-2019：-高效的调试"><a href="#2017-2019：-高效的调试" class="headerlink" title="2017-2019： 高效的调试"></a>2017-2019： 高效的调试</h1><p>C++ 模板一个最被人诟病的问题就是报错信息非常糟糕，而且难以调试。内层模板实例化失败之后，会把整个实例化栈打印出来，能轻松产生成百上千行报错。但是事情在 constexpr 函数这里其实也并没有变好，如果 constexpr 函数常量求值失败，也会把整个函数调用堆栈打印出来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">13</span> + <span class="number">2147483647</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">oo</span>(); &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> x = <span class="built_in">bar</span>();</span><br></pre></td></tr></table></figure>

<p>报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">in <span class="string">&#x27;constexpr&#x27;</span> expansion of <span class="string">&#x27;bar()&#x27;</span></span><br><span class="line">in <span class="string">&#x27;constexpr&#x27;</span> expansion of <span class="string">&#x27;foo()&#x27;</span></span><br><span class="line">error: overflow in constant expression [-fpermissive]</span><br><span class="line">  <span class="number">233</span> | <span class="keyword">constexpr</span> <span class="keyword">auto</span> x = <span class="built_in">bar</span>();</span><br></pre></td></tr></table></figure>

<p>如果函数嵌套多了，报错信息也非常糟糕。不同于模板的地方在于，constexpr 函数也可以在运行期运行。所以我们可以在运行期调试代码，最后在编译期执行就好了。但是如果考虑到上一小节加的<code>is_constant_evaluated</code>，就会发现这种做法并不完全可行，因为编译期和运行期的代码逻辑可能不同。提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0596r0.html">P0596</a> 希望引入<code>constexpr_trace</code>和<code>constexpr_assert</code>来方便编译期调试代码，虽然投票一致赞成，但是暂时未进入 C++ 标准。</p>
<h1 id="2017：-编译期可变容器"><a href="#2017：-编译期可变容器" class="headerlink" title="2017： 编译期可变容器"></a>2017： 编译期可变容器</h1><p>尽管在先前的提案中，允许了 constexpr 函数使用和修改变量，但是动态内存分配还是不允许的。如果有未知长度的数据需要处理，一般就是在栈上开一个大数组，这没什么问题。但是从实践上来说，有特别多的函数依赖于动态内存分配，支持 constexpr 函数中使用<code>vector</code>势在必得。</p>
<p>在当时，直接允许在 constexpr 函数中使用<code>new</code>&#x2F;<code>delete</code>似乎过于让人惊讶了，所以提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0597r0.html">P0597</a> 想了一个折中的办法，先提供一个 magic container 叫做<code>std::constexpr_vector</code>，它由编译器实现，并且支持在 constexpr 函数中使用和修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> constexpr_vector&lt;<span class="type">int</span>&gt; x;  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> constexpr_vector&lt;<span class="type">int</span>&gt; y&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">series</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::constexpr_vector&lt;<span class="type">int</span>&gt; r&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k; k &lt; n; ++k) &#123;</span><br><span class="line">        r.<span class="built_in">push_back</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这并不彻底解决问题，用户仍然需要重写它的代码以支持常量求值。从在 constexpr 函数支持循环的那一节来看，这种加重语言不一致性的东西，很难被加入标准。最终有更好的提案取代了它，后面会提到。</p>
<h1 id="2018：真正的编译期多态？"><a href="#2018：真正的编译期多态？" class="headerlink" title="2018：真正的编译期多态？"></a>2018：真正的编译期多态？</h1><p>提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1064r0.html">P1064R0</a> 希望在常量求值中支持虚函数调用。哎，还不支持动态内存分配呢，咋就要支持虚函数调用了？其实不依赖动态内存分配也可以弄出来多态指针嘛，指向栈上的对象或者静态储存就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p;</span><br><span class="line">    Derived d;</span><br><span class="line">    p = &amp;d;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎没有任何理由拒绝上面这段代码编译通过。由于是在编译期执行，编译器当然能知道<code>p</code>指向的是<code>Derived</code>，然后调用<code>Derived::f</code>，实践上没有任何难度。的确如此，之后又有一个新的提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1327r1.html">P1327R1</a> 进一步希望<code>dynamic_cast</code>和<code>typeid</code>也能在常量求值中使用，最终它们都被接受并且加入了 <a href="https://en.cppreference.com/w/cpp/language/constexpr#:~:text=it%20must%20not%20be%20virtual">C++20</a>，现在可以自由的在编译期使用这些特性了。</p>
<h1 id="2017-2019：-真正的动态内存分配！"><a href="#2017-2019：-真正的动态内存分配！" class="headerlink" title="2017-2019： 真正的动态内存分配！"></a>2017-2019： 真正的动态内存分配！</h1><p>在 <a href="https://www.youtube.com/watch?v=HMB9oXFobJc">constexpr everything</a> 的这个演示视频中，展示了一个能在编译期处理<code>JSON</code>对象的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> jsv= <span class="string">R&quot;(&#123;</span></span><br><span class="line"><span class="string">    &quot;feature-x-enabled&quot;: true,</span></span><br><span class="line"><span class="string">    &quot;value-of-y&quot;: 1729,</span></span><br><span class="line"><span class="string">    &quot;z-options&quot;: &#123;&quot;a&quot;: null,</span></span><br><span class="line"><span class="string">        &quot;b&quot;: &quot;220 and 284&quot;,</span></span><br><span class="line"><span class="string">         &quot;c&quot;: [6, 28, 496]&#125;</span></span><br><span class="line"><span class="string"> &#125;)&quot;</span>_json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(jsv[<span class="string">&quot;feature-x-enabled&quot;</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// feature x</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// feature y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望能直接通过解析常量字符串起到配置文件的作用（字符串文本可以由<code>#include</code>引入）。作者们因为不能使用 STL 的容器受到了严重影响，并且自己编写了替代品。通过<code>std::array</code>来实现<code>std::vector</code>和<code>std::map</code>这样的容器，由于没有动态内存分配，只能预先计算出需要的大小（可能导致多次遍历）或者在栈上开块大内存。</p>
<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p0784r7.html">P0784R7</a> 重新讨论了在常量求值中支持标准库容器的可能性</p>
<p>主要有以下三个难点： </p>
<ul>
<li>析构函数不能被声明为 constexpr（对于 constexpr 对象，它们必须是 trivial 的） </li>
<li>无法进行动态内存分配&#x2F;释放 </li>
<li>无法在常量求值中使用 <a href="https://en.cppreference.com/w/cpp/language/new#Placement_new">placement new</a> 来调用对象的构造函数</li>
</ul>
<p>针对第一个问题，作者们与 MSVC，GCC，Clang，EDG 等前端开发人员快速讨论并解决了这个问题。C++20 起，可以符合 <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">literal type</a> 要求的类型具有 constexpr 修饰的析构函数，而不是严格要求平凡的析构函数。</p>
<p>针对第二个问题，处理起来并不简单。C++ 有很多未定义行为都是由于错误的内存处理导致的，相比之下，不能直接操作内存的脚本语言则安全的多。但是为了复用代码，C++ 编译器中的常量求值器不得不直接操作内存，不过由于所有信息都是编译期已知的，理论上可以保证常量求值中不会出现内存错误 (out of range, double free, memory leak, …)，如果出现应该中止编译并报告错误。</p>
<p>常量求值器需要跟踪许多对象的的元信息，并找出这些错误 </p>
<ul>
<li>记录<code>union</code>哪个 field 是 active 的，访问 unactive 的成员导致未定义行为，这由 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1330r0.pdf">P1330</a> 阐明 </li>
<li>正确记录对象的 <a href="https://en.cppreference.com/w/cpp/language/lifetime">lifetime</a>，访问未初始化的内存和已经析构的对象都是不允许的</li>
</ul>
<p>当时还不允许在常量求值中把<code>void*</code>转换成<code>T*</code>，所以理所当然的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不支持在常量求值中使用，取而代之的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new =&gt; initialize when allocate</span></span><br><span class="line"><span class="keyword">auto</span> pa = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">delete</span> pa;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::allocator =&gt; initialize after allocate</span></span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> pb = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(pb, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>它们返回的都是<code>T*</code>，并且由编译器实现，这对于支持标准库容器来说已经足够了。</p>
<p>对于第三个问题，则是添加了一个 magic function 即 <a href="https://en.cppreference.com/w/cpp/memory/construct_at">std::construct_at</a>，它的作用是在指定的内存位置上调用对象的构造函数，用来在常量求值中取代<code>placement new</code>。这样的话我们就可以先通过<code>std::allocator</code>分配内存，再通过<code>std::construct_at</code>来构造对象了。该提案最终被接受，进入了 <a href="https://en.cppreference.com/w/cpp/memory/construct_at">C++20</a>，同时使得<code>std::vector</code>，<code>std::string</code>在常量求值中可用（其它的容器理论上也行，但是目前的实现还没支持，如果非常想要只能自己搓一个了）。</p>
<p>虽然支持了动态内存分配，但并不是毫无限制。<strong>在一次常量求值中分配的内存必须要在这次常量求值结束之前释放完全，不能有内存泄漏，否则会导致编译错误</strong>。这种类型的内存分配被叫做 。该提案也讨论了 ，在编译期未被释放的内存，将被转为静态储存（其实就是存在数据区，就像全局变量那样）。但是，委员会认为这种可能性 “too brittle”，出于多种原因，目前尚未采纳。</p>
<h1 id="2018：更多的-constexpr"><a href="#2018：更多的-constexpr" class="headerlink" title="2018：更多的 constexpr"></a>2018：更多的 constexpr</h1><p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1002r1.pdf">P1002</a> 希望在 constexpr 函数中支持<code>try-catch</code>块。但是不能<code>throw</code>，这样是为了能把更多的标准库容器的成员函数标记为<code>constexpr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> x = <span class="built_in">foo</span>();  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// expression &#x27;&lt;throw-expression&gt;&#x27; is not a constant expression</span></span><br><span class="line"><span class="comment">//    233 |     throw 1;</span></span><br></pre></td></tr></table></figure>

<p>如果在编译期<code>throw</code>会直接导致编译错误，由于<code>throw</code>不会发生，那自然也不会有异常被捕获。</p>
<h1 id="2018：保证编译期执行！"><a href="#2018：保证编译期执行！" class="headerlink" title="2018：保证编译期执行！"></a>2018：保证编译期执行！</h1><p>有些时候我们想保证一个函数在编译期执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">bar</span>(<span class="number">1</span>)); <span class="comment">// evaluate at compile time ?</span></span><br></pre></td></tr></table></figure>

<p>事实上<code>g</code>无论是在编译期还是运行期执行，理论上都可以。为了保证它在编译期执行，我们需要多写一些代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> x = <span class="built_in">bar</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">foo</span>(x);</span><br></pre></td></tr></table></figure>

<p>这样就保证了<code>g</code>在编译期执行，同样，这种没意义的局部变量实在是多余。提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1073r0.html">P1073</a> 希望增加一个标记 <code>constexpr!</code>来确保一个函数在编译期执行，如果不满足则导致编译错误。最终该标记被更名为 <a href="https://en.cppreference.com/w/cpp/language/consteval">consteval</a> 并进入了 C++20。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">bar</span>(<span class="number">1</span>)); <span class="comment">// ensure evaluation at compile time</span></span><br></pre></td></tr></table></figure>

<p><code>consteval</code>函数不能获取指针或引用，编译器后端根本不需要（也不应该）知道这些函数的存在，也不需要将它们放入符号表中等等。事实上该提案也为未来可能引入的 static reflection 做了铺垫，未来将会有大量只在编译期执行的函数进入标准。</p>
<h1 id="2018：默认-constexpr-？"><a href="#2018：默认-constexpr-？" class="headerlink" title="2018：默认 constexpr ？"></a>2018：默认 constexpr ？</h1><p>在当时，有很多提案的内容仅仅是把标准库的某个部分标记为<code>constexpr</code>，在本文中没有讨论它们，因为它们具有相同的模式。</p>
<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1235r0.pdf">P1235</a> 希望把所有函数都标记为 implicit constexpr 的</p>
<ul>
<li>non：如果可能，将方法标记为 constexpr。</li>
<li>constexpr：与当前行为相同</li>
<li>constexpr(false)：不能在编译时调用</li>
<li>constexpr(true)：只能在编译时调用</li>
</ul>
<p>该提案最终没有被接受。</p>
<h1 id="2020：更强的动态内存分配？"><a href="#2020：更强的动态内存分配？" class="headerlink" title="2020：更强的动态内存分配？"></a>2020：更强的动态内存分配？</h1><p>正如之前提到的，在 constexpr 函数中支持内存分配已经被允许了，也可以在 constexpr 函数中使用<code>std::vector</code>这样的容器，但是由于是瞬态内存分配，无法创建全局的<code>std::vector</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>所以如果一个 constexpr 函数返回一个<code>std::vector</code>，只能额外包装一层把这个<code>std::vector</code>转成<code>std::array</code>然后作为全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arr = []()&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> len = <span class="built_in">f</span>().<span class="built_in">size</span>();</span><br><span class="line">    std::array&lt;<span class="type">int</span>, len&gt; result&#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> temp = <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        result[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2020/p1974r0.pdf">P1974</a> 提议使用<code>propconst</code>来支持非瞬态内存分配，这样上述的额外的包装代码就不需要了。</p>
<p>非瞬态内存分配的原理很简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::vector vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器会将上述代码编译为类似下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> data[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::vector vec&#123;</span><br><span class="line">    .begin = data, </span><br><span class="line">    .end = data + <span class="number">3</span>, </span><br><span class="line">    .capacity = data + <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实就是把本来应该指向动态分配的内存的指针改为指向静态内存。原理并不复杂，真正的难点是如何保证程序的正确性。<strong>显然上述的vec即使在程序结束的时候也不应该调用析构函数，否则会导致段错误</strong>。这个问题要解决很简单，我们可以约定，<strong>任何constexpr标记的变量都不会调用析构函数</strong>。</p>
<p>但是考虑如下情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> unique_ptr&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; ppi &#123; </span><br><span class="line">    <span class="keyword">new</span> unique_ptr&lt;<span class="type">int</span>&gt; &#123; <span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">42</span> &#125; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ppi.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">43</span> &#125;); <span class="comment">// error, ppi is const</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; pi = *ppi;</span><br><span class="line">    pi.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">43</span> &#125;); <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>pp1</code>是<code>constexpr</code>的，那么它的析构函数不应该调用。对<code>ppi</code>尝试调用<code>reset</code>是不允许的，因为<code>constexpr</code>标记的变量隐含<code>const</code>，而<code>reset</code>并不是一个<code>const</code>方法。但是对<code>pi</code>调用<code>reset</code>是允许的，因为外层<code>const</code>不影响内层指针。</p>
<p>如果允许<code>pi</code>调用<code>reset</code>，显然这是一次运行期调用，会在运行期动态内存分配，而由于<code>ppi</code>不会调用析构函数，里面的<code>pi</code>当然也不会调用析构函数，于是内存就泄露了，显然这种做法不应该被允许。</p>
<p>解决办法自然是想办法禁止<code>pi</code>调用<code>reset</code>，提案提出了<code>propconst</code>关键字，它可以把外层的<code>constexpr</code>传递给内层，这样<code>pi</code>也是<code>const</code>的了，也就不能调用<code>reset</code>了，就不会出现代码逻辑问题了。</p>
<p>可惜的的是暂时还未被标准接受，在那之后还有一些新的的提案希望能够支持这个特性比如 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2670r1.html">P2670R1</a>，相关的讨论还在继续。</p>
<h1 id="2021：constexpr-类"><a href="#2021：constexpr-类" class="headerlink" title="2021：constexpr 类"></a>2021：constexpr 类</h1><p>C++ 标准库中的很多类型，比如<code>vector</code>, <code>string</code>, <code>unique_ptr</code>中的所有方法都被标记为 constexpr，并且真正可以在编译期执行。很自然的，我们希望能直接标记整个类为 constexpr，这样可以省去哪些重复的说明符编写。</p>
<p>提案 <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2021/p2350r1.pdf">P2350</a> 希望支持这个特性，constexpr 标记的<code>class</code>中的所有方法都被隐式标记为 constexpr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">struct</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">SomeType</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有一个有趣的故事与这个提案有关 - 在不知道它的存在之前，我（文章原作者）在 <a href="https://stdcpp.ru/">stdcpp.ru</a> 提出了同样的想法。</p>
<p>在标准制定过程中，很多几乎相同的提案几乎可以同时出现。这证明了 <a href="https://en.wikipedia.org/wiki/Multiple_discovery">多重发现理论的正确性</a>：某些思想或概念会在不同的人群中独立地出现，就像它们在空气中漂浮一样，并且谁先发现的并不重要。如果社区的规模足够大，这些思想或概念自然会发生演变。</p>
<h1 id="2023：编译期类型擦除！"><a href="#2023：编译期类型擦除！" class="headerlink" title="2023：编译期类型擦除！"></a>2023：编译期类型擦除！</h1><p>在常量求值中，一直不允许把<code>void*</code>转换成<code>T*</code>，这样导致诸如<code>std::any</code>，<code>std::function</code>等类型擦除实现的容器无法在常量求值中使用。原因呢，是因为我们可以通过<code>void*</code>来绕过类型系统，把一个类型转换为不相干的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="type">double</span>* p1 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(p));</span><br></pre></td></tr></table></figure>

<p>如果对<code>p1</code>解引用实际上是未定义的行为，所以禁止了这种转换（<strong>注意 reinterpret_cast 一直在常量求值中禁用</strong>）。但是显然这种做法已经误伤了正确的写法了，因为像<code>std::any</code>这种实现，显然不会把一个从<code>void*</code>转换成无关的类型，而是会把它转换回原来的类型，完全不允许这种转换是不合理的。提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r0.pdf">P2738R0</a> 希望在常量求值中支持这种转换，编译器理论上能在编译期记录一个<code>void*</code>指针原本的类型，如果转换的不是原本的类型，就报错。</p>
<p>最终该提案被接受，并且加入 C++26，现在可以进行 <code>T*</code> -&gt; <code>void*</code> -&gt; <code>T*</code> 的转换了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">void</span>* p = &amp;x;</span><br><span class="line">    <span class="type">int</span>* p1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(p); <span class="comment">// ok</span></span><br><span class="line">    <span class="type">float</span>* p2 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(p); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2023：支持-placement-new？"><a href="#2023：支持-placement-new？" class="headerlink" title="2023：支持 placement new？"></a>2023：支持 placement new？</h1><p>前面我们提到，为了支持<code>vector</code>在常量求值中使用，加入了<code>construct_at</code>用于在常量求值中调用构造函数。它具有如下形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T* <span class="title">construct_at</span><span class="params">(T* p, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>虽然一定程度上解决了问题，但是它并不能完全提供<code>placement new</code>的功能</p>
<ul>
<li>value initialization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (p) <span class="built_in">T</span>(args...) <span class="comment">// placement new version</span></span><br><span class="line"><span class="built_in">construct_at</span>(p, args...) <span class="comment">// construct_at version</span></span><br></pre></td></tr></table></figure>

<ul>
<li>default initialization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (p) T <span class="comment">// placement new version</span></span><br><span class="line">std::<span class="built_in">default_construct_at</span>(p) <span class="comment">// P2283R1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>list initialization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (p) T&#123;args...&#125; <span class="comment">// placement new version</span></span><br><span class="line"><span class="comment">// construct_at version doesn&#x27;t exist</span></span><br></pre></td></tr></table></figure>

<ul>
<li>designated initialization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (p) T&#123;.x = <span class="number">1</span>, .y = <span class="number">2</span>&#125; <span class="comment">// placement new version</span></span><br><span class="line"><span class="comment">// construct_at version cannot exist</span></span><br></pre></td></tr></table></figure>

<p>提案 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2747r1.html">P2747R1</a> 希望在常量求值中直接支持<code>placement new</code>。暂时还未被加入标准。</p>
<h1 id="2024-∞：未来无极限！"><a href="#2024-∞：未来无极限！" class="headerlink" title="2024-∞：未来无极限！"></a>2024-∞：未来无极限！</h1><p>截止目前，C++ 的常量求值已经支持了非常丰富的功能，支持条件，变量，循环，虚函数调用，动态内存分配等等一系列特性。但是受限于日常开发使用的 C++ 版本，有很多功能可能暂时没法使用，可以在 <a href="https://en.cppreference.com/w/cpp/feature_test#:~:text=P2564R3-,__cpp_constexpr,-constexpr">这里</a> 方便的查看哪个版本支持了什么特性。</p>
<p>未来的 constexpr 中仍然有很多可能性，比如像<code>memcpy</code>这样的函数或许也能在常量求值中使用？又或者目前的<code>small_vector</code>的<strong>某些实现不能在不改动任何代码的前提</strong>下变成 constexpr 的，因为它们使用<code>char</code>数组为栈上的对象提供储存（为了避免默认构造）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::byte buf[<span class="number">100</span>];</span><br><span class="line">    std::<span class="built_in">construct_at</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(buf), <span class="number">42</span>); <span class="comment">// no matter what</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是目前在常量求值中无法直接在<code>char</code>数组上构造对象。更进一步，在 C++20 加入的 <a href="https://en.cppreference.com/w/cpp/named_req/ImplicitLifetimeType">implicit lifetime</a> 是否可能在常量求值中表现出来呢？这些理论上都是可能实现的，只是要求编译器记录更多的元信息。而在未来，一切皆有可能！最终我们或许真的能 constexpr everything！</p>
]]></content>
  </entry>
  <entry>
    <title>彻底理解 C++ ABI</title>
    <url>/692886292/</url>
    <content><![CDATA[<p>Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的时候经常会讨论到它，看文章的时候经常会提到它，有时候又要处理它导致的兼容性。陌生在哪里？如果有人问你什么是 ABI，你会发现你知道它是怎么一回事，但是要用严谨的语言去描述它有些困难。最后只好照着 <a href="https://en.wikipedia.org/wiki/Application_binary_interface">WIKI</a> 说：ABI 就是两个二进制程序模块之间的接口。有问题吗？没有问题，作为一个概括性的描述，已经足够了。但是让人感觉到有些空洞。</p>
<p>这一情况在 CS 领域并不少见，笔者之前写的讨论 <a href="https://16bit-ykiko.github.io/about-me/669358870">反射</a> 的文章也遇到完全相同的情况。究其根本，CS 本来就不是一门力求严谨性的学科，很多概念都没有严格的定义，更多的是约定俗成的说法。所以我们就不去纠结定义，而是就实际出发，来看看这些所谓的二进制接口究竟有哪些，又有哪些因素会影响它们的稳定性。</p>
<p>软件工程讲究分层，对于一个 C++ 程序的 ABI 来说，我们也可以从下面这五个层次来看待。</p>
<h1 id="CPU-OS"><a href="#CPU-OS" class="headerlink" title="CPU &amp; OS"></a>CPU &amp; OS</h1><p>最终的可执行文件最后都是要运行在特定 CPU 上的特定操作系统的。如果 CPU 的指令集不同，那肯定会导致二进制不兼容，比如 <a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> 上的程序没法<strong>直接</strong>运行在 x64 处理器上（除非借助一些虚拟化技术）。如果指令集兼容呢？比如 x64 处理器就兼容 x86 的指令集，那 x86 程序一定能运行在 x64 操作系统上吗？这时候就要看操作系统了，具体来说，要考虑到 <strong>Object File Format</strong>（目标文件格式），<strong>Data Representation</strong>（数据表示）， <strong>Function Calling Convention</strong>（函数调用约定）和 <strong>Runtime Library</strong>（运行时库）等因素。这几点就可以看做是操作系统层面的 ABI 规定。第四点我们后面有专门的一节来讨论，下面以 x64 平台为例，就前三点进行讨论。</p>
<blockquote>
<p>x64, x86-64, x86_64, AMD64 和 Intel 64 是一个意思，都是指 x86 指令集的 64 位版本。</p>
</blockquote>
<p><strong>x64 平台上主要有两套常用的 ABI</strong>：</p>
<ul>
<li>用于 64 位 Windows 操作系统上的 <a href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170">Windows x64 ABI</a></li>
<li>用于 64 位 Linux 以及一众 UNIX-like 的操作系统上的 <a href="https://gitlab.com/x86-psABIs/x86-64-ABI">x86-64 System V ABI</a></li>
</ul>
<p>而从一个动态库里面调用某个函数可以简单的看成下面这个三个步骤：</p>
<ul>
<li>按照某种格式解析动态库</li>
<li>根据符号名从解析结果中查找函数地址</li>
<li>函数参数传递，调用函数</li>
</ul>
<h2 id="Object-File-Format"><a href="#Object-File-Format" class="headerlink" title="Object File Format"></a>Object File Format</h2><p>以何种格式解析动态库？这就是 ABI 中对 Object File Format 的规定起作用的地方了。如果你希望自己写一个链接器，那么最后生成的可执行文件就需要满足对应平台的格式要求。Windows x64 使用的可执行文件格式是 <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">PE32+</a> ，也就是 PE32（Portable Executable 32-bit）格式的<code>64</code>位版本。System V ABI 使用的则是 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF（Executable Linkable Format）</a> 格式的可执行文件。通过使用一些 parse 库（当然感兴趣的话也可以自己写），例如 <a href="https://github.com/trailofbits/pe-parse">pe-parse</a> 和 <a href="https://github.com/serge1/ELFIO">elfio</a>，对实际的可执行文件进行解析，得到其中的符号表，我们便能拿到函数名与函数地址的映射关系了。</p>
<h2 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h2><p>拿到函数地址之后，接下来就是怎么进行调用了。在调用之前，首先得传参对吧。那传参的时候就特别要注意 Data Representation（数据表示）表示的一致性，什么意思呢？</p>
<p>假设我把下面这个文件编译成动态库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(X x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a + x.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果后续版本升级导致结构体内容发生变动了，用户代码里面看到的结构体定义变成了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后仍然去尝试链接旧版本代码编译出的动态库，并调用里面的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">foo</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能成功吗？当然会失败了。这种错误可以看成所谓的 ODR（One Definition Rule）违反，更多的示例会在后面的章节中讨论。</p>
<p>上面的情况属于用户主动变更代码导致的 ODR 违反，那如果我不主动变更代码，能确保结构体布局的稳定性吗？那这就由 ABI 中 Data Representation 来进行相关保证了。例如：规定一些基础类型的大小和对齐， Windows x64 规定<code>long</code>是<code>32</code>位，而 System V 则规定<code>long</code>是<code>64</code>位。规定<code>struct</code>和<code>union</code>的大小和对齐等等。</p>
<blockquote>
<p>注意 C 语言标准仍然是不规定 ABI 的，对于 System V ABI 来说，其主要使用 C 语言的术语和概念编写，所以可以认为提供了针对 C 语言的 ABI。而 Windows x64 ABI 在 C 和 C++ 之间并没有太过明显的界限。</p>
</blockquote>
<h2 id="Function-Calling-Convention"><a href="#Function-Calling-Convention" class="headerlink" title="Function Calling Convention"></a>Function Calling Convention</h2><p>接下来就到函数传参这一步了。我们知道，函数不过就是一段二进制数据，执行函数其实就是跳转到函数的入口地址，然后执行那一段代码，最后执行完了再跳转回来就行了。而传参无非就是找一块地方，存放数据，<strong>使得调用前后都能访问到这个地方来取数据</strong>。有哪些位置可以选择呢？主要有下面四个选项： </p>
<ul>
<li>global（全局变量） </li>
<li>heap（堆） </li>
<li>register（寄存器） </li>
<li>stack（栈）</li>
</ul>
<p>使用全局变量进行传参，听起来很魔幻，实际上平常写代码的时候经常把一些需要反复传递的参数改成全局变量，例如<code>config</code>这种的。但是，显然不是所有参数都适合使用全局变量传参，如果考虑到线程安全就要更加注意了。</p>
<p>使用堆进行传参，似乎也很不可思议，但其实 C++20 加入的无栈协程就把协程的状态（函数参数，局部变量）保存在堆上。不过对于普通的函数调用来说，如果每次传参都要动态内存分配，确实有些奢侈了。</p>
<p>所以我们主要还是考虑使用寄存器和栈进行传参。多一种选择总是好的，但是在这里并不好。如果调用方觉得应该使用寄存器传参，于是把参数存到寄存器里面去了。而被调用方觉得应该使用栈传参，所以取数据的时候是从栈里面取的。不一致就出现了，很可能从栈里面独到的就是垃圾值，导致代码逻辑错误，程序直接崩溃。</p>
<p>如何保证调用方和被调用方传参的位置一致呢？相信你已经猜到了，这就是 Function Calling Convention（函数调用约定）发挥作用的地方。 </p>
<p>具体来说，调用约定规定下面这些内容： </p>
<ul>
<li>函数参数传递顺序，从左到右还是从右到左？ </li>
<li>函数参数和返回值传递的方式，通过栈还是寄存器？ </li>
<li>哪些寄存器在调用者调用前后是保持不变的？ </li>
<li>谁负责清理栈帧，调用者还是被调用者？ </li>
<li>如何处理 C 语言的 <a href="https://en.cppreference.com/w/c/variadic">variadic</a> 函数？</li>
<li><code>...</code></li>
</ul>
<p>在<code>32</code>位程序中，有很多调用约定，像什么<code>__cdecl</code>，<code>__stdcall</code>，<code>__fastcall</code>，<code>__thiscall</code>等等，当时的程序可谓是饱受兼容性之苦。而在<code>64</code>位程序中，已经基本完成统一。主要有两种调用约定，也就是 Windows x64 ABI 和 x86-64 System V ABI 分别规定的调用约定（不过并没有个正式的名字）。<strong>需要强调的是函数传参方式只和调用约定有关，和代码优化等级无关。你也不想不同优化等级编译出来的代码，链接到一起之后跑不起来吧。</strong></p>
<p>介绍具体的规定是有些无聊的，感兴趣的读者可以自行查阅对应文档的相关小节，下面主要讨论一些比较有意思的话题。</p>
<blockquote>
<p>注意：下面这些讨论只适用于函数调用实际发生的情况，如果函数被完全内联，函数传参这一行为并不会发生。目前 C++ 代码的内联优化主要发生在同一编译单元内（单个文件），对于跨编译单元的代码，必须要打开 LTO（Link Time Optimization）才行，跨动态库的代码目前还不能内联。</p>
</blockquote>
<ul>
<li><strong>小于16字节大小的结构体值传递效率比引用效率更高</strong></li>
</ul>
<p>这个说法由来已久，但是我始终没有找到依据。终于，最近在研究调用约定的时候，让我找到原因了。首先如果结构体大小小于等于<code>8</code>字节，那么可以直接塞进一个<code>64</code>位寄存器里面传参，<strong>通过寄存器传参比通过引用传参要少几次访存</strong>，效率要高一些，没什么问题。那对于<code>16</code>字节呢？System V ABI 允许将一个<code>16</code>字节大小的结构体拆两个<code>8</code>个字节的部分，然后分别使用寄存器传递。那么在这种情况下传值确实比传引用要高一些，观察下面的 <a href="https://godbolt.org/z/5Ph34x1cK">代码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> x;</span><br><span class="line">    <span class="type">size_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">f</span><span class="params">(X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// pass by value</span></span><br><span class="line">    <span class="built_in">g</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// pass by reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后生成的代码如下所示</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">24</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="number">2</span> </span><br><span class="line">        <span class="keyword">call</span>    f(X)</span><br><span class="line">        <span class="keyword">movdqa</span>  <span class="built_in">xmm0</span>, XMMWORD <span class="built_in">PTR</span> .LC0[<span class="built_in">rip</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rsp</span></span><br><span class="line">        <span class="keyword">movaps</span>  XMMWORD <span class="built_in">PTR</span> [<span class="built_in">rsp</span>], <span class="built_in">xmm0</span></span><br><span class="line">        <span class="keyword">call</span>    g(X const&amp;)</span><br><span class="line">        <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">24</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.LC0:</span></span><br><span class="line"><span class="meta">        .quad</span>   <span class="number">1</span></span><br><span class="line"><span class="meta">        .quad</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>System V ABI 规定了前六个整形参数，依次可以使用<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code>寄存器传递，而 Windows x64 ABI 规定了前四个整形参数，依次可以使用<code>rcx</code>，<code>rdx</code>，<code>r8</code>，<code>r9</code>寄存器传递。如果过寄存器用完了，就通过栈传递。整形参数即<code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>long long</code>等基础整数类型外加指针类型。浮点参数和 SIMD 类型的参数则有专门的寄存器负责，这里不过多涉及了。</p>
</blockquote>
<p>可以发现<code>1</code>,<code>2</code>分别通过寄存器<code>edi</code>和<code>esi</code>传递给了<code>f</code>函数，而<code>g</code>则是把临时变量的地址传递给了<code>g</code>函数。但是这只是 System V ABI，对于 Windows x64 ABI 来说，<strong>只要结构体的大小大于8字节，只能通过引用传递。</strong>同样的代码，在 Windows 上编译的结果如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">56</span>                             </span><br><span class="line">        <span class="keyword">lea</span>     <span class="built_in">rcx</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">32</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">32</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">40</span>], <span class="number">2</span></span><br><span class="line">        <span class="keyword">call</span>    void f(X)                   </span><br><span class="line">        <span class="keyword">lea</span>     <span class="built_in">rcx</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">32</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">32</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">40</span>], <span class="number">2</span></span><br><span class="line">        <span class="keyword">call</span>    void g(X const &amp;)</span><br><span class="line">        <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">56</span>                        </span><br><span class="line">        <span class="keyword">ret</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到两次函数调用产生的代码完全相同，也就是说对于 Windows x64 ABI 来说，大于<code>8</code>字节的结构体无论是通过引用传递还是值传递，生成的代码都是一样的。</p>
<ul>
<li><strong>unique_ptr 和 raw_ptr 的效率完全一致</strong></li>
</ul>
<p>好吧在此之前我一直对此深信不疑，毕竟<code>unique_ptr</code>只是对裸指针简单包装一层嘛。直到看了 CPPCON 上 <a href="https://www.bilibili.com/video/BV1qp421y75W/?spm_id_from=333.999.0.0">There are no zero-cost abstractions</a> 这个令人深省的 talk，才意识到完全是我想当然了。这里不谈异常导致的额外开销（析构函数导致编译器必须额外生成清理栈帧的代码），仅仅讨论一个 C++ 对象（小于<code>8</code>字节）能使用寄存器传参吗？对于一个完全 <a href="https://en.cppreference.com/w/cpp/language/classes#Trivial_class">trivial</a> 的类型来说，是没问题的，它表现得和一个 C 语言的结构体几乎完全一样。不过不满足呢？</p>
<p>比如自定义了拷贝构造函数，还能放寄存器里面吗？其实从逻辑上就不能，为什么呢？我们知道，C++ 是允许我们对函数参数取地址的，那如果参数是整形，那么它通过寄存器传参，那取地址的结果哪里来的呢？实验一下，就知道了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的对应汇编如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">g(<span class="keyword">int</span>):</span><br><span class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">24</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">12</span>], <span class="built_in">edi</span></span><br><span class="line">        <span class="keyword">lea</span>     <span class="built_in">rdi</span>, [<span class="built_in">rsp</span>+<span class="number">12</span>]</span><br><span class="line">        <span class="keyword">call</span>    f(<span class="keyword">int</span>&amp;)</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsp</span>+<span class="number">12</span>]</span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">24</span></span><br><span class="line">        <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>可以发现，这里把<code>edi</code>（用于传递第一个整形参数）里面的值拷贝到了 <code>rsp+12</code> 这个地址，也就是栈上，之后把这个地址传递给了<code>f</code>。也就是说，如果一个函数参数通过寄存器传递，如果在某些情况下需要它的地址，编译器会把这个参数拷贝到栈上。<strong>但是无论如何，用户是观察不到这些拷贝过程的，因为它们的拷贝构造函数是trivial的。不影响最终代码执行结果的任何优化都是符合 as if 原则的。</strong></p>
<p>那么如果这个对象有用户定义的拷贝构造函数，假设参数通过寄存器传递，就可能会导致额外的拷贝构造函数调用，并且用户可以观察到这个副作用。显然这是不合理的，所以不允许拥有自定义拷贝构造函数的对象通过寄存器传参，那通过栈传递呢？实际上也会遇到类似的拷贝困境。于是最终这类对象只能通过引用传递了。<strong>注意，给拷贝构造显式标记为delete也算是自定义拷贝构造函数。</strong></p>
<p>所以对于<code>unique_ptr</code>来说，只能通过引用传递，无论你函数签名写成<code>void f(unique_ptr&lt;int&gt;)</code>还是<code>void f(unique_ptr&lt;int&gt;&amp;)</code>，最后在传参处生成的二进制代码都是一样的。但是裸指针却可以通过寄存器安全的传递。综上所述，<code>unique_ptr</code>和裸指针的效率并不是完全一致的。</p>
<blockquote>
<p>实际上对于一个非 trivial 的 C++ 对象，究竟能否使用寄存器传参的实际情况更复杂一些，相关的内容参考对应 ABI 中的相关小节，这里不过多描述。另外 C++ 对象如何传递这部分规定，究竟属于操作系统的 ABI 还是 C++ 编译器 ABI 这个问题也并不是很明确。</p>
</blockquote>
<h1 id="C-Standard"><a href="#C-Standard" class="headerlink" title="C++ Standard"></a>C++ Standard</h1><p>终于说完了操作系统层面的保证，由于偏向底层，涉及到较多汇编，对于不那么熟悉汇编的读者，读起来可能有些困难。不过接下来的内容基本就和汇编没什么关系了，可以放心阅读。</p>
<p>我们都知道 C++ 标准没有明确规定 ABI，但并不是完全没有规定，它对于编译器的实现是有一些要求的，例如：</p>
<ul>
<li>结构体成员地址按照声明顺序 <a href="https://en.cppreference.com/w/c/language/struct#Explanation">递增</a>，这保证了编译器不会对结构体成员进行重新排序</li>
<li>满足 <a href="https://en.cppreference.com/w/cpp/language/data_members#Standard-layout">Standard Layout</a> 约束的结构体需要与相应的 C 结构体布局兼容</li>
<li>满足 <a href="https://en.cppreference.com/w/cpp/types/is_trivially_copyable">Trivially Copyable</a> 约束的结构体可以使用<code>memmove</code>或者<code>memcpy</code>进行拷贝得到一个完全相同的全新对象</li>
<li><code>...</code></li>
</ul>
<p>另外，由于 C++ 一直在推出新的版本。同一份代码，我使用新标准和旧标准分别进行编译，得到的结果相同吗（不考虑使用宏控制 C++ 版本进行条件编译的影响）？这就要看 C++ 标准层面对 ABI 兼容性的保证了，事实上，C++ 标准尽可能的保证<strong>向后兼容性</strong>。也就是说，两段代码，使用旧标准和新标准编译出来的代码是完全一样的。</p>
<p>然而，也有极少数的例外，例如（我只找得到这些，欢迎评论区补充）：</p>
<ul>
<li>C++17 把<code>noexcept</code>作为函数类型的一部分，这会影响函数最后生成的 mangling name</li>
<li>C++20 引入的<code>no_unique_address</code>，MSVC 目前仍然没直接支持，因为会导致 ABI Broken</li>
</ul>
<p>更多时候，C++ 新版本会在加入新的语言特性的同时带来新的 ABI，而不会影响旧的代码，例如 C++23 加入的两个新特性：</p>
<h2 id="Explicit-Object-Parameter"><a href="#Explicit-Object-Parameter" class="headerlink" title="Explicit Object Parameter"></a><a href="https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter">Explicit Object Parameter</a></h2><p>在 C++23 之前，事实上没有<strong>合法</strong>的手段获取一个成员函数的地址，我们唯一能做的就是获取成员指针（关于成员指针是什么，可以参考这篇 <a href="https://16bit-ykiko.github.io/about-me/659510753">文章</a> 的内容）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = &amp;X::f; </span><br><span class="line"><span class="comment">// p is a pointer to member function of X</span></span><br><span class="line"><span class="comment">// type of p is void (X::*)(int)</span></span><br></pre></td></tr></table></figure>

<p>想要获取使用成员函数作为回调函数，只能使用 lambda 表达式包装一层</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Fn = <span class="built_in">void</span>(*)(X*, <span class="type">int</span>);</span><br><span class="line">Fn p = [](A* self, <span class="type">int</span> x) &#123; self-&gt;<span class="built_in">f</span>(x); &#125;;</span><br></pre></td></tr></table></figure>

<p>这其实很麻烦，没有任何必要，而且这层包装可能会导致额外的函数调用开销。某种程度上这算是个历史遗留问题，<code>32</code>位系统上对成员函数的调用约定有些特殊（广为人知的<code>thiscall</code>），而 C++ 中并没有调用约定相关的内容，所以搞了个成员函数指针这么个东西。旧的代码为了 ABI 兼容性已经无法改变，但是新的可以，C++23 加入了显式对象参数，我们现在可以明确<code>this</code>的传入方式了，甚至可以使用值传递</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 this 只是个标记作用，为了和旧语法区分开来</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="keyword">this</span> X self, <span class="type">int</span> x)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="keyword">this</span> X&amp; self, <span class="type">int</span> x)</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>被显式<code>this</code>标记的函数也可以直接获取函数地址了，就和普通的函数一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = &amp;X::f; <span class="comment">// type of f is void(*)(X, int)</span></span><br><span class="line"><span class="keyword">auto</span> g = &amp;X::g; <span class="comment">// type of g is void(*)(X*, int)</span></span><br></pre></td></tr></table></figure>

<p>所以新代码可以都采用这种写法，只有好处，没有坏处。</p>
<h2 id="Static-Operator"><a href="#Static-Operator" class="headerlink" title="Static Operator()"></a><a href="https://en.cppreference.com/w/cpp/feature_test#cpp_static_call_operator">Static Operator()</a></h2><p>标准库中有一些仿函数，里面什么成员都没有，只有一个<code>operator()</code>，例如<code>std::hash</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span>&amp; t)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尽管这是个空的结构体，但是由于<code>operator()</code>是成员函数，所以有一个隐式<code>this</code>参数。在非内联调用的情况下仍然需要传递一个无用的空指针。这个问题在 C++23 中得到了解决，可以直接定义<code>static operator()</code>，从而避免这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span>&amp; t)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>static</code>也就意味着这是个静态函数了，使用上还是和原来一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::hash&lt;<span class="type">int</span>&gt; h;</span><br><span class="line">std::<span class="type">size_t</span> n = <span class="built_in">h</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>但这里只是拿<code>hash</code>举个例子，实际上标准库的代码为了 ABI 兼容性已经不会改动了。新代码可以使用这个特性，来避免不必要的<code>this</code>传递。</p>
<h1 id="Compiler-Specific"><a href="#Compiler-Specific" class="headerlink" title="Compiler Specific"></a>Compiler Specific</h1><p>接下来就到了重头戏了，实现定义的部分，这部分似乎是被人诟病最多的内容了。然而事实真的如此吗？让我们一点点往下看。</p>
<h2 id="De-Facto-Standard"><a href="#De-Facto-Standard" class="headerlink" title="De Facto Standard"></a>De Facto Standard</h2><p>C++ 中的一些抽象最终是要落实到实现上的，而标准有没有规定如何实现，那这部分内容就由编译器自由发挥，例如：</p>
<ul>
<li>name mangling 的规则（为了实现函数重载和模板函数）</li>
<li>复杂类型的布局（例如含有虚继承）</li>
<li>虚函数表的布局</li>
<li>RTTI 的实现</li>
<li>异常处理 </li>
<li><code>...</code></li>
</ul>
<p>如果编译器对这些部分的实现不同，那么最后不同编译器编译出的二进制产物自然是互不兼容，不能混用的。</p>
<blockquote>
<p>在上世纪<code>90</code>年代，那时候还是 C++ 发展的黄金时期，各个厂商都致力于实现自己的编译器并扩大基本盘，争夺用户。出于竞争关系，不同编译器之间使用不同的 ABI 是很常见的行为。随着时代的发展，它们中的大多数已经退出了历史舞台，要么停止更新，要么仅做维护，不再跟进 C++ 的新标准。浪潮过后，留下的只有 GCC，Clang 和 MSVC 这三大编译器。</p>
</blockquote>
<p>在今天，C++ 编译器的 ABI 已经基本得到统一，主流的 ABI 只有两套：</p>
<ul>
<li>Itanium C++ ABI，具有公开透明的 <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html">文档</a> </li>
<li>MSVC C++ ABI，并没有官方的文档，这里有一份非正式的 <a href="https://link.zhihu.com/?target=http://www.openrce.org/articles/files/jangrayhood.pdf">版本</a></li>
</ul>
<blockquote>
<p>尽管名为 Itanium C++ ABI，但它实际上是用于 C++ 的跨架构 ABI，除了 MSVC 之外，几乎所有的 C++ 编译器都在使用它，尽管在异常处理方面的细节略有不同。历史上，C++ 编译器都以各自的方式处理 C++ ABI。当英特尔大力推广 Itanium 时，他们希望避免不兼容问题，因此，他们为 Itanium 上的所有 C++ 供应商创建了一个标准化的 ABI。后来，由于各种原因，GCC 需要修改其内部 ABI，而且鉴于它已经支持了 Itanium ABI（为 Itanium 处理器），他们选择将 ABI 定义扩展到所有架构，而不是创建自己的 ABI。从那时起，所有主要的编译器除了 MSVC 都采用了跨架构的 Itanium ABI，并且即使 Itanium 处理器本身不再接收维护，该 ABI 仍然得到了维护。 </p>
</blockquote>
<p>在 Linux 平台上，GCC 和 Clang 都使用 Itanium ABI，所以两个编译器编译出来的代码就具有互操作性，可以链接到一起并运行。而在 Windows 平台上，情况则稍微复杂些，默认的 MSVC 工具链使用自己的 ABI。但是除了 MSVC 工具链以外，还有人把 GCC 移植到 Windows 上了，也就是我们熟知的 <a href="https://www.mingw-w64.org/">MinGW</a> 工具链，它使用的仍然是 Itanium ABI。这两套 ABI 互不兼容，编译出来的代码不能直接链接到一起。而 Windows 平台上的 Clang 可以通过编译选项控制使用这两种 ABI 的其中的一种。</p>
<blockquote>
<p>注意：MinGW 既然在 Windows 上运行，那它生成的代码的调用约定自然是尽量遵守 Windows x64 ABI 的，最终生成的可执行文件格式也是 PE32+。但是它的使用的 C++ ABI 仍然是 Itanium ABI，这两者并没有必然关联。</p>
</blockquote>
<p>考虑到 C++ 巨大的 codebase，这两套 C++ ABI 已经基本稳定，不会再改动了，<strong>所以我们现在其实可以说 C++ 编译器具有稳定的 ABI</strong>。怎么样，是不是和网上主流的说法不同？但是事实的确就摆在这里。</p>
<blockquote>
<p>MSVC 从 <a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170">2015</a> 的版本往后开始保证 ABI 稳定。GCC 从 3.4 开始使用 Itanium ABI 并保证 ABI 稳定。</p>
</blockquote>
<h2 id="Workaround"><a href="#Workaround" class="headerlink" title="Workaround"></a>Workaround</h2><p>尽管基础的 ABI 不再改变，但是升级编译器版本仍然可能会导致编译出来的库发生 ABI Broken，为什么呢？</p>
<p>这其实不难理解，首先编译器也是软件，只要是软件就可能有 BUG。有时候为了修复 BUG，会被迫做出一些 ABI Broken（一般会在新版本的发行介绍中详细说明）。例如 GCC 有一个编译选项 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#index-fabi-version">-fabi-version</a> 用于专门控制这些不同的版本，其中一些内容如下：</p>
<ul>
<li>版本<code>7</code>首次出现在 G++ 4.8 中，它将<code>nullptr_t</code>视为内建类型，并修正了默认参数作用域中 Lambda 表达式的名称编码</li>
<li>版本<code>8</code>首次出现在 G++ 4.9 中，修正了带有函数 CV 限定符的函数类型的替换行为</li>
<li>版本<code>9</code>首次出现在 G++ 5.2 中，修正了<code>nullptr_t</code>的对齐方式</li>
</ul>
<p>另外对于用户来说，也可能之前为了绕过编译器的 BUG，编写了一些特殊的代码，我们一般把这个叫做 workaround。当 BUG 被修复之后，这些 workaround 很可能起到反作用。从而导致 ABI 出现不兼容</p>
<h2 id="Important-Options"><a href="#Important-Options" class="headerlink" title="Important Options"></a>Important Options</h2><p>除此之外，编译器还提供了一些列选项用来控制编译器的行为，这些选项可能会影响 ABI，比如：</p>
<ul>
<li>-fno-strict-aliasing：关闭严格别名</li>
<li>-fno-exceptions：关闭异常</li>
<li>-fno-rtti：关闭 RTTI</li>
<li><code>...</code></li>
</ul>
<p>给不同选项编译出来的库链接到一起的时候，尤其要兼容性问题。例如你的代码关闭了严格别名，但是依赖的外部库开启了严格别名，很可能指针错误的传播，从而导致程序出错。</p>
<p>我最近就遇到了这种情况，我在给 LLVM 的一些函数编写 Python Wrapper，通过 <a href="https://github.com/pybind/pybind11">pybind11</a>。而 pybind11 要求必须打开 RTTI，但是 LLVM 默认构建是关闭异常和 RTTI 的，所以最后代码就链接不到一块去了。一开始我是自己编译了一份开 RTTI 的 LLVM，这会导致二进制膨胀，后来发现没必要这样做。我其实没有用到 LLVM 里面类型的 RTTI 信息，只是由于写在同一个文件里面，编译器认为我用到了。于是把使用到 LLVM 部分的代码单独编译成一个动态库，再和使用 pybind11 部分的代码一起链接就解决了。</p>
<h1 id="Runtime-Library"><a href="#Runtime-Library" class="headerlink" title="Runtime &amp; Library"></a>Runtime &amp; Library</h1><p>这一小节主要讨论的就是，一个 C++ 程序依赖的库的 ABI 稳定性。<strong>理想情况下是，对于一个可执行程序，使用新版本的动态库替换旧版本的动态库，仍然不影响它运行。</strong></p>
<p>三大 C++ 编译器都有自己的标准库 </p>
<ul>
<li>MSVC 对应的是 <a href="https://github.com/microsoft/STL">msvc stl</a> </li>
<li>GCC 对应的是 <a href="https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3">libstdc++</a> </li>
<li>Clang 对应的是 <a href="https://github.com/llvm/llvm-project/tree/main/libcxx">libc++</a></li>
</ul>
<p>我们在前面提到过，C++ 标准尽量保证 ABI 向后兼容。即使是从 C++98 到 C++11 这样的大更新，旧代码的 ABI 也没有受到太大影响，导致 ABI Break Change 的措辞改变更是完全找不到。</p>
<p>但是对于 C++ 标准库来说情况就有些不一样了，从 C++98 到 C++11，标准库经历了一次大的 ABI Break Change。标准库中修改了对一些容器实现的要求，例如<code>std::string</code>。这导致原来广泛使用的 COW 实现不符合新标准，于是在 C++11 中不得不采用新实现。这也就导致了 C++98 和 C++11 之间的标准库 ABI Broken。不过在这之后，标准库的 ABI 一般相对稳定，各家实现也尽量保证。参考 <a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170">stl</a>，<a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html">libstdc++</a> 和 <a href="https://libcxx.llvm.org/DesignDocs/ABIVersioning.html">libc++</a> 相关的页面以获取详细介绍。</p>
<p>另外由于 RTTI 和 Exception 一般可以关掉，所以这两项功能可能由单独的运行时库来负责，比如 MSVC 的 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features?view=msvc-170">vcruntime</a> 和 libc++ 的 <a href="https://libcxxabi.llvm.org/">libcxxabi</a>。</p>
<blockquote>
<p>值得一提的是，libcxxabi 中还包含了对静态局部变量初始化的支持，涉及到的主要函数是 **cxa_guard_acquire, **cxa_guard_release。使用它们来保证静态局部变量只在运行时初始化一次，如果对具体的实现感到好奇，可以查阅相关源码。</p>
</blockquote>
<p>还有就是负责一些底层功能的运行时库，比如 <a href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">libgcc</a> 和 <a href="https://compiler-rt.llvm.org/">compiler-rt</a>。</p>
<p>除了标准库以外，C++ 程序一般还需要链接 C 运行时 </p>
<ul>
<li>在 Windows 上，必须链接 <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/compatibility?view=msvc-170">CRT</a> </li>
<li>在 Linux 上 取决于所使用的发行版和编译环境，可能会链接 <a href="https://www.gnu.org/software/libc/">glibc</a> 或者 <a href="https://musl.libc.org/">musl</a></li>
</ul>
<p>C 运行时除了提供 C 标准库的实现外，还负责程序的初始化和清理。它负责调用<code>main</code>函数，并管理程序的启动和终止过程，包括执行一些必要的初始化和清理工作。对于大多数在操作系统上的软件来说，链接它是必须的。</p>
<p>最理想的状态自然是，升级编译器的时候把这些对应的运行时库版本也升级，避免不必要的麻烦。但是在实际项目中，依赖关系可能十分复杂，可能会引发连锁反应。</p>
<h1 id="User-Code"><a href="#User-Code" class="headerlink" title="User Code"></a>User Code</h1><p>最后我们来谈谈用户代码自身的改变导致的 ABI 问题，如果希望将你的库以二进制形式进行分发，那么当用户量达到一定程度之后，ABI 兼容性就很重要了。</p>
<p>在第一小节讨论调用约定的时候，就提到过变更结构体定义导致的 ABI 不兼容问题。那如果既想要保证 ABI 兼容，又想要为以后得扩展留下空间怎么办呢？答案就是在运行时处理了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> x;</span><br><span class="line">    <span class="type">size_t</span> y;</span><br><span class="line">    <span class="type">void</span>* reserved;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过一个<code>void*</code>指针为以后的扩展预留空间。可以根据它来判断不同的版本，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(X* x)</span> </span>&#123;</span><br><span class="line">    Reserved* r = <span class="built_in">static_cast</span>&lt;Reserved*&gt;(x-&gt;reserved);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;version == ...) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r-&gt;version == ...) &#123;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能在添加新的功能的同时而不影响原有的代码。</p>
<p>在对外暴露接口的时候，对于函数参数中有自定义析构函数的类型，也要格外注意。假设我们要暴露<code>std::vector</code>作为返回值，例如把下面这个简单的代码编译成动态库，并且使用<code>\MT</code>选项来静态链接 Windows CRT。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__declspec(dllexport) <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们写一个源文件，链接到刚才编译的这个动态库，调用这个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vec = <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，发现直接崩溃了。如果关闭<code>\MT</code>重新编译一遍动态库，然后运行，发现一切正常。很奇怪，为什么依赖的动态库静态链接 CRT 会导致代码崩溃？</p>
<p>思考一下上面的代码不难发现，<code>vec</code>的构造实际上发生在动态库里面，而析构则是发生在<code>main</code>函数里面。更进一步，其实就是内存是在动态库里面分配的，释放是在<code>main</code>函数里面。但是每一份 CRT 都有自己的<code>malloc</code>，<code>free</code>（类似于不同进程间的内存）。<strong>你不能把 CRT A 分配的内存交给 CRT B 释放</strong>，这就是问题的根源。所以之后不静态链接到 CRT 就没事了，它们用的都是同一个<code>malloc</code>，<code>free</code>。不仅仅是 WIndows CRT，对于 Linux 上的 glibc 或者 musl 也是一样的。示例代码放在 <a href="https://github.com/16bit-ykiko/about-me/tree/main/code/crt-fault">这里</a>，感兴趣的可以自己试试。</p>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p>对于任何带有自定义析构函数的 C++ 类型都可能出现上面那种情况，<strong>由于种种原因，构造函数和析构函数的调用跨越动态库边界，RAII 的约定被打破，导致严重的错误。</strong></p>
<p>如何解决呢？那自然是函数参数和返回值都不使用带有析构函数的类型了，只使用 POD 类型。</p>
<p>例如上面那个例子需要改成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Vec = <span class="type">void</span>*;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function">Vec <span class="title">create_Vec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">destroy_Vec</span><span class="params">(Vec vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="type">int</span>&gt;*&gt;(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用就得这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Vec = <span class="type">void</span>*;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec <span class="title">create_Vec</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_Vec</span><span class="params">(Vec vec)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec vec = <span class="built_in">create_Vec</span>();</span><br><span class="line">    <span class="built_in">destroy_Vec</span>(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我们就是在按照 C 风格的 RAII 来进行封装。更进一步，如果想要解决 C 和 C++ 由于 mangling 不同而导致的链接问题，可以使用<code>extern &quot;C&quot;</code>来修饰函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function">Vec <span class="title">create_Vec</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_Vec</span><span class="params">(Vec vec)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话 C 语言也可以使用上述的导出函数了。</p>
<p>但是如果代码量很大的话，把全部的函数都封装成这样的 API 显然不太现实，那就只能把 C++ 的类型暴露在导出接口中，然后小心地管理依赖项（比如所有依赖库全都静态链接）。具体选择哪一种方式，还是要看项目大小和复杂度，然后再做定夺。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>到这里，我们终于讨论完了影响 C++ 程序 ABI 的主要因素。可以清楚地看到，C++ 标准、编译器厂商和运行时库都在尽力维护 ABI 的稳定性，C++ ABI 并没有很多人说的那么不堪，那么不稳定。对于小型项目而言，带源码静态链接，几乎不会有任何的兼容性问题。对于那些历史悠久的大型项目来说，由于复杂的依赖关系，升级某些库的版本可能会导致程序崩溃。<strong>但这并不是 C++ 的错，对于大型项目的管理，早已超出了单纯的语言层面，不能指望通过更换编程语言来解决这些问题</strong>。实际上，学习软件工程就是在学习如何应对巨大的复杂度，如何保证复杂系统的稳定性。</p>
<p>文章到这就结束了，感谢您的阅读。作者水平有限，并且这篇文章内容跨度较大，如有错误欢迎评论区留言讨论。</p>
<p>一些其它的参考资料：</p>
<ul>
<li><a href="https://www.agner.org/optimize/calling_conventions.pdf">An Overview of ABI in Different Platforms</a></li>
<li><a href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170">WIndows x64 ABI</a></li>
<li><a href="https://gitlab.com/x86-psABIs/x86-64-ABI">System V x64 ABI</a></li>
<li><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html">Itanium C++ ABI</a></li>
<li><a href="https://sourceforge.net/p/mingw-w64/wiki2/MinGW%20x64%20Software%20convention/">MinGW x64 Software Convention</a></li>
<li><a href="https://developer.apple.com/documentation/xcode/writing-64-bit-intel-code-for-apple-platforms">MacOS x64 ABI</a></li>
<li><a href="https://developer.arm.com/Architectures/Application%20Binary%20Interface">ARM ABI</a></li>
<li><a href="https://learn.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=msvc-170">WIndows ARM64 ABI</a></li>
<li><a href="https://d3s.mff.cuni.cz/files/teaching/nswi200/202324/doc/riscv-abi.pdf">RISCV ABI</a></li>
<li><a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go Internal ABI</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C++ 究竟代码膨胀在哪里？</title>
    <url>/686296374/</url>
    <content><![CDATA[<p>相信读者经常能听见有人说 C++ 代码二进制膨胀严重，但是一般很少会有人指出具体的原因。在网络上一番搜索过后，发现深入讨论这个问题的文章的并不多。上面那句话更像是八股文的一部分，被口口相传，但是没什么人能说出个所以然。今天小编 ykiko 就带大家一起来探秘 C++ 代码膨胀那些事  (^ω^)</p>
<p>首先要讨论的是，什么叫做代码膨胀？如果一个函数被大量内联，那相比于不被内联，最终生成的可执行文件是更大了对吧。那这样算膨胀吗？我认为不算，这是我们预期范围内的，可接受的，正常行为。那反过来，不在我们预期范围内的，理论上能消除，但迫于现有的实现却没有消除的代码膨胀，我把它叫做”真正的代码膨胀”。后文所讨论的膨胀都是这个意思。</p>
<h1 id="用-inline-标记函数会导致膨胀吗？"><a href="#用-inline-标记函数会导致膨胀吗？" class="headerlink" title="用 inline 标记函数会导致膨胀吗？"></a>用 inline 标记函数会导致膨胀吗？</h1><p>首先要明确，这里的<code>inline</code>是 C++ 中的<code>inline</code>，标准中规定的语义是，<strong>允许一个函数的在多个源文件中定义</strong>。被<code>inline</code>标记的函数可以直接定义在头文件中，即使被多个源文件<code>#include</code>，也不会导致链接错误，这样可以方便的支持 header-only 的库。</p>
<h2 id="多份实例的情况"><a href="#多份实例的情况" class="headerlink" title="多份实例的情况"></a>多份实例的情况</h2><p>既然可以在多个源文件中定义，那是不是就意味着每个源文件都有一份代码实例，会不会导致代码膨胀呢?</p>
<p>考虑如下示例，开头的注释表示文件名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src1.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src2.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">g1</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">g2</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g1</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">g2</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先尝试<strong>不开优化</strong>编译前两个文件，看看他们是不是各自保留了一份<code>add</code>函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ -c src1.cpp -o src1.o</span><br><span class="line">$ g++ -c src2.cpp -o src2.o</span><br></pre></td></tr></table></figure>

<p>分别查看这两个文件里面的符号表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -d src1.o | c++filt</span><br><span class="line">$ objdump -d src2.o | c++filt</span><br></pre></td></tr></table></figure>

<p>本地验证都通过上述命令直接查看符号表进行。但是为了方便展示，我会把 godbolt 对应的链接和截图放上来，它把很多影响阅读的不关键符号都省略了，看起来更加清晰。</p>
<p>可以看到这两个 <a href="https://godbolt.org/z/xoW8TTvP7">源文件</a> 分别保留了一份，<code>add</code>函数的实例。然后我们将它们链接成可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ main.o src1.o src2.o -o main.exe</span><br><span class="line">$ objdump -d main.exe | c++filt</span><br></pre></td></tr></table></figure>

<p>结果如下图所示</p>
<p>发现链接器只保留了两份<code>add</code>实例中的一份，所以并没有<strong>额外的代码膨胀</strong>。并且 C++ 标准要求，内联函数在不同编译单元的定义必须相同，所以无论选哪一份代码保留都没区别。但是如果你问：万一定义不同呢？那就会导致 ODR 违反，严格意义来说算 undefined behavior，究竟保留哪一个可能就看具体实现了，甚至和链接顺序有关。关于 ODR 违反相关的内容，我最近可能会单独写一个文章介绍，这里就不说太多了。<strong>只需要知道 C++ 标准保证 inline 函数在不同编译单元定义相同就行了</strong>。</p>
<h2 id="完全内联的情况"><a href="#完全内联的情况" class="headerlink" title="完全内联的情况"></a>完全内联的情况</h2><p>前面我特意强调了，不打开优化，如果打开了优化会怎么样呢？仍然是上面的代码，我们尝试打开<code>O2</code>优化。最后的 <a href="https://godbolt.org/z/jfx8jrnzf">结果</a> 如下图所示</p>
<p>可能让人有点吃惊，打开<code>-O2</code>优化之后，<code>add</code>调用被完全内联。编译器最后连符号都没有给<code>add</code>生成，链接的时候自然也没有<code>add</code>。按照我们之前的定义来看，这种函数内联不属于代码膨胀，所以是没有<strong>额外的</strong>二进制膨胀开销的。</p>
<p>稍微偏个题，既然这两个文件都不生成<code>add</code>这个符号，那万一有别的文件引用了<code>add</code>这个符号，不就会导致编译失败吗？</p>
<p>考虑如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src1.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g1</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试编译链接上面的代码。发现不开优化可以链接通过。开了优化就会导致链接失败了。链接器会告诉你<code>undefined reference to add(int, int)</code>。<strong>三大编译器的行为都是如此</strong>，具体的原因上面已经解释过了，开了优化之后，编译器压根没生成<code>add</code>这个符号，链接的时候自然无法找到了。</p>
<p>但是我们想知道的是，这样做符合 C++ 标准吗？</p>
<p>三大编译器都这样，似乎没有不符合的道理。但是在 inline 那一小节并没有明确说明，而在 <a href="https://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule">One Definition Rule</a>  这里有如下两句话 </p>
<ul>
<li>For an inline function or inline variable(since C++17), a definition is required in every translation unit where it is odr-used. </li>
<li>a function is odr-used if a function call to it is made or its address is taken</li>
</ul>
<p>两句话啥意思呢？意思就是，一个 inline 函数，如果在某个编译单元被 <a href="https://en.cppreference.com/w/cpp/language/definition#ODR-use">odr-used</a> 了，那么这个编译单元必须要有该函数的定义。啥情况是 odr-used 呢？后面一句话就是在解释，如果<strong>函数被调用</strong>或者<strong>取函数的地址</strong>就算是 odr-used。</p>
<p>那我们看看之前的代码，在 main.cpp 中调用一个 inline 函数，但是却没有定义，所以其实是违背了 C++ 标准的约定的。到这里，算是松了一口气了。虽然有点反直觉，但是事实的确如此，三大编译器都没错！</p>
<h2 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h2><p>我们这一小节主要讨论了两种情况：</p>
<ul>
<li>第一种即<code>inline</code>函数在多个编译单元都有实例（生成符号），那么这时候目前主流的链接器都只会选择其中一份保留，不会有额外的代码膨胀</li>
<li>第二种情况是<code>inline</code>函数被完全内联，并且不生成符号。这时候就如同普通的函数被内联一样，不属于”额外的开销”</li>
</ul>
<p>可能会有人觉得 C++ 优化怎么规则这么多啊。但是实际上核心的规则只有一条，那就是<code>as-if</code>原则，也就是编译器可以对代码进行任何优化，只要最后生成的代码运行效果和不优化的一样就行了。编译器绝大部分时候都是按照这个原则来进行优化的，只有少数几个例外可以不满足这个原则。上述对 inline 函数的优化也是满足这个原则的，如果不显式对 inline 函数取地址，那的确没必要保留符号。</p>
<p>另外， inline 虽然标准层面没有强制内联的语义了，但是实际上它会给编译器一些 hint，使得这个函数更容易被内联。这个 hint 是如何作用的呢？前面提到了，标准的措辞表明 inline 函数可以不生成符号。那相比之下，没有任何说明符限定的函数，则默认被标记为 extern ，必须要生成符号。<strong>编译器肯定是更愿意内联可以不生成符号的函数的</strong>。从这个角度出发，你可能会猜测 static 也会有类似的 hint 效果，实际情况的确如此。当然了，这些只是一个方面，实际上，判断函数是否被内联的计算会复杂的多。</p>
<p>注意：本小节，只讨论了仅被<code>inline</code>标记的函数，除此之外还有<code>inline static</code>和<code>inline extern</code>这样的组合，感兴趣的读者可以阅读官方文档或者自行尝试效果如何。</p>
<h1 id="模板导致代码膨胀的真正原因？"><a href="#模板导致代码膨胀的真正原因？" class="headerlink" title="模板导致代码膨胀的真正原因？"></a>模板导致代码膨胀的真正原因？</h1><p>如果有人给出 C++ 二进制膨胀的理由，那么几乎它的答案一定是模板。果真如此吗？模板究竟是怎么导致二进制膨胀的？在什么情况导致的？难道我用了就导致吗？</p>
<h2 id="隐式实例化如同-inline-标记"><a href="#隐式实例化如同-inline-标记" class="headerlink" title="隐式实例化如同 inline 标记"></a>隐式实例化如同 inline 标记</h2><p>我们知道模板实例化发生在当前编译单元，实例化一份就会产生一份代码。考虑下面这个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src1.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">g1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">add</span>(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src2.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">g2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">add</span>(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">g1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">g2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g1</span>() + <span class="built_in">g2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍然不开优化，尝试编译 <a href="https://godbolt.org/z/aTxMsnK5n">编译结果</a> 如下</p>
<p>可以看见就像被 inline 标记的函数那样，这两个编译单元都实例化了<code>add&lt;int, int&gt;</code>和<code>add&lt;double, double&gt;</code>，各有一份代码。然后在最终链接的时候，链接器只为每个模板实例化保留了一份代码。那我们尝试打开<code>-O2</code>，然后再看看情况。<a href="https://godbolt.org/z/edEd8Tvo4">结果</a> 如下</p>
<p>也和 inline 标记的效果一样，编译器直接把函数内联了，然后实例化出的函数的符号都扔了。那这样的话，要么内联了符号都没生成，要么生成了符号，最后函数合并了。和 inline 一样，这种情况似乎没有额外的膨胀啊，那经常说的模板膨胀，究竟膨胀在哪呢？</p>
<h2 id="显式实例化和-extern-模板"><a href="#显式实例化和-extern-模板" class="headerlink" title="显式实例化和 extern 模板"></a>显式实例化和 extern 模板</h2><p>在介绍真正膨胀的原因之前，我们先来讨论一下显式实例化。</p>
<p>虽然链接器最后能合并多份相同的模板实例化。但是模板定义的解析，模板实例化，以及生成最终的二进制代码和链接器去除重复代码，这些都要编译时间的啊。有些时候，我们能确定，只是使用某几种固定模板参数的实例化，比如像标准库的<code>basic_string</code>几乎只有那几种固定的类型作为模板参数，如果每次个文件用到它们，都要进行模板实例化可能会大大增长编译时间。</p>
<p>那我们可以像非模板函数一样，把实现放在某一个源文件，其它文件引用这个源文件的函数吗？从上一小节的讨论来看，既然会生成符号，那应该就有办法链接到。但是不能保证一定生成啊，有什么办法保证生成符号吗？</p>
<p>答案就是 —— 显式实例化！</p>
<p>什么叫显式实例化？简单来说，如果一个模板，你直接使用。而不提前声明具体到何种类型，由编译器帮你生成声明，那就算隐式实例化。反之就叫做显式实例化。以函数模板为例，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 显式实例化 f&lt;int&gt; 定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用之前显式实例化的 f&lt;int&gt;</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">// 隐式实例化 f&lt;double&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信还是很好理解的，而且<strong>显式实例化定义</strong>的话，编译器一定会为你保留符号。那接下来就是外部如何链接到这个显式实例化的函数了，有两种办法</p>
<p>一种是，直接显式实例化一个函数声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 显式实例化 f&lt;int&gt; 仅声明</span></span><br></pre></td></tr></table></figure>

<p>另一种是直接使用<code>extern</code>关键字实例化一个定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 显式实例化 f&lt;int&gt; 声明</span></span><br><span class="line"><span class="comment">// 注意不加 extern 就会显式实例化一个定义了</span></span><br></pre></td></tr></table></figure>

<p>这两种都能正确引用到上面那个函数<code>f</code>，这样就可以调用其它文件的模板实例化了！</p>
<h2 id="真正的模板膨胀开销"><a href="#真正的模板膨胀开销" class="headerlink" title="真正的模板膨胀开销"></a>真正的模板膨胀开销</h2><p>接下来是最重要的部分了，我们将会介绍模板膨胀的真正原因。由于一些历史遗留问题，C++ 中<code>char</code>,<code>unsigned char</code>,<code>signed char</code>三种类型永远互不相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(!std::is_same_v&lt;<span class="type">char</span>, <span class="type">unsigned</span> <span class="type">char</span>&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_same_v&lt;<span class="type">char</span>, <span class="type">signed</span> <span class="type">char</span>&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_same_v&lt;<span class="type">unsigned</span> <span class="type">char</span>, <span class="type">signed</span> <span class="type">char</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>但是如果落实到到编译器最终实现上来，<code>char</code>要么<code>signed</code>，要么<code>unsigned</code>。假设我们编写一个模板函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">signed</span> <span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化三种类型的函数模板，那么其中必然有两个实例化是相同的代码。编译器会把函数类型不同，但是最后生成的二进制代码相同的两个函数合并吗？尝试一下，<a href="https://godbolt.org/z/KncEh3z5n">结果</a> 如下</p>
<p>可以看到这里生成了两个完全一样的函数，但是并没有合并。当然，如果我们打开<code>-O2</code>优化，这样短的函数就会被内联掉了，也不会生成最终符号。就和第一小节说的那样，也就没有所谓的”模板膨胀开销”。实际代码编写中有很多这样的短小的模板函数，比如<code>vector</code>这种容器的<code>end</code>,<code>begin</code>,<code>operator[]</code>等等，它们大概率会被完全内联，从而没有”额外的膨胀”开销。</p>
<p>现在问题来了，如果函数没被没有内联呢？假设模板函数比较复杂，函数体较大。为了方便演示，我们暂时使用 GCC 的一个 attribute <code>[[gnu::noinline]]</code>来实现这种效果，然后打开 O2，再次编译上面的 <a href="https://godbolt.org/z/Exff5cnfj">代码</a></p>
<p>可以看到虽然被优化的只剩一条指令，但是编译器还是生成了三份函数。实际上，真的不被编译器内联的函数体积可能比较大，情况可能比这个“伪装的大函数”糟糕的多。于是，这样的话就产生了所谓的”模板膨胀”。<strong>本来能合并的代码却没有合并，这就是真正的模板膨胀开销所在</strong>。</p>
<p>如果非常希望编译器&#x2F;链接器合并这些相同的二进制代码怎么办呢？很遗憾，主流的工具链 ld &#x2F; lld &#x2F; ms linker 都不会做这种合并。目前唯一支持这个特性的链接器是 <a href="https://www.gnu.org/software/binutils/">gold</a>，但是它只能用于链接 elf 格式的可执行文件，所以没法在 Windows 上面使用了。下面我展示一下：如何使用它合并相同的二进制代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    std::<span class="type">size_t</span> x;</span><br><span class="line"></span><br><span class="line">    [[gnu::noinline]] <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;X&lt;%zu&gt;::f() called\n&quot;</span>, x); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span>... Is&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_f</span><span class="params">(std::index_sequence&lt;Is...&gt;)</span> </span>&#123;</span><br><span class="line">    ((X&lt;Is&gt;&#123;Is&#125;).<span class="built_in">f</span>(), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">call_f</span>(std::make_index_sequence&lt;<span class="number">100</span>&gt;&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里通过模板生成了<code>100</code>个不同的类型，但是实际上它们底层都是<code>size_t</code>类型，所以进行最终编译生成的二进制代码是完全相同的。使用如下命令尝试编译它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ -O2 -ffunction-sections -fuse-ld=gold -Wl,--icf=all main.cpp -o main.o</span><br><span class="line">$ objdump -d main.o | c++filt</span><br></pre></td></tr></table></figure>

<p>使用<code>-fue-ld=gold</code>指定链接器，<code>-Wl,--icf=all</code>指定链接器选项。<code>icf</code>即意味着<code>identical code folding</code>，即相同代码折叠。因为链接器只在 section 级别上工作，所以 GCC 则需要配合开启<code>-ffunction-sections</code>，上面的编译器也可以替换成<code>clang</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000000000000740 &lt;X&lt;99ul&gt;::f() [<span class="built_in">clone</span> .isra.0]&gt;:</span><br><span class="line"> 740:   48 89 fa                mov    %rdi,%rdx</span><br><span class="line"> 743:   48 8d 35 1a 04 00 00    lea    0x41a(%rip),%rsi</span><br><span class="line"> 74a:   bf 01 00 00 00          mov    <span class="variable">$0x1</span>,%edi</span><br><span class="line"> 74f:   31 c0                   xor    %eax,%eax</span><br><span class="line"> 751:   e9 ca fe ff ff          jmp    620 &lt;_init+0x68&gt;</span><br><span class="line"> 756:   66 2e 0f 1f 84 00 00    cs nopw 0x0(%rax,%rax,1)</span><br><span class="line"> 75d:   00 00 00 </span><br><span class="line"></span><br><span class="line">0000000000000760 &lt;void call_f&lt;0..99&gt;(std::integer_sequence&lt;unsigned long, 0..99&gt;) [<span class="built_in">clone</span> .isra.0]&gt;:</span><br><span class="line"> 760:   48 83 ec 08             sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line"> 764:   31 ff                   xor    %edi,%edi</span><br><span class="line"> 766:   e8 d5 ff ff ff          call   740 &lt;X&lt;99ul&gt;::f() [<span class="built_in">clone</span> .isra.0]&gt;</span><br><span class="line"> ... <span class="comment"># 重复 98 次</span></span><br><span class="line"> b48:   e9 f3 fb ff ff          jmp    740 &lt;X&lt;99ul&gt;::f() [<span class="built_in">clone</span> .isra.0]&gt;</span><br><span class="line"> b4d:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>对输出内容进行了一些筛选，可以发现，gold 把二进制完全相同的 100 个模板函数合并成一个了，所谓的”模板膨胀”消失了。相比之下，前面那些那些不做这种合并的链接器，就自然就有额外的开销了。</p>
<p>但是 gold 并不是万能的，有些情况不能很好的处理。假设这 100 个函数，前<code>90%</code>的代码相同，但是最后<code>10%</code>的代码不相同，那么它就无能为力了。它只是简单的对比最终生成的二进制，然后合并完全相同的函数。那么还有其他的解决办法吗？**自动挡没有，咱们还有手动挡呢，咱写 C++ 的没什么别的擅长的，就擅长开手动挡。 **</p>
<h2 id="手动优化模板膨胀问题"><a href="#手动优化模板膨胀问题" class="headerlink" title="手动优化模板膨胀问题"></a>手动优化模板膨胀问题</h2><p>下面以大家最常用的<code>vector</code>为例，展示一下解决模板膨胀的主要思路。前面已经提到了，像迭代器接口这样的短函数，我们是不需要去管的。我们主要来处理那些逻辑比较复杂的函数，对 vector 来说，首当其冲的就是扩容函数了</p>
<p>假设我们有如下<code>vector</code>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vector</span> &#123;</span><br><span class="line">    T* m_Begin;</span><br><span class="line">    T* m_End;</span><br><span class="line">    T* m_Capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">grow</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑一个<code>vector</code>扩容的朴素实现，暂不考虑异常安全</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">grow</span>(std::<span class="type">size_t</span> n) &#123;</span><br><span class="line">    T* new_date = <span class="built_in">static_cast</span>&lt;T*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(n * <span class="built_in">sizeof</span>(T)));</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_move_constructible_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">uninitialized_move</span>(m_Begin, m_End, new_date);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::<span class="built_in">uninitialized_copy</span>(m_Begin, m_End, new_date);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">destroy</span>(m_Begin, m_End);</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(m_Begin)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑看起来还挺简单的。但是毫无疑问，它算是一个较复杂的函数了，尤其是当对象的构造函数被内联的话，代码量也是比较大的。那如何合并呢？注意，合并模板的前提是找出不同模板实例的相同部分，如果一个函数为不同的类型生成完全不同的代码，那是没法合并的。</p>
<p>那对于<code>vector</code>来说，如果 T 里面的元素类型不同，扩容逻辑还能相同吗？考虑到构造函数调用，似乎没任何办法。关键点来了，这里需要介绍一个<code>trivially_relocatable</code>的概念，具体的讨论可以参考</p>
<p><a target="_blank" href="https://16bit-ykiko.github.io/about-me/679782886" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">全新的构造函数，C++ 中的 relocate 构造函数</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://16bit-ykiko.github.io/about-me/679782886</span></span></span></a></p>
<p>我们这里只说结果，如果一个类型是<code>trivially_relocatable</code>的，那么可以使用<code>memcpy</code>把它从旧内存移动到新内存，不需要调用构造函数了。</p>
<p>考虑编写如下的扩容函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trivially_grow</span><span class="params">(<span class="type">char</span>*&amp; begin, <span class="type">char</span>*&amp; end, <span class="type">char</span>*&amp; capacity, std::<span class="type">size_t</span> n, std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* new_data = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(n * size));</span><br><span class="line">    std::<span class="built_in">memcpy</span>(new_data, begin, (end - begin) * size);</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(begin)</span></span>;</span><br><span class="line">    begin = new_data;</span><br><span class="line">    end = new_data + (end - begin);</span><br><span class="line">    capacity = new_data + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将原来的<code>grow</code>实现转发到这个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">grow</span>(std::<span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_trivially_relocatable_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">trivially_grow</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&amp;&gt;(m_Begin), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&amp;&gt;(m_End), </span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&amp;&gt;(m_Capacity), n, <span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原来的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了抽取公共逻辑。于是所有的<code>T</code>只要满足<code>trivially_relocatable</code>，就可以全都这共享一份代码了。而几乎所有不含有自引用的类型都符合这个条件，于是<code>99%</code>的类型都使用同一套扩容逻辑！这样的优化效果是非常显著的！实际上 LLVM 很多容器的源码，比如 <code>SmallVector</code>,<code>StringMap</code>等等，都使用了这样的技巧。另外如果你觉得上面的<code>reinterpret_cast</code>破坏了严格别名，用起来有点害怕，你可以通过继承来实现相同的效果（基类成员用<code>void*</code>），具体的代码就不展示了。</p>
<h1 id="异常导致的代码膨胀！"><a href="#异常导致的代码膨胀！" class="headerlink" title="异常导致的代码膨胀！"></a>异常导致的代码膨胀！</h1><p>为什么 LLVM 源码禁用异常？很多人可能会下意识的认为，原因是异常很慢，效率很低。但其实，根据 <a href="https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions">LLVM Coding Standard</a> 里面的内容，关闭异常和<code>RTTI</code>的主要目的是为了减少二进制大小。据说，打开异常和<code>RTTI</code>会导致 LLVM 的编译结果膨胀<code>10%-15%</code>，那么实际情况究竟如何？</p>
<p>目前主要的异常实现有两种，一种是 Itanium ABI 的实现，另一种则是 MS ABI 的实现。简单来说 MS ABI 采用运行时查找的办法，这样会导致异常在 Happy Path 执行也有的额外运行时开销，但是优点是最终生成的二进制代码相对较小。而 Itanium ABI 则是我们今天的主角，它号称零开销异常，Happy 路径没有任何额外的运行时开销。那古尔丹，代价是什么？代价就是非常严重的二进制膨胀。为什么会产生膨胀呢？简单来说，就是如果不想完全等到运行时去查找，那就得预先打表。由于异常的隐式传播特性，会导致表占用空间很大。具体实现细节非常复杂，不是本文的主题，放张图，大概感受一下</p>
<p>那我们主要讨论什么呢？异常会导致二进制膨胀，这个没什么好怀疑的。我们主要看看如何减少异常产生的二进制膨胀，以 Itanium ABI 为例</p>
<p>先来看下面这段示例代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 外部链接函数，可能抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">12</span>)</span></span>; <span class="comment">// 拥有 non-trivial 的析构函数</span></span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里<code>foo</code>是一个外部链接的函数，可能会抛出异常。另外就是<code>vector</code>的析构函数调用是在<code>foo</code>之后的。如果<code>foo</code>抛出异常，控制流不知道跳转到什么地方了，那么<code>vetcor</code>的析构函数可能被跳过调用了，如果编译器不做些特殊处理的话，就会导致内存泄露了。先只打开<code>-O2</code>看看程序编译的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bar():</span><br><span class="line">        ...</span><br><span class="line">        call    operator new(unsigned long)</span><br><span class="line">        ...</span><br><span class="line">        call    foo()</span><br><span class="line">        ...</span><br><span class="line">        jmp     operator delete(void*, unsigned long)</span><br><span class="line">        mov     rbp, rax</span><br><span class="line">        jmp     .L2</span><br><span class="line">bar() [<span class="built_in">clone</span> .cold]:</span><br><span class="line">.L2:</span><br><span class="line">        mov     rdi, rbx</span><br><span class="line">        mov     esi, 48</span><br><span class="line">        call    operator delete(void*, unsigned long)</span><br><span class="line">        mov     rdi, rbp</span><br><span class="line">        call    _Unwind_Resume</span><br></pre></td></tr></table></figure>

<p>省略掉不重要的部分，和我们刚才猜的大致相同。那这个<code>.L2</code>是干嘛的呢？这个其实就是异常被<code>catch</code>处理完后会跳转到这个<code>L2</code>把之前没处理完的工作做完（这里就是析构之前未析构的对象），之后再<code>Resume</code>回到先前的位置。</p>
<p>我们稍微调整下代码，把<code>foo</code>调用移动到<code>vector</code>构造的前面，其它什么都不变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bar():</span><br><span class="line">        sub     rsp, 8</span><br><span class="line">        call    foo()</span><br><span class="line">        mov     edi, 48</span><br><span class="line">        call    operator new(unsigned long)</span><br><span class="line">        ...</span><br><span class="line">        jmp     operator delete(void*, unsigned long)</span><br></pre></td></tr></table></figure>

<p>可以发现没有生成清理栈的代码了，很合理。原因很简单，如果<code>foo</code>抛出异常，控制流直接跳转走了，那<code>vector</code>都没构造呢，自然也不需要析构了。通过简单的调整调用顺序就减少了二进制大小！但是，只有这种特别简单的情况下，依赖关系才比较明显。如果实际抛出异常的函数很多的话，就很难分析了。</p>
<h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><p>先讨论 C++11 加入的这个<code>noexcept</code>。注意即使加了<code>noexcept</code>，这个函数还是可能会抛出异常的，如果该函数抛出异常，程序直接<code>terminate</code>。那你可能要问了，这玩意有啥用呢？我异常抛了，不捕获不也是<code>terminate</code>吗？</p>
<p>其实这个和 const 有点类似，你想改 const 变量，虽然是 undefined behavior，但是运行时随便改呀，限制不多。那你要问了， const 有什么意义？一个重要的意义是给编译器提供优化指示信息。编译器可以利用这个做  和 。</p>
<p><code>noexcept</code>也是类似的，它让编译器假设这个函数不会抛出异常，从而可以进行一些额外的优化。 还是第一个例子里面的代码为例，唯一的改变是把<code>foo</code>函数声明为了<code>noexcept</code>，然后再次编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bar():</span><br><span class="line">        push    rbx</span><br><span class="line">        mov     edi, 48</span><br><span class="line">        call    operator new(unsigned long)</span><br><span class="line">        ...</span><br><span class="line">        call    foo()</span><br><span class="line">        ...</span><br><span class="line">        jmp     operator delete(void*, unsigned long)</span><br></pre></td></tr></table></figure>

<p>可以发现，用于异常处理的代码路径，同样没有了，这就是<code>noexpect</code>的功劳。 </p>
<h2 id="fno-exceptions"><a href="#fno-exceptions" class="headerlink" title="fno-exceptions"></a>fno-exceptions</h2><p>终于讲到重头戏了：<code>-fno-exceptions</code>，注意这个选项非标准。但是三大编译器都有提供，不过具体的实现效果有些许差异。好像并没有十分详细的文档，我仅凭经验说一下 GCC 相关的，对于 GCC 来说，该选项会禁止用户的代码里面使用<code>try</code>,<code>catch</code>,<code>throw</code>等关键字，如果使用则导致编译错误。但是特别的，允许使用标准库。如果异常被抛出，就和<code>noexcept</code>一样，程序直接<code>terminate</code>。所以如果打开了这个选项，GCC 会默认假设所有函数不会抛出异常。</p>
<p>仍然是上面的例子，我们尝试打开<code>-fno-exceptions</code>，然后再次编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bar():</span><br><span class="line">        push    rbx</span><br><span class="line">        mov     edi, 48</span><br><span class="line">        call    operator new(unsigned long)</span><br><span class="line">        ...</span><br><span class="line">        call    foo()</span><br><span class="line">        ...</span><br><span class="line">        jmp     operator delete(void*, unsigned long)</span><br></pre></td></tr></table></figure>

<p>可以发现和<code>noexcept</code>产生的效果类似，它们都会让编译器假设某个函数不会抛出异常，从而不需要生成清理栈的额外代码,达到减少程序二进制大小的效果。</p>
<hr>
<p>这篇文章涉及到的话题跨度有点大，某些地方有错误在所难免，欢迎评论区讨论交流   (^ω^)</p>
]]></content>
  </entry>
  <entry>
    <title>超好用的 C++ 在线编译器（VSCode 版）</title>
    <url>/694365783/</url>
    <content><![CDATA[<p><a href="https://godbolt.org/">Compiler Explorer</a> 是一个非常流行的 C++ 在线编译器，可用于测试不同的编译执行环境，或者分享代码。作为一个 C++ 爱好者，我几乎每天都要和它打交道，使用频率之高远超我的想象。同时，我也是一个重度 VSCode 用户，几乎所有的事情都在 VSCode 中完成。考虑到经常在本地写代码然后拷贝到 Compiler Explorer 上去，总觉得不太舒服，有时候直接就在它的网页编辑器上改了，但是又没有代码补全，也不舒服。所以我和 <a href="https://www.zhihu.com/people/32ffceca937677f7950b64e5186bb998">@iiirhe</a> 合作编写了这个插件 <a href="https://marketplace.visualstudio.com/items?itemName=ykiko.vscode-compiler-explorer">Compiler Explorer for VSCode</a>，基于 Compiler Explorer 提供的 <a href="https://github.com/compiler-explorer/compiler-explorer/blob/main/docs/API.md">API</a> 将 Compiler Explorer 集成到 VSCode 中，使得用户可以在 VSCode 中直接使用 Compiler Explorer 的功能。</p>
<p>现在你可以在 VSCode 插件市场搜索到这个插件</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h2 id="单文件支持"><a href="#单文件支持" class="headerlink" title="单文件支持"></a>单文件支持</h2><p>让我们从上往下以此介绍 </p>
<p>这个三个按钮的功能依次是： </p>
<ul>
<li><code>Compile All</code>：编译所有的编译器实例 </li>
<li><code>Add New</code>：添加一个新的编译器实例 </li>
<li><code>Share Link</code>：根据当前的编译器实例生成一个链接，并复制到剪贴板</li>
</ul>
<p> 这四个按钮的功能依次是： </p>
<ul>
<li><code>Add CMake</code>：添加一个 CMake 编译器实例（后面会细说） </li>
<li><code>Clear All</code>：关闭所有用于展示的<code>webview</code>面板 </li>
<li><code>Load Link</code>：根据输入的链接加载编译器实例的信息 </li>
<li><code>Remove All</code>：删除所有的编译器实例</li>
</ul>
<p> 这个三个按钮的功能依次是： </p>
<ul>
<li><code>Run</code>：编译这个编译器实例 </li>
<li><code>Clone</code>：克隆这个编译器实例 </li>
<li><code>Remove</code>：删除这个编译器实例</li>
</ul>
<p>下面这些用于设置编译器实例的参数：</p>
<ul>
<li><code>Compiler</code>：点击右侧的按钮可以选择编译器版本</li>
<li><code>Input</code>：选择源代码文件，默认是<code>active</code>即当前活跃的编辑器</li>
<li><code>Output</code>：输出编译结果的文件，默认使用<code>webview</code></li>
<li><code>Options</code>：编译选项，点击右侧按钮可以打开输入框</li>
<li><code>Execute Arguments</code>：传递给可执行文件的参数</li>
<li><code>Stdin</code>：用于标准输入的缓冲区</li>
<li><code>Filters</code>：一些选项</li>
</ul>
<h2 id="多文件支持"><a href="#多文件支持" class="headerlink" title="多文件支持"></a>多文件支持</h2><p>使用<code>Add CMake</code>按钮可以添加一个 CMake 编译器实例，这个实例可以用于编译多个文件。</p>
</br>

<p>大部分选项和单文件的编译器实例一样，额外多出了两个 </p>
<ul>
<li><code>CMake Arguments</code>：传递给 CMake 的参数</li>
<li><code>Source</code>：CMakelists.txt 所在的文件夹路径</li>
</ul>
<p>注意，由于多文件编译需要把所有用到的文件都上传到服务器，所以我们默认会读取你指定的目录下的所有文件（无论后缀名），<strong>所以目前请不要指定文件数量过多的文件夹</strong>。之后可能会添加一些选项允许用户过滤掉一些文件，但是目前还没有。</p>
<h2 id="一些用户设置"><a href="#一些用户设置" class="headerlink" title="一些用户设置"></a>一些用户设置</h2><p><code>compiler-explorer.default.options</code>：使用<code>+</code>号创建编译器时的默认参数</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;compiler-explorer.default.options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The default compiler configuration&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compiler&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x86-64 gcc 13.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exec&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stdin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cmakeArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workspace&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;binaryObject&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;binary&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;execute&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;intel&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;demangle&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;labels&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;libraryCode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;directives&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;commentOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;trim&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;debugCalls&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>compiler-explorer.default.color</code>：用于指定高亮汇编代码时的颜色</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;compiler-explorer.default.color&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;symbol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#61AFEF&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;string&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#98C379&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#D19A66&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;register&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E5C07B&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;instruction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#C678DD&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;comment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#7F848E&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;operator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ABB2BF&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>compiler-explorer.default.url</code>：用于打开插件时默认加载的链接，默认是空</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;compiler-explorer.default.url&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="问题反馈"><a href="#问题反馈" class="headerlink" title="问题反馈"></a>问题反馈</h2><p>该插件还处于早期阶段，如果你在使用过程中遇到了问题，或者有任何建议，欢迎在 <a href="https://github.com/16bit-ykiko/vscode-compiler-explorer">GitHub</a> 上留言讨论。或者添加 QQ 群：<code>662499937</code>。</p>
<p>另外 Output 窗口可能会提供一些有用的信息，可以注意检索</p>
]]></content>
  </entry>
  <entry>
    <title>C++ 中的单例模式真的“单例”吗？</title>
    <url>/696878184/</url>
    <content><![CDATA[<p><strong>单例模式 (Singleton Pattern)</strong> 是一种常见的设计模式，往往应用于配置系统，日志系统，数据库连接池等需要确保对象唯一性的场景。但是单例模式真的能保证单例吗？如果唯一性得不到保证会产生什么后果呢？</p>
<p>既然写了这篇文章，那答案肯定是否了。知乎上已经有很多相关的讨论了，比如 <a href="https://www.zhihu.com/question/425920019/answer/2254241454">C++单例模式跨 DLL 是不是就是会出问题？</a> 和 <a href="https://zhuanlan.zhihu.com/p/354694011">动态库和静态库混合使用下的单例模式 BUG</a>。不过大部分都是遇到问题以后，贴一下解决方案，很零散，并没有系统分析问题产生的原因。于是，我写了这篇文章来详细讨论一下这个问题。</p>
<h1 id="明确问题"><a href="#明确问题" class="headerlink" title="明确问题"></a>明确问题</h1><p>首先我们要明确讨论的问题，以 C++11 常见的单例模式实现为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们将默认构造设置为<code>private</code>并且显式<code>delete</code>拷贝构造和赋值运算符，这样的话用户只能通过<code>instance</code>这个函数来获取我们预先创建好的对象，不能自己通过构造函数创建一个对象。而使用静态局部变量是为了保证这个变量的初始化线程安全。</p>
<p>但其实，单例对象和一个普通的全局变量并没有什么区别。在 C++ 中，它们都属于 <a href="https://en.cppreference.com/w/cpp/language/storage_duration">静态储存期 (static storage duration)</a>，编译器对它们的处理是类似的（只是初始化方式上有点区别）。而所谓的单例模式，只是在语言层面通过一些手段，防止用户不小心创建多个对象。</p>
<p>那我们讨论的问题其实可以等价为：<strong>C++ 中的全局变量是唯一的吗？</strong></p>
<h1 id="一个定义"><a href="#一个定义" class="headerlink" title="一个定义"></a>一个定义</h1><p>首先得区分变量的声明和定义。我们都知道，头文件中一般是不能写变量定义的。否则如果这个头文件被多个源文件包含，就会出现多个定义，链接的时候就会报<code>multiple definition of variable</code>的错误。所以我们一般会在头文件中使用<code>extern</code>声明变量，然后在对应的源文件中定义变量。</p>
<p>那编译器是如何处理全局变量定义的呢？</p>
<p>假设我们定义一个全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其实不会产生任何的指令，编译器会在这个编译单元（每个源文件）编译产物的符号表中，增加一个符号<code>x</code>。在静态储存（具体的实现可能是 bss 段或者 rdata 段等等）中给符号<code>x</code>预留<code>4</code>字节的空间。视初始化方式（<a href="https://en.cppreference.com/w/cpp/language/initialization#Static_initialization">静态初始化</a> 或者 <a href="https://en.cppreference.com/w/cpp/language/initialization#Dynamic_initialization">动态初始化</a>）来决定这块内存的数据如何填充。</p>
<p>由于只有一个定义，那么这种情况肯定是全局唯一的了。</p>
<h1 id="多个定义"><a href="#多个定义" class="headerlink" title="多个定义"></a>多个定义</h1><p>我们都知道 C++ 并没有官方的构建系统，不同的库使用不同的构建系统，就不方便互相使用了（目前的事实标准来看是 cmake）。这个现状使得 header-only 库变得越来越流行，<code>include</code>即用，谁不喜欢呢？但是 header-only 也就意味着所有的代码都写在头文件中，如何在头文件中定义变量并且使得它能直接被多个源文件包含而不导致链接错误呢？</p>
<p>在 C++17 之前，并没有直接的办法。但有一些间接的办法，考虑到<code>inline</code>函数或者模板函数的定义都可以出现在多个源文件中，并且 C++ 标准保证它们具有相同的地址（相关的讨论可以参考 <a href="https://16bit-ykiko.github.io/about-me/686296374">C++ 究竟代码膨胀在哪里？</a>）。于是只需要在这些函数中定义静态局部变量，效果上就相当于在头文件中定义变量了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span>&amp; <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="type">void</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++17 之后，我们可以直接使用<code>inline</code>来标记变量，使得这个变量的定义可以出现在多个源文件中。使用它，我们就可以直接在头文件中定义变量了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们知道，把变量标记为<code>static</code>也可以使得它在多个源文件中出现定义。那<code>inline</code>和<code>static</code>有什么区别呢？关键就在于，<code>static</code>标记的变量是内部链接的，每个编译单元都有自己的一份实例，你在不同的编译单元取的地址是不一样的。而<code>inline</code>标记的变量是外部链接的，C++ 标准保证你在不同编译单元取同一个<code>inline</code>变量的地址是一样的。</p>
<h1 id="真的单例吗"><a href="#真的单例吗" class="headerlink" title="真的单例吗"></a>真的单例吗</h1><p>实践是检验真理的唯一标准，我们来实验一下，C++ 标准有没有骗我们呢？</p>
<p>示例代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addreress of x in src: %p\n&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addreress of x in main: %p\n&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先简单一点，把这两个源文件一起编译成一个可执行文件，在 Windows(MSVC) 上和 Linux(GCC) 上分别尝试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Windows:</span></span><br><span class="line">addreress of x <span class="keyword">in</span> main: 00007FF7CF84C000</span><br><span class="line">addreress of x <span class="keyword">in</span> src: 00007FF7CF84C000</span><br><span class="line"><span class="comment"># Linux:</span></span><br><span class="line">addreress of x <span class="keyword">in</span> main: 0x404018</span><br><span class="line">addreress of x <span class="keyword">in</span> src: 0x404018</span><br></pre></td></tr></table></figure>

<p>可以发现确实是相同的地址。下面我们试一下把<code>src.cpp</code>编译成动态库，<code>main.cpp</code>链接这个库，编译运行。看看是不是像很多人说的那样，一遇到动态库就不行了呢？注意在 Windows 上要显式给<code>foo</code>加上<code>__declspec(dllexport)</code>，否则动态库不会导出这个符号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Windows:</span></span><br><span class="line">addreress of x <span class="keyword">in</span> main: 00007FF72F3FC000</span><br><span class="line">addreress of x <span class="keyword">in</span> src: 00007FFC4D91C000</span><br><span class="line"><span class="comment"># Linux:</span></span><br><span class="line">addreress of x <span class="keyword">in</span> main: 0x404020</span><br><span class="line">addreress of x <span class="keyword">in</span> src: 0x404020</span><br></pre></td></tr></table></figure>

<p>夭寿啦，为什么 Windows 和 Linux 的情况不一样呢？</p>
<h1 id="符号导出"><a href="#符号导出" class="headerlink" title="符号导出"></a>符号导出</h1><p>一开始，我简单的以为是动态库默认符号导出规则的问题。因为 GCC 编译动态库的时候，会默认把所有符号导出。而 MSVC 恰恰相反，默认不导出任何符号，全部都要手动导出。显然只有一个符号被导出了，链接器才能“看见”它，然后才能合并来自不同动态库的符号。</p>
<p>抱着这个想法，我尝试寻找在 GCC 上自定义符号导出的手段，最终找到了 <a href="https://gcc.gnu.org/wiki/Visibility">Visibility - GCC Wiki</a>。在编译的时候使用<code>-fvisibility=hidden</code>，这样的话符号就都是默认 hidden（不导出）了。然后使用<code>__attribute__((visibility(&quot;default&quot;)))</code>或者它在 C++ 的等价写法<code>[[gnu::visibility(&quot;default&quot;)]]</code>来显式标记需要导出的符号。于是我修改了代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addreress of x in src: %p\n&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addreress of x in main: %p\n&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我只导出了<code>foo</code>用于函数调用，这两个<code>inline</code>变量都没有导出。编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addreress of x <span class="keyword">in</span> main: 0x404020</span><br><span class="line">addreress of x <span class="keyword">in</span> src: 0x7f5a45513010</span><br></pre></td></tr></table></figure>

<p>就像我们预期的那样，地址果然不一样。这就验证了：符号被导出，是链接器合并符号的必要条件，但是并不充分。如果在 Windows 上能通过改变默认符号导出规则，使得 inline 变量具有相同的地址，那么充分性就得到验证。当我满怀激动的开始尝试，却发现事情并非这么简单。</p>
<p>注意到 Windows 上的 GCC（MinGW64 工具链）仍然默认导出所有符号，按照设想，变量地址应该相同。尝试结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addreress of x <span class="keyword">in</span> main: 00007ff664a68130</span><br><span class="line">addreress of x <span class="keyword">in</span> src: 00007ffef4348110</span><br></pre></td></tr></table></figure>

<p>可以发现结果并不相同，我不理解，并认为是编译器的 BUG。转而使用 MSVC，并且发现 CMake 提供了一个 <a href="https://cmake.org/cmake/help/latest/prop_tgt/WINDOWS_EXPORT_ALL_SYMBOLS.html">CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS</a> 选项，打开之后会自动导出所有符号（通过 dumpbin 实现的）。遂尝试，编译运行，结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addreress of x <span class="keyword">in</span> main: 00007FF60B11C000</span><br><span class="line">addreress of x <span class="keyword">in</span> src: 00007FFEF434C000</span><br></pre></td></tr></table></figure>

<p>哦，结果还是不同，我意识到我的猜测出问题了。但是查阅了很久资料，也没找到为什么。后来还是在 TG 的 C++ 群提问，才得到了答案。</p>
<p>简单来说，在 ELF 不区分符号是来自哪个<code>.so</code>的，先加载谁就用谁，所以遇到多个<code>inline</code>变量就使用第一个加载的。但是 <code>PE</code> 文件的符号表指定了某个符号从哪个<code>dll</code>引入，这样就会导致只要一个变量<code>dllexport</code>了，那么这个 dll 一定会使用自己的变量。即使多个<code>dll</code>同时<code>dllexport</code>同一个变量，也没法合并，Windows 上 dll 的格式就限制了这件事情是做不到的。</p>
<p>动态库链接时的符号解析问题实际上可能还要复杂的得多，还有很多其它的情况，例如通过<code>dlopen</code>等函数主动加载动态库。之后有时间的话，可能会专门写一篇文章来分析这个事情，这里就不多说了。</p>
<h1 id="不唯一如何？"><a href="#不唯一如何？" class="headerlink" title="不唯一如何？"></a>不唯一如何？</h1><p>为什么要保证“单例”变量的唯一性呢？这里拿 C++ 标准库来举例子</p>
<p>我们都知道 <a href="https://en.cppreference.com/w/cpp/types/type_info">type_info</a> 可以用于运行时区分不同的类型，标准库的<code>std::function</code>和<code>std::any</code>这些类型擦除的设施就依赖于它来实现。它的<code>constructor</code>和<code>operator=</code>就被<code>deleted</code>了，我们只能通过<code>typeid(T)</code>来获取对应<code>type_info</code>对象的引用，对象的创建则由编译器来负责。</p>
<p>怎么样，是不是完全符合单例模式呢？下一个问题是，编译器是如何判断两个<code>type_info</code>对象是否相同的呢？一个典型的实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> _PLATFORM_SUPPORTS_UNIQUE_TYPEINFO</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> type_info&amp; __rhs) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> __mangled_name == __rhs.__mangled_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> type_info&amp; __rhs) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> __mangled_name == __rhs.__mangled_name ||</span><br><span class="line">             <span class="built_in">strcmp</span>(__mangled_name, __rhs.__mangled_name) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面的代码很好理解，如果保证<code>type_info</code>的地址是唯一的，那么直接比较<code>__mangled_name</code>就行了（它是<code>const char*</code>所以是指针比较）。若不然，就先比较地址然后比较类型名。具体到三大标准库的实现：</p>
<ul>
<li><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/tinfo.cc#L39">libstdc++</a> 使用<code>__GXX_MERGED_TYPEINFO_NAMES</code>来控制是否启用</li>
<li><a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/typeinfo#L197">libc++</a> 使用<code>_LIBCPP_TYPEINFO_COMPARATION_IMPLEMENTATION</code>来决定采用的方式（实际上还有一种特殊的 BIT_FLAG 模式）</li>
<li>msvc stl (crt&#x2F;src&#x2F;vcruntime&#x2F;std_type_info.cpp) 由于前面提到的 Windows 上 dll 的限制，总是使用第二种方式</li>
</ul>
<p>举这个例子的目的是，为了说明，单例变量地址的唯一性会影响我们代码的编写方式。如果不唯一我们可能被迫要书写一些代码进行防御，可能会影响性能，而如果没写的话，甚至会直接导致逻辑错误。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>只提出问题可不行，得要解决，如何确保单例唯一呢？</p>
<p>在 Linux 上就很简单了，如果同一个变量出现在多个动态库中，只要确保这些动态库都把这个符号设置为对外可见就行了。而编译器默认的行为也就是对外可见，所以基本上不用担心这个问题。</p>
<p>在 Windows 上呢？非常麻烦了，必须要确保只有一个 dll 使用<code>dllexport</code>导出了这个符号，其它所有的<code>dll</code>必须要使用<code>dllimport</code>。这件事情常常不太好做，你可能写着写着就忘记，是哪个 dll 负责导出的这个符号了。怎么办呢？那就是专门用一个 dll 来管理所有的单例变量，也就是说这个 dll 负责所有<code>dllexport</code>所有的单例变量，除此之外的 dll 都只 dllimport 就行了。之后添加和修改都在这个 dll 中进行，这样就比较好管理了。</p>
<p>到这文章就结束了，说实话我并不确定上面的讨论有没有覆盖所有的情形。如果有错误欢迎评论区留言讨论。</p>
]]></content>
  </entry>
  <entry>
    <title>Python 与 C++ 的完美结合：pybind11 中的对象设计</title>
    <url>/702197261/</url>
    <content><![CDATA[<p>参加了 <a href="https://summerofcode.withgoogle.com/programs/2024/projects/Ji2Mi97o">Google Summer of Code 2024</a>，主要的任务就是为一个 <a href="https://pocketpy.dev/">Python 解释器</a> 实现 <a href="https://github.com/pybind/pybind11">pybind11</a> 的兼容性接口。说是实现兼容性接口，实际上相当于重写 pybind11 了，所以最近一直在读它的源码。</p>
<blockquote>
<p> 可能有的读者不太清楚 pybind11 是什么，简单来说 pybind11 是一个中间件，让你可以方便进行 Python 与 C++ 代码之间的交互。比如在 C++ 中内嵌 Python 解释器，或者把 C++ 代码编译成动态库以供 Python 调用。具体的内容还请见官方文档。</p>
</blockquote>
<p>最近基本把框架的大体的运作逻辑理清了。现在回过头来看，pybind11 不愧是 C++ 和 Python 绑定的事实标准，有很多巧妙的设计。它这套交互逻辑也完全可以套用到 C++ 和其它有 GC 的语言的交互上，比如 JS 和 C#（虽然现在并没有 jsbind11 和 csharpbind11 之类的东西）。最近可能我会写一系列相关的文章，去掉一些繁琐的细节，介绍其中一些共用的思想。</p>
<p>这篇文章主要是讨论 pybind11 对象设计一些有意思的点。</p>
<h1 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h1><p>我们都知道 Python 中，一切皆对象，全都是<code>object</code>。但是 pybind11 实际上是需要和 CPython 这种 Python 的具体实现打交道的。那一切皆对象在 CPython 中的体现是什么呢？答案是<code>PyObject*</code>。接下来让我们“看见” Python，理解实际的 Python 代码是如何运作在 CPython 中的。</p>
<p>创建一个对象实际上就是创建一个<code>PyObject*</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>CPython 中有专门的 API 来创建内建类型的对象，上面这句话大概就会被翻译成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* x = PyList_New(<span class="number">3</span>);</span><br><span class="line">PyList_SetItem(x, <span class="number">0</span>, PyLong_FromLong(<span class="number">1</span>));</span><br><span class="line">PyList_SetItem(x, <span class="number">1</span>, PyLong_FromLong(<span class="number">2</span>)); </span><br><span class="line">PyList_SetItem(x, <span class="number">2</span>, PyLong_FromLong(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>这样的话，<code>is</code>的作用就很好理解了，就是用来判断两个指针的值是否相同。而所谓的默认浅拷贝的原因也就是因为默认的赋值只是指针的赋值，不涉及它指向的元素。</p>
<p>CPython 也提供了一系列的 API 用来操作 <code>PyObject*</code> 指向的对象，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallObject</span><span class="params">(PyObject *callable_object, PyObject *args)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallFunction</span><span class="params">(PyObject *callable_object, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallMethod</span><span class="params">(PyObject *o, <span class="type">const</span> <span class="type">char</span> *method, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallFunctionObjArgs</span><span class="params">(PyObject *callable, ...)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallMethodObjArgs</span><span class="params">(PyObject *o, PyObject *name, ...)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_GetAttrString</span><span class="params">(PyObject *o, <span class="type">const</span> <span class="type">char</span> *attr_name)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_SetAttrString</span><span class="params">(PyObject *o, <span class="type">const</span> <span class="type">char</span> *attr_name, PyObject *v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PyObject_HasAttrString</span><span class="params">(PyObject *o, <span class="type">const</span> <span class="type">char</span> *attr_name)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_GetAttr</span><span class="params">(PyObject *o, PyObject *attr_name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PyObject_SetAttr</span><span class="params">(PyObject *o, PyObject *attr_name, PyObject *v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PyObject_HasAttr</span><span class="params">(PyObject *o, PyObject *attr_name)</span></span>;</span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_GetItem</span><span class="params">(PyObject *o, PyObject *key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PyObject_SetItem</span><span class="params">(PyObject *o, PyObject *key, PyObject *v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PyObject_DelItem</span><span class="params">(PyObject *o, PyObject *key)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些函数在 Python 中基本都有直接对应，看名字就知道是干什么用的了。</p>
<h1 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h1><p>由于 pybind11 要支持在 C++ 中操作 Python 对象，首要任务就是对上述这些 C 风格的 API 进行封装。具体是由<code>handle</code>这个类型来完成的。<code>handle</code>是对<code>PyObject*</code>的简单包装，并且封装了一些成员函数，例如</p>
<p>大概像下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">handle</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    PyObject* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">handle</span>(PyObject* ptr) : <span class="built_in">m_ptr</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> handle&amp; lhs, <span class="type">const</span> handle&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyObject_RichCompareBool</span>(lhs.m_ptr, rhs.m_ptr, Py_EQ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> handle&amp; lhs, <span class="type">const</span> handle&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyObject_RichCompareBool</span>(lhs.m_ptr, rhs.m_ptr, Py_NE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大部分函数都是像上面这样简单包装一下，但有一些函数比较特殊。</p>
<h1 id="get-set"><a href="#get-set" class="headerlink" title="get&#x2F;set"></a>get&#x2F;set</h1><p>根据 C++ 之父 Bjarne Stroustrup 在《The Design and Evolution of C++》中的说法，引入引用（左值）类型的部分原因是为了使得用户能够对返回值进行赋值，让<code>[]</code>这样的运算符的重载变的更加自然。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> x = v[<span class="number">0</span>]; <span class="comment">// get</span></span><br><span class="line">v[<span class="number">0</span>] = <span class="number">4</span>;     <span class="comment">// set</span></span><br></pre></td></tr></table></figure>

<p>如果没有引用，就只能返回指针，那么上面的代码就得写成这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> x = *v[<span class="number">0</span>]; <span class="comment">// get</span></span><br><span class="line">*v[<span class="number">0</span>] = <span class="number">4</span>;     <span class="comment">// set</span></span><br></pre></td></tr></table></figure>

<p>相比之下，使用引用是不是美观的多呢？这个问题在其它编程语言中也存在，但不是所有语言都采用这种解决办法。例如，Rust 选择自动解引用，编译器在合适的时机自动添加<code>*</code>来解引用，这样也就不需要多写上面那个<code>*</code>了。但是，这两种方法对 Python 来说都不行，因为 Python 中根本没有解引用这个说法，也不区分什么左值和右值。那怎么办呢？答案是区分<code>getter</code>和<code>setter</code>。</p>
<p>例如，如果要重载<code>[]</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__getitem__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__setitem__&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="type">List</span>()</span><br><span class="line">x = a[<span class="number">0</span>] <span class="comment"># __getitem__</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># __setitem__</span></span><br></pre></td></tr></table></figure>

<p>Python 会检查语法结构，如果<code>[]</code> 出现在<code>=</code>的左边，就会调用<code>__setitem__</code>，否则就会调用<code>__getitem__</code>。实际上有挺多语言采用类似的设计的，例如 C# 的<code>this[]</code>运算符重载。</p>
<p>甚至连<code>.</code>运算符都可以重载，只需要重写<code>__getattr__</code>和<code>__setattr__</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__getattr__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__setattr__&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = Point()</span><br><span class="line">x = p.x <span class="comment"># __getattr__</span></span><br><span class="line">p.x = <span class="number">1</span> <span class="comment"># __setattr__</span></span><br></pre></td></tr></table></figure>

<p>pybind11 希望 handle 也能实现这样的效果，即在合适的时机调用<code>__getitem__</code>和<code>__setitem__</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">py::handle obj = py::<span class="built_in">list</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">obj[<span class="number">0</span>] = <span class="number">4</span>; <span class="comment">// __setitem__</span></span><br><span class="line"><span class="keyword">auto</span> x = obj[<span class="number">0</span>]; <span class="comment">// __getitem__</span></span><br><span class="line">x = py::<span class="built_in">int_</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>对应的 Python 代码是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">obj[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">x = obj[<span class="number">0</span>]</span><br><span class="line">x = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="accessor"><a href="#accessor" class="headerlink" title="accessor"></a>accessor</h1><p>接下来就让我们重点讨论如何实现这样的效果。首先考虑<code>operator[]</code>的返回值，由于可能要调用<code>__setitem__</code>，所以这里我们返回一个代理对象。里面会把<code>key</code>存下来以备后续调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">accessor</span> &#123;</span><br><span class="line">    handle m_obj;</span><br><span class="line">    <span class="type">ssize_t</span> m_key;</span><br><span class="line">    handle m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">accessor</span>(handle obj, <span class="type">ssize_t</span> key) : <span class="built_in">m_obj</span>(obj), <span class="built_in">m_key</span>(key) &#123;</span><br><span class="line">        m_value = <span class="built_in">PyObject_GetItem</span>(obj.<span class="built_in">ptr</span>(), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面一个问题就是如何区分<code>obj[0] = 4</code>和<code>x = int_(1)</code>，使得前面一种情况调用<code>__setitem__</code>，后面一种情况就是简单的对<code>x</code>赋值。注意到上面两种情况的关键性区别，左值和右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">obj[<span class="number">0</span>] = <span class="number">4</span>; <span class="comment">// assign to rvalue</span></span><br><span class="line"><span class="keyword">auto</span> x = obj[<span class="number">0</span>]; </span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// assign to lvalue</span></span><br></pre></td></tr></table></figure>

<p>如何让<code>operator=</code>根据操作数的值类别 (value category) 调用不同的函数呢？这就要用到一个比较少见的小技巧了，我们都知道可以在成员函数上加上<code>const</code>限定符，从而允许这个成员函数在 const 对象上调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> A a;</span><br><span class="line">    a.<span class="built_in">foo</span>(); <span class="comment">// error </span></span><br><span class="line">    a.<span class="built_in">bar</span>(); <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，其实还可以加引用限定符<code>&amp;</code>和<code>&amp;&amp;</code>，效果就是要求<code>expr.f()</code>的这个<code>expr</code>是左值还是右值。这样我们就可以根据左值和右值调用不同的函数了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> &amp; </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> &amp;&amp; </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">foo</span>(); <span class="comment">// ok</span></span><br><span class="line">    a.<span class="built_in">bar</span>(); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>().<span class="built_in">bar</span>(); <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">A</span>().<span class="built_in">foo</span>(); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个特性我们就能实现上面的效果了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">accessor</span> &#123;</span><br><span class="line">    handle m_obj;</span><br><span class="line">    <span class="type">ssize_t</span> m_key;</span><br><span class="line">    handle m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">accessor</span>(handle obj, <span class="type">ssize_t</span> key) : <span class="built_in">m_obj</span>(obj), <span class="built_in">m_key</span>(key) &#123;</span><br><span class="line">        m_value = <span class="built_in">PyObject_GetItem</span>(obj.<span class="built_in">ptr</span>(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign to rvalue</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(handle value) &amp;&amp; &#123;</span><br><span class="line">        <span class="built_in">PyObject_SetItem</span>(m_obj.<span class="built_in">ptr</span>(), m_key, value.<span class="built_in">ptr</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign to lvalue</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(handle value) &amp; &#123;</span><br><span class="line">        m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="lazy-evaluation"><a href="#lazy-evaluation" class="headerlink" title="lazy evaluation"></a>lazy evaluation</h1><p>更进一步，我们希望这个代理对象仿佛就像一个<code>handle</code>一样，可以使用<code>handle</code>的所有方法。这很简单，直接继承<code>handle</code>就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">accessor</span> : <span class="keyword">public</span> handle &#123;</span><br><span class="line">    handle m_obj;</span><br><span class="line">    <span class="type">ssize_t</span> m_key;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">accessor</span>(handle obj, <span class="type">ssize_t</span> key) : <span class="built_in">m_obj</span>(obj), <span class="built_in">m_key</span>(key) &#123;</span><br><span class="line">        m_ptr = <span class="built_in">PyObject_GetItem</span>(obj.<span class="built_in">ptr</span>(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign to rvalue</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(handle value) &amp;&amp; &#123;</span><br><span class="line">        <span class="built_in">PyObject_SetItem</span>(m_ptr, m_key, value.<span class="built_in">ptr</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign to lvalue</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(handle value) &amp; &#123;</span><br><span class="line">        m_ptr = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到这似乎就结束了，但是注意到我们的<code>__getitem__</code>是在构造函数中调用的，也就是说即使后面没用到获取到的值，也会调用。感觉有进一步优化的空间，能不能通过一些手段把这个求值 lazy 化呢？只在需要调用<code>handle</code>里面这些函数的时候才去调用<code>__getitem__</code>呢？</p>
<p>目前这样直接继承<code>handle</code>肯定是不行的，不可能在每次成员函数调用之前插入一次判断，然后决定要不要调用<code>__getitem__</code>。可以让<code>handle</code>和<code>accessor</code>都继承一个基类，这个基类里面有一个有一个接口，用来实际获取要操作的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object_api</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PyObject* <span class="title">get</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> handle&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyObject_RichCompareBool</span>(<span class="built_in">get</span>(), rhs.<span class="built_in">ptr</span>(), Py_EQ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后<code>handle</code>和<code>accessor</code>都继承这个基类，这时候<code>accessor</code>就可以在这里对<code>__getitem__</code>进行 lazy evaluation 了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">handle</span> : <span class="keyword">public</span> object_api &#123;</span><br><span class="line">    <span class="function">PyObject* <span class="title">get</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">accessor</span> : <span class="keyword">public</span> handle &#123;</span><br><span class="line">    <span class="function">PyObject* <span class="title">get</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ptr) &#123;</span><br><span class="line">            m_ptr = <span class="built_in">PyObject_GetItem</span>(m_obj.<span class="built_in">ptr</span>(), m_key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样并不涉及到类型擦除，只是需要子类暴露出一个接口，所以理所应当的我们可以使用 <a href="https://en.cppreference.com/w/cpp/language/crtp">CRTP</a> 来去虚化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object_api</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">PyObject* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> handle&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyObject_RichCompareBool</span>(<span class="built_in">get</span>(), rhs.<span class="built_in">ptr</span>(), Py_EQ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">handle</span> : <span class="keyword">public</span> object_api&lt;handle&gt; &#123;</span><br><span class="line">    <span class="function">PyObject* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">accessor</span> : <span class="keyword">public</span> object_api&lt;accessor&gt; &#123;</span><br><span class="line">    <span class="function">PyObject* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ptr) &#123;</span><br><span class="line">            m_ptr = <span class="built_in">PyObject_GetItem</span>(m_obj.<span class="built_in">ptr</span>(), m_key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样我们就在不额外引入其它运行时开销的情况下把<code>__getitem__</code>的调用 lazy 化了。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>我们常说 C++ 实在是太复杂了，各种眼花缭乱的特性太多了，不同特性之间还经常打架。那换一个角度来看待，特性多，意味着用户就有更多的选择，有更多的设计空间，就能组装出上述这样精彩的设计。我想很难有另外一门语言能实现这样的效果。或许这就是 C++ 的魅力所在吧。</p>
<p>文章到这里就结束了，感谢你的阅读，欢迎评论区讨论交流。</p>
]]></content>
  </entry>
</search>
